---
title: "Dates and Time (java.time.*)"
slug: "dates-and-time-javatime"
draft: false
images: []
weight: 9952
type: docs
toc: true
---

## Calculate Difference between 2 LocalDates
Use `LocalDate` and `ChronoUnit`:


    LocalDate d1 = LocalDate.of(2017, 5, 1);
    LocalDate d2 = LocalDate.of(2017, 5, 18);
    

now, since the method `between` of the `ChronoUnit` enumerator takes 2 `Temporal`s as parameters so you can pass without a problem the `LocalDate` instances

    long days = ChronoUnit.DAYS.between(d1, d2);
    System.out.println( days );

## Simple Date Manipulations


## Date and time
Date and time without time zone information

    LocalDateTime dateTime = LocalDateTime.of(2016, Month.JULY, 27, 8, 0);
    LocalDateTime now = LocalDateTime.now();
    LocalDateTime parsed = LocalDateTime.parse("2016-07-27T07:00:00");

Date and time with time zone information

    ZoneId zoneId = ZoneId.of("UTC+2");
    ZonedDateTime dateTime = ZonedDateTime.of(2016, Month.JULY, 27, 7, 0, 0, 235, zoneId);
    ZonedDateTime composition = ZonedDateTime.of(localDate, localTime, zoneId);
    ZonedDateTime now = ZonedDateTime.now(); // Default time zone
    ZonedDateTime parsed = ZonedDateTime.parse("2016-07-27T07:00:00+01:00[Europe/Stockholm]");

Date and time with offset information (i.e. no DST changes taken into account)

    ZoneOffset zoneOffset = ZoneOffset.ofHours(2);
    OffsetDateTime dateTime = OffsetDateTime.of(2016, 7, 27, 7, 0, 0, 235, zoneOffset);
    OffsetDateTime composition = OffsetDateTime.of(localDate, localTime, zoneOffset);
    OffsetDateTime now = OffsetDateTime.now(); // Offset taken from the default ZoneId
    OffsetDateTime parsed = OffsetDateTime.parse("2016-07-27T07:00:00+02:00");



## Operations on dates and times
    LocalDate tomorrow = LocalDate.now().plusDays(1);
    LocalDateTime anHourFromNow = LocalDateTime.now().plusHours(1);
    Long daysBetween = java.time.temporal.ChronoUnit.DAYS.between(LocalDate.now(), LocalDate.now().plusDays(3)); // 3
    Duration duration = Duration.between(Instant.now(), ZonedDateTime.parse("2016-07-27T07:00:00+01:00[Europe/Stockholm]"))

## Instant
Represents an instant in time. Can be thought of as a wrapper around a Unix timestamp.

    Instant now = Instant.now();
    Instant epoch1 = Instant.ofEpochMilli(0);
    Instant epoch2 = Instant.parse("1970-01-01T00:00:00Z");
    java.time.temporal.ChronoUnit.MICROS.between(epoch1, epoch2); // 0
    

## Usage of various classes of Date Time API
Following example also have explanation required for understanding example within it.

    import java.time.Clock;
    import java.time.Duration;
    import java.time.Instant;
    import java.time.LocalDate;
    import java.time.LocalDateTime;
    import java.time.LocalTime;
    import java.time.ZoneId;
    import java.time.ZonedDateTime;
    import java.util.TimeZone;
    public class SomeMethodsExamples {
    
    /**
     * Has the methods of the class {@link LocalDateTime}
     */
    public static void checkLocalDateTime() {
        LocalDateTime localDateTime = LocalDateTime.now();
        System.out.println("Local Date time using static now() method ::: >>> "
                + localDateTime);
    
        LocalDateTime ldt1 = LocalDateTime.now(ZoneId.of(ZoneId.SHORT_IDS
                .get("AET")));
        System.out
                .println("LOCAL TIME USING now(ZoneId zoneId) method ::: >>>>"
                        + ldt1);
    
        LocalDateTime ldt2 = LocalDateTime.now(Clock.system(ZoneId
                .of(ZoneId.SHORT_IDS.get("PST"))));
        System.out
                .println("Local TIME USING now(Clock.system(ZoneId.of())) ::: >>>> "
                        + ldt2);
    
        System.out
                .println("Following is a static map in ZoneId class which has mapping of short timezone names to their Actual timezone names");
        System.out.println(ZoneId.SHORT_IDS);
    
    }
    
    /**
     * This has the methods of the class {@link LocalDate}
     */
    public static void checkLocalDate() {
        LocalDate localDate = LocalDate.now();
        System.out.println("Gives date without Time using now() method. >> "
                + localDate);
        LocalDate localDate2 = LocalDate.now(ZoneId.of(ZoneId.SHORT_IDS
                .get("ECT")));
        System.out
                .println("now() is overridden to take ZoneID as parametere using this we can get the same date under different timezones. >> "
                        + localDate2);
    }
    
    /**
     * This has the methods of abstract class {@link Clock}. Clock can be used
     * for time which has time with {@link TimeZone}.
     */
    public static void checkClock() {
        Clock clock = Clock.systemUTC();
        // Represents time according to ISO 8601
        System.out.println("Time using Clock class : " + clock.instant());
    }
    
    /**
     * This has the {@link Instant} class methods.
     */
    public static void checkInstant() {
        Instant instant = Instant.now();
    
        System.out.println("Instant using now() method :: " + instant);
    
        Instant ins1 = Instant.now(Clock.systemUTC());
    
        System.out.println("Instants using now(Clock clock) :: " + ins1);
    
    }
    
    /**
     * This class checks the methods of the {@link Duration} class.
     */
    public static void checkDuration() {
        // toString() converts the duration to PTnHnMnS format according to ISO
        // 8601 standard. If a field is zero its ignored.
    
        // P is the duration designator (historically called "period") placed at
        // the start of the duration representation.
        // Y is the year designator that follows the value for the number of
        // years.
        // M is the month designator that follows the value for the number of
        // months.
        // W is the week designator that follows the value for the number of
        // weeks.
        // D is the day designator that follows the value for the number of
        // days.
        // T is the time designator that precedes the time components of the
        // representation.
        // H is the hour designator that follows the value for the number of
        // hours.
        // M is the minute designator that follows the value for the number of
        // minutes.
        // S is the second designator that follows the value for the number of
        // seconds.
    
        System.out.println(Duration.ofDays(2));
    }
    
    /**
     * Shows Local time without date. It doesn't store or represenet a date and
     * time. Instead its a representation of Time like clock on the wall.
     */
    public static void checkLocalTime() {
        LocalTime localTime = LocalTime.now();
        System.out.println("LocalTime :: " + localTime);
    }
    
    /**
     * A date time with Time zone details in ISO-8601 standards.
     */
    public static void checkZonedDateTime() {
        ZonedDateTime zonedDateTime = ZonedDateTime.now(ZoneId
                .of(ZoneId.SHORT_IDS.get("CST")));
        System.out.println(zonedDateTime);
    
    }
    }

## Date Time Formatting
Before Java 8, there was `DateFormat` and `SimpleDateFormat` classes in the package `java.text` and this legacy code will be continued to be used for sometime.     

But, Java 8 offers a modern approach to handling Formatting and Parsing.

In formatting and parsing first you pass a `String` object to `DateTimeFormatter`, and in turn use it for formatting or parsing.

    import java.time.*;
    import java.time.format.*;
    
    class DateTimeFormat
    {
        public static void main(String[] args) {
    
            //Parsing
            String pattern = "d-MM-yyyy HH:mm";
            DateTimeFormatter dtF1 = DateTimeFormatter.ofPattern(pattern);
    
            LocalDateTime ldp1 = LocalDateTime.parse("2014-03-25T01:30"), //Default format
                          ldp2 = LocalDateTime.parse("15-05-2016 13:55",dtF1); //Custom format
    
            System.out.println(ldp1 + "\n" + ldp2); //Will be printed in Default format
    
            //Formatting
            DateTimeFormatter dtF2 = DateTimeFormatter.ofPattern("EEE d, MMMM, yyyy HH:mm");
            
            DateTimeFormatter dtF3 = DateTimeFormatter.ISO_LOCAL_DATE_TIME;
    
            LocalDateTime ldtf1 = LocalDateTime.now();
    
            System.out.println(ldtf1.format(dtF2) +"\n"+ldtf1.format(dtF3));
        }
    }

An important notice, instead of using Custom patterns, it is good practice to use predefined formatters. Your code look more clear and usage of ISO8061 will definitely help you in the long run.

