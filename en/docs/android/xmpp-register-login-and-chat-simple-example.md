---
title: "XMPP register login and chat simple example"
slug: "xmpp-register-login-and-chat-simple-example"
draft: false
images: []
weight: 9910
type: docs
toc: true
---

## XMPP register login and chat basic example
Install openfire or any chat server in your system or on server. For more details [click here.][1]

Create android project and add these libraries in gradle:

    compile 'org.igniterealtime.smack:smack-android:4.2.0'
    compile 'org.igniterealtime.smack:smack-tcp:4.2.0'
    compile 'org.igniterealtime.smack:smack-im:4.2.0'
    compile 'org.igniterealtime.smack:smack-android-extensions:4.2.0'
    
    
Next create one xmpp class from xmpp connection purpose:

    public class XMPP {

    public static final int PORT = 5222;
    private static XMPP instance;
    private XMPPTCPConnection connection;
    private static String TAG = "XMPP-EXAMPLE";
    public static final String ACTION_LOGGED_IN = "liveapp.loggedin";
    private String HOST = "192.168.0.10";

    private XMPPTCPConnectionConfiguration buildConfiguration() throws XmppStringprepException {
        XMPPTCPConnectionConfiguration.Builder builder =
                XMPPTCPConnectionConfiguration.builder();


        builder.setHost(HOST);
        builder.setPort(PORT);
        builder.setCompressionEnabled(false);
        builder.setDebuggerEnabled(true);
        builder.setSecurityMode(ConnectionConfiguration.SecurityMode.disabled);
        builder.setSendPresence(true);

        if (Build.VERSION.SDK_INT >= 14) {
            builder.setKeystoreType("AndroidCAStore");
            // config.setTruststorePassword(null);
            builder.setKeystorePath(null);
        } else {
            builder.setKeystoreType("BKS");
            String str = System.getProperty("javax.net.ssl.trustStore");
            if (str == null) {
                str = System.getProperty("java.home") + File.separator + "etc" + File.separator + "security"
                        + File.separator + "cacerts.bks";
            }
            builder.setKeystorePath(str);
        }
        DomainBareJid serviceName = JidCreate.domainBareFrom(HOST);
        builder.setServiceName(serviceName);


        return builder.build();
    }

    private XMPPTCPConnection getConnection() throws XMPPException, SmackException, IOException, InterruptedException {
        Log.logDebug(TAG, "Getting XMPP Connect");
        if (isConnected()) {
            Log.logDebug(TAG, "Returning already existing connection");
            return this.connection;
        }

        long l = System.currentTimeMillis();
        try {
            if(this.connection != null){
                Log.logDebug(TAG, "Connection found, trying to connect");
                this.connection.connect();
            }else{
                Log.logDebug(TAG, "No Connection found, trying to create a new connection");
                XMPPTCPConnectionConfiguration config = buildConfiguration();
                SmackConfiguration.DEBUG = true;
                this.connection = new XMPPTCPConnection(config);
                this.connection.connect();
            }
        } catch (Exception e) {
            Log.logError(TAG,"some issue with getting connection :" + e.getMessage());
           
        }

        Log.logDebug(TAG, "Connection Properties: " + connection.getHost() + " " + connection.getServiceName());
        Log.logDebug(TAG, "Time taken in first time connect: " + (System.currentTimeMillis() - l));
        return this.connection;
    }

    public static XMPP getInstance() {
        if (instance == null) {
            synchronized (XMPP.class) {
                if (instance == null) {
                    instance = new XMPP();
                }
            }
        }
        return instance;
    }

    public void close() {
        Log.logInfo(TAG, "Inside XMPP close method");
        if (this.connection != null) {
            this.connection.disconnect();
        }
    }

    private XMPPTCPConnection connectAndLogin(Context context) {
        Log.logDebug(TAG, "Inside connect and Login");
        if (!isConnected()) {
            Log.logDebug(TAG, "Connection not connected, trying to login and connect");
            try { 
               // Save username and password then use here
                String username = AppSettings.getUser(context);
                String password = AppSettings.getPassword(context);
                this.connection = getConnection();
                Log.logDebug(TAG, "XMPP username :" + username);
                Log.logDebug(TAG, "XMPP password :" + password);
                this.connection.login(username, password);
                Log.logDebug(TAG, "Connect and Login method, Login successful");
                context.sendBroadcast(new Intent(ACTION_LOGGED_IN));
            } catch (XMPPException localXMPPException) {
                Log.logError(TAG, "Error in Connect and Login Method");
                localXMPPException.printStackTrace();
            } catch (SmackException e) {
                Log.logError(TAG, "Error in Connect and Login Method");
                e.printStackTrace();
            } catch (IOException e) {
                Log.logError(TAG, "Error in Connect and Login Method");
                e.printStackTrace();
            } catch (InterruptedException e) {
                Log.logError(TAG, "Error in Connect and Login Method");
                e.printStackTrace();
            } catch (IllegalArgumentException e) {
                Log.logError(TAG, "Error in Connect and Login Method");
                e.printStackTrace();
            } catch (Exception e) {
                Log.logError(TAG, "Error in Connect and Login Method");
                e.printStackTrace();
            }
        }
        Log.logInfo(TAG, "Inside getConnection - Returning connection");
        return this.connection;
    }

    public boolean isConnected() {
        return (this.connection != null) && (this.connection.isConnected());
    }

    public EntityFullJid getUser() {
        if (isConnected()) {
            return connection.getUser();
        } else {
            return null;
        }
    }

    public void login(String user, String pass, String username)
            throws XMPPException, SmackException, IOException, InterruptedException, PurplKiteXMPPConnectException {
        Log.logInfo(TAG, "inside XMPP getlogin Method");
        long l = System.currentTimeMillis();
        XMPPTCPConnection connect = getConnection();
        if (connect.isAuthenticated()) {
            Log.logInfo(TAG, "User already logged in");
            return;
        }

        Log.logInfo(TAG, "Time taken to connect: " + (System.currentTimeMillis() - l));

        l = System.currentTimeMillis();
        try{
            connect.login(user, pass);
        }catch (Exception e){
            Log.logError(TAG, "Issue in login, check the stacktrace");
            e.printStackTrace();
        }

        Log.logInfo(TAG, "Time taken to login: " + (System.currentTimeMillis() - l));

        Log.logInfo(TAG, "login step passed");

        PingManager pingManager = PingManager.getInstanceFor(connect);
        pingManager.setPingInterval(5000);

    }

    public void register(String user, String pass) throws XMPPException, SmackException.NoResponseException, SmackException.NotConnectedException {
        Log.logInfo(TAG, "inside XMPP register method, " + user + " : " + pass);
        long l = System.currentTimeMillis();
        try {
            AccountManager accountManager = AccountManager.getInstance(getConnection());
            accountManager.sensitiveOperationOverInsecureConnection(true);
            accountManager.createAccount(Localpart.from(user), pass);
        } catch (SmackException e) {
            e.printStackTrace();
        } catch (IOException e) {
            e.printStackTrace();
        } catch (InterruptedException e) {
            e.printStackTrace();
        } catch (PurplKiteXMPPConnectException e) {
            e.printStackTrace();
        }
        Log.logInfo(TAG, "Time taken to register: " + (System.currentTimeMillis() - l));
    }


    public void addStanzaListener(Context context, StanzaListener stanzaListener){
        XMPPTCPConnection connection =  connectAndLogin(context);
        connection.addAsyncStanzaListener(stanzaListener, null);
    }

    public void removeStanzaListener(Context context, StanzaListener stanzaListener){
        XMPPTCPConnection connection =  connectAndLogin(context);
        connection.removeAsyncStanzaListener(stanzaListener);
    }

    public void addChatListener(Context context, ChatManagerListener chatManagerListener){
        ChatManager.getInstanceFor(connectAndLogin(context))
                .addChatListener(chatManagerListener);
    }

    public void removeChatListener(Context context, ChatManagerListener chatManagerListener){
        ChatManager.getInstanceFor(connectAndLogin(context)).removeChatListener(chatManagerListener);
    }

    public void getSrvDeliveryManager(Context context){
        ServiceDiscoveryManager sdm = ServiceDiscoveryManager
                .getInstanceFor(XMPP.getInstance().connectAndLogin(
                        context));
        //sdm.addFeature("http://jabber.org/protocol/disco#info");
        //sdm.addFeature("jabber:iq:privacy");
        sdm.addFeature("jabber.org/protocol/si");
        sdm.addFeature("http://jabber.org/protocol/si");
        sdm.addFeature("http://jabber.org/protocol/disco#info");
        sdm.addFeature("jabber:iq:privacy");

    }

    public String getUserLocalPart(Context context){
       return  connectAndLogin(context).getUser().getLocalpart().toString();
    }

    public EntityFullJid getUser(Context context){
        return  connectAndLogin(context).getUser();
    }

    public Chat getThreadChat(Context context, String party1, String party2){
        Chat chat = ChatManager.getInstanceFor(
                XMPP.getInstance().connectAndLogin(context))
                .getThreadChat(party1 + "-" + party2);
        return chat;
    }

    public Chat createChat(Context context, EntityJid jid, String party1, String party2, ChatMessageListener messageListener){
        Chat chat = ChatManager.getInstanceFor(
                XMPP.getInstance().connectAndLogin(context))
                .createChat(jid, party1 + "-" + party2,
                        messageListener);
        return chat;
    }

    public void sendPacket(Context context, Stanza packet){
        try {
            connectAndLogin(context).sendStanza(packet);
        } catch (SmackException.NotConnectedException e) {
            e.printStackTrace();
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }

    }


Finally, add this activiy:


    private UserLoginTask mAuthTask = null;
    private ChatManagerListener chatListener;
    private Chat chat;
    private Jid opt_jid;
    private ChatMessageListener messageListener;
    private StanzaListener packetListener;
   
    private boolean register(final String paramString1,final String paramString2) {
        try {
            XMPP.getInstance().register(paramString1, paramString2);
            return true;

        } catch (XMPPException localXMPPException) {
            localXMPPException.printStackTrace();
        } catch (SmackException.NoResponseException e) {
            e.printStackTrace();
        } catch (SmackException.NotConnectedException e) {
            e.printStackTrace();
        }
        return false;
    }

    private boolean login(final String user,final String pass,final String username) {

        try {
           
            XMPP.getInstance().login(user, pass, username);
            sendBroadcast(new Intent("liveapp.loggedin"));

            return true;
        } catch (Exception e) {
            e.printStackTrace();
            try {
          
                XMPP.getInstance()
                        .login(user, pass, username);
                sendBroadcast(new Intent("liveapp.loggedin"));

                return true;
            } catch (XMPPException e1) {
                e1.printStackTrace();
            } catch (SmackException e1) {
                e1.printStackTrace();
            } catch (InterruptedException e1) {
                e1.printStackTrace();
            } catch (IOException e1) {
                e1.printStackTrace();
            }catch (Exception e1){
                e1.printStackTrace();
            }
        }
        return false;
    }
   
    public class UserLoginTask extends AsyncTask<Void, Void, Boolean> {

        public UserLoginTask() {
        }

        protected Boolean doInBackground(Void... paramVarArgs) {
            String mEmail = "abc";
            String mUsername = "abc";
            String mPassword = "welcome";
           
            if (register(mEmail, mPassword)) {
                try {
                    XMPP.getInstance().close();
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
            return login(mEmail, mPassword, mUsername);

        }

        protected void onCancelled() {
            mAuthTask = null;

        }

        @Override
        protected void onPreExecute() {
            super.onPreExecute();

        }

        protected void onPostExecute(Boolean success) {
            mAuthTask = null;
            try {
                if (success) {

                  messageListener = new ChatMessageListener() {
                    @Override
                    public void processMessage(Chat chat, Message message) {

                    // here you will get only connected user by you

                    }
            };


            packetListener = new StanzaListener() {
                    @Override
                    public void processPacket(Stanza packet) throws SmackException.NotConnectedException, InterruptedException {

                        if (packet instanceof Message) {
                            final Message message = (Message) packet;
                          
                     // here you will get all messages send by anybody
                        }
                    }
            };

            chatListener = new ChatManagerListener() {

                    @Override
                    public void chatCreated(Chat chatCreated, boolean local) {
                        onChatCreated(chatCreated);
                    }
            };
            
            
            try {
            String opt_jidStr = "abc";

            try {
                opt_jid = JidCreate.bareFrom(Localpart.from(opt_jidStr), Domainpart.from(HOST));
            } catch (XmppStringprepException e) {
                e.printStackTrace();
            }
            String addr1 = XMPP.getInstance().getUserLocalPart(getActivity());
            String addr2 = opt_jid.toString();
            if (addr1.compareTo(addr2) > 0) {
                String addr3 = addr2;
                addr2 = addr1;
                addr1 = addr3;
            }
            chat = XMPP.getInstance().getThreadChat(getActivity(), addr1, addr2);
            if (chat == null) {
                chat = XMPP.getInstance().createChat(getActivity(), (EntityJid) opt_jid, addr1, addr2, messageListener);
                PurplkiteLogs.logInfo(TAG, "chat value single chat 1 :" + chat);
            } else {
                chat.addMessageListener(messageListener);
                PurplkiteLogs.logInfo(TAG, "chat value single chat  2:" + chat);
            }

            } catch (Exception e) {
            e.printStackTrace();
            }

            
            XMPP.getInstance().addStanzaListener(getActivity(), packetListener);
            XMPP.getInstance().addChatListener(getActivity(), chatListener);
            XMPP.getInstance().getSrvDeliveryManager(getActivity());
                
                } else {

                }
            } catch (Exception e) {
                e.printStackTrace();
            }

        }
    }

    /**
     * user attemptLogin for xmpp
     *
     */

    private void attemptLogin() {
        if (mAuthTask != null) {
            return;
        }

        boolean cancel = false;
        View focusView = null;

        if (cancel) {
            focusView.requestFocus();
        } else {
            try {
                mAuthTask = new UserLoginTask();
                mAuthTask.execute((Void) null);
            } catch (Exception e) {

            }

        }
    }
    
    void onChatCreated(Chat chatCreated) {
        if (chat != null) {
            if (chat.getParticipant().getLocalpart().toString().equals(
                    chatCreated.getParticipant().getLocalpart().toString())) {
                chat.removeMessageListener(messageListener);
                chat = chatCreated;
                chat.addMessageListener(messageListener);
            }
        } else {
            chat = chatCreated;
            chat.addMessageListener(messageListener);
        }
    }    
 
    private void sendMessage(String message) {
        if (chat != null) {
            try {
                chat.sendMessage(message);
            } catch (SmackException.NotConnectedException e) {
                e.printStackTrace();
            } catch (Exception e) {
                e.printStackTrace();
            }
        }
    }    
    
     @Override
    public void onDestroy() {
        // TODO Auto-generated method stub
        super.onDestroy();
        try {
            XMPP.getInstance().removeChatListener(getActivity(), chatListener);
            if (chat != null && messageListener != null) {
                XMPP.getInstance().removeStanzaListener(getActivity(), packetListener);
                chat.removeMessageListener(messageListener);
            }
        } catch (Exception e) {
            e.printStackTrace();
        }

    }

Make sure the internet permission is added in your manifest file.


  [1]: https://xmpp.org/software/servers.html

