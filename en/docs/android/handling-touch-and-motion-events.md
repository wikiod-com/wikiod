---
title: "Handling touch and motion events"
slug: "handling-touch-and-motion-events"
draft: false
images: []
weight: 9989
type: docs
toc: true
---

A summary of some of the basic touch/motion-handling systems in the Android API.

## Parameters
| Listener | Details | 
| --- | --- |
| onTouchListener | Handles single touches for buttons, surfaces and more
| onTouchEvent | A listener that can be found in surfaces(e.g. SurfaceView). Does not need to be set like other listeners(e,g. onTouchListener) |
| onLongTouch | Similar to onTouch, but listens for long presses in buttons, surfaces and more.|


## Buttons
Touch events related to a `Button` can be checked as follows:

    public class ExampleClass extends Activity implements View.OnClickListener, View.OnLongClickListener{
        public Button onLong, onClick;

        @Override
        public void onCreate(Bundle sis){
            super.onCreate(sis);
            setContentView(R.layout.layout);
            onLong = (Button) findViewById(R.id.onLong);
            onClick = (Button) findViewById(R.id.onClick);
            // The buttons are created. Now we need to tell the system that
            // these buttons have a listener to check for touch events.
            // "this" refers to this class, as it contains the appropriate event listeners.
            onLong.setOnLongClickListener(this);
            onClick.setOnClickListener(this);
    
            [OR]
    
            onClick.setOnClickListener(new View.OnClickListener(){
                @Override
                public void onClick(View v){
                    // Take action. This listener is only designed for one button.
                    // This means, no other input will come here.
                    // This makes a switch statement unnecessary here.
                }
            });
    
            onLong.setOnLongClickListener(new View.OnLongClickListener(){
                @Override
                public boolean onLongClick(View v){
                    // See comment in onClick.setOnClickListener().
                }
            });
        }
    
        @Override
        public void onClick(View v) {
            // If you have several buttons to handle, use a switch to handle them.
            switch(v.getId()){
                case R.id.onClick:
                    // Take action.
                    break;
            }
        }
    
        @Override
        public boolean onLongClick(View v) {
            // If you have several buttons to handle, use a switch to handle them.
            switch(v.getId()){
                case R.id.onLong:
                    // Take action.
                    break;
            }
            return false;
        }
    }



## Surface
Touch event handler for surfaces (e.g. SurfaceView, GLSurfaceView, and others):

    import android.app.Activity;
    import android.os.Bundle;
    import android.view.MotionEvent;
    import android.view.SurfaceView;
    import android.view.View;
    
    public class ExampleClass extends Activity implements View.OnTouchListener{
        @Override
        public void onCreate(Bundle sis){
            super.onCreate(sis);
            CustomSurfaceView csv = new CustomSurfaceView(this);
            csv.setOnTouchListener(this);
            setContentView(csv);
        }
    
        @Override
        public boolean onTouch(View v, MotionEvent event) {
            // Add a switch (see buttons example) if you handle multiple views
            // here you can see (using MotionEvent event) to see what touch event
            // is being taken. Is the pointer touching or lifted? Is it moving?
            return false;
        }
    }

Or alternatively (in the surface):

    public class CustomSurfaceView extends SurfaceView {
        @Override
        public boolean onTouchEvent(MotionEvent ev) {
            super.onTouchEvent(ev);
            // Handle touch events here. When doing this, you do not need to call a listener.
            // Please note that this listener only applies to the surface it is placed in 
            // (in this case, CustomSurfaceView), which means that anything else which is 
            // pressed outside the SurfaceView is handled by the parts of your app that
            // have a listener in that area.
            return true;
        }
    }

    



## Handling multitouch in a surface
    public class CustomSurfaceView extends SurfaceView {
        @Override
        public boolean onTouchEvent(MotionEvent e) {
            super.onTouchEvent(e);
            if(e.getPointerCount() > 2){
                return false; // If we want to limit the amount of pointers, we return false
                    // which disallows the pointer. It will not be reacted on either, for
                    // any future touch events until it has been lifted and repressed.
            }
    
            // What can you do here? Check if the amount of pointers are [x] and take action,
            // if a pointer leaves, a new enters, or the [x] pointers are moved.
            // Some examples as to handling etc. touch/motion events.

            switch (MotionEventCompat.getActionMasked(e)) {
                case MotionEvent.ACTION_DOWN:
                case MotionEvent.ACTION_POINTER_DOWN:
                    // One or more pointers touch the screen.
                    break;
                case MotionEvent.ACTION_UP:
                case MotionEvent.ACTION_POINTER_UP:
                    // One or more pointers stop touching the screen.
                    break;
                case MotionEvent.ACTION_MOVE:
                    // One or more pointers move.
                    if(e.getPointerCount() == 2){
                        move();
                    }else if(e.getPointerCount() == 1){
                        paint();
                    }else{
                        zoom();
                    }
                    break;
            }
            return true; // Allow repeated action.    
        }
    }

