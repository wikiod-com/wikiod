---
title: "Move Semantics"
slug: "move-semantics"
draft: false
images: []
weight: 9895
type: docs
toc: true
---

## Using std::move to reduce complexity from O(n²) to O(n)
C++11 introduced core language and standard library support for **moving** an object. The idea is that when an object *o* is a temporary and one wants a logical copy, then its safe to just pilfer *o*'s resources, such as a dynamically allocated buffer, leaving *o* logically empty but still destructible and copyable.

The core language support is mainly

* the **rvalue reference** type builder `&&`, e.g., `std::string&&` is an rvalue reference to a `std::string`, indicating that that referred to object is a temporary whose resources can just be pilfered (i.e. moved)

* special support for a **move constructor** `T( T&& )`, which is supposed to efficiently move resources from the specified other object, instead of actually copying those resources, and

* special support for a **move assignment operator** `auto operator=(T&&) -> T&`, which also is supposed to move from the source.

The standard library support is mainly the `std::move` function template from the `<utility>` header. This function produces an rvalue reference to the specified object, indicating that it can be moved from, just as if it were a temporary.

---

For a container actual copying is typically of O(*n*) complexity, where *n* is the number of items in the container, while moving is O(1), constant time. And for an algorithm that logically copies that container *n* times, this can reduce the complexity from the usually impractical O(*n*²) to just linear O(*n*).


In his article [“Containers That Never Change” in Dr. Dobbs Journal in September 19 2013][1], Andrew Koenig presented an interesting example of algorithmic inefficiency when using a style of programming where variables are immutable after initialization. With this style loops are generally expressed using recursion. And for some algorithms such as generating a Collatz sequence, the recursion requires logically copying a container:

    // Based on an example by Andrew Koenig in his Dr. Dobbs Journal article
    // “Containers That Never Change” September 19, 2013, available at
    // <url: http://www.drdobbs.com/cpp/containters-that-never-change/240161543>

    // Includes here, e.g. <vector>

    namespace my {
        template< class Item >
        using Vector_ = /* E.g. std::vector<Item> */;

        auto concat( Vector_<int> const& v, int const x )
            -> Vector_<int>
        {
            auto result{ v };
            result.push_back( x );
            return result;
        }

        auto collatz_aux( int const n, Vector_<int> const& result )
            -> Vector_<int>
        {
            if( n == 1 )
            {
                return result;
            }
            auto const new_result = concat( result, n );
            if( n % 2 == 0 )
            {
                return collatz_aux( n/2, new_result );
            }
            else
            {
                return collatz_aux( 3*n + 1, new_result );
            }
        }

        auto collatz( int const n )
            -> Vector_<int>
        {
            assert( n != 0 );
            return collatz_aux( n, Vector_<int>() );
        }
    }  // namespace my

    #include <iostream>
    using namespace std;
    auto main() -> int
    {
        for( int const x : my::collatz( 42 ) )
        {
            cout << x << ' ';
        }
        cout << '\n';
    }

Output:

<pre>
42 21 64 32 16 8 4 2
</pre>

The number of item copy operations due to copying of the vectors is here roughly O(*n²*), since it's the sum 1 + 2 + 3 + ... *n*. 

In concrete numbers, with g++ and Visual C++ compilers the above invocation of `collatz(42)` resulted in a Collatz sequence of 8 items and 36 item copy operations (8*7/2 = 28, plus some) in vector copy constructor calls.

*All* of these item copy operations can be removed by simply moving vectors whose values are not needed anymore. To do this it's necessary to remove `const` and reference for the vector type arguments, passing the vectors *by value*. The function returns are already automatically optimized. For the calls where vectors are passed, and not used again further on in the function, just apply `std::move` to *move* those buffers rather than actually copying them:

    using std::move;

    auto concat( Vector_<int> v, int const x )
        -> Vector_<int>
    {
        v.push_back( x );
        // warning: moving a local object in a return statement prevents copy elision [-Wpessimizing-move]
        // See https://www.wikiod.com/docs/c%2b%2b/2489/copy-elision
        // return move( v );
        return v;
    }

    auto collatz_aux( int const n, Vector_<int> result )
        -> Vector_<int>
    {
        if( n == 1 )
        {
            return result;
        }
        auto new_result = concat( move( result ), n );
        struct result;      // Make absolutely sure no use of `result` after this.
        if( n % 2 == 0 )
        {
            return collatz_aux( n/2, move( new_result ) );
        }
        else
        {
            return collatz_aux( 3*n + 1, move( new_result ) );
        }
    }

    auto collatz( int const n )
        -> Vector_<int>
    {
        assert( n != 0 );
        return collatz_aux( n, Vector_<int>() );
    }

Here, with g++ and Visual C++ compilers, the number of item copy operations due to vector copy constructor invocations, was exactly 0.

The algorithm is necessarily still O(*n*) in the length of the Collatz sequence produced, but this is a quite dramatic improvement: O(*n*²) &rarr; O(*n*).

---

With some language support one could perhaps use moving and still express and enforce the immutability of a variable *between its initialization and final move*, after which any use of that variable should be an error. Alas, as of C++14 C++ does not support that. For loop-free code the no use after move can be enforced via a re-declaration of the relevant name as an incomplete `struct`, as with `struct result;` above, but this is ugly and not likely to be understood by other programmers; also the diagnostics can be quite misleading.

Summing up, the C++ language and library support for moving allows drastic improvements in algorithm complexity, but due the support's incompleteness, at the cost of forsaking the code correctness guarantees and code clarity that `const` can provide.

---

<sup>
<i>For completeness, the instrumented vector class used to measure the number of item copy operations due to copy constructor invocations:</i>
</sup>

    template< class Item >
    class Copy_tracking_vector
    {
    private:
        static auto n_copy_ops()
            -> int&
        {
            static int value;
            return value;
        }
        
        vector<Item>    items_;
        
    public:
        static auto n() -> int { return n_copy_ops(); }

        void push_back( Item const& o ) { items_.push_back( o ); }
        auto begin() const { return items_.begin(); }
        auto end() const { return items_.end(); }

        Copy_tracking_vector(){}
        
        Copy_tracking_vector( Copy_tracking_vector const& other )
            : items_( other.items_ )
        { n_copy_ops() += items_.size(); }

        Copy_tracking_vector( Copy_tracking_vector&& other )
            : items_( move( other.items_ ) )
        {}
    };

  [1]: http://www.drdobbs.com/cpp/containters-that-never-change/240161543
  

## Move semantics
Move semantics are a way of moving one object to another in C++. For this, we empty the old object and place everything it had in the new object. 

For this, we must understand what an rvalue reference is. An rvalue reference (`T&&` where T is the object type) is not much different than a normal reference (`T&`, now called lvalue references). But they act as 2 different types, and so, we can make constructors or functions that take one type or the other, which will be necessary when dealing with move semantics.

The reason why we need two different types is to specify two different behaviors. Lvalue reference constructors are related to copying, while rvalue reference constructors are related to moving.

To move an object, we will use `std::move(obj)`. This function returns an rvalue reference to the object, so that we can steal the data from that object into a new one. There are several ways of doing this which are discussed below.

Important to note is that the use of `std::move` creates just an rvalue reference.
In other words the statement `std::move(obj)` does not change the content of obj, while `auto obj2 = std::move(obj)` (possibly) does.

## Move constructor
Say we have this code snippet.

    class A {
    public:
        int a;
        int b;
           
        A(const A &other) {
            this->a = other.a;
            this->b = other.b;
        }
    };

To create a copy constructor, that is, to make a function that copies an object and creates a new one, we normally would choose the syntax shown above, we would have a constructor for A that takes an reference to another object of type A, and we would copy the object manually inside the method.

Alternatively, we could have written `A(const A &) = default;` which automatically copies over all members, making use of its copy constructor.


To create a move constructor, however, we will be taking an rvalue reference instead of an lvalue reference, like here.

    class Wallet {
    public:
        int nrOfDollars;
        
        Wallet() = default; //default ctor

        Wallet(Wallet &&other) {
            this->nrOfDollars = other.nrOfDollars;
            other.nrOfDollars = 0;
        }
    };

Please notice that we set the old values to `zero`. The default move constructor (`Wallet(Wallet&&) = default;`) copies the value of `nrOfDollars`, as it is a POD.

As move semantics are designed to allow 'stealing' state from the original instance, it is important to consider how the original instance should look like after this stealing. In this case, if we would not change the value to zero we would have doubled the amount of dollars into play.

    Wallet a;
    a.nrOfDollars = 1;
    Wallet b (std::move(a)); //calling B(B&& other);
    std::cout << a.nrOfDollars << std::endl; //0
    std::cout << b.nrOfDollars << std::endl; //1

Thus we have move constructed an object from an old one.

----

While the above is a simple example, it shows what the move constructor is intended to do.  It becomes more useful in more complex cases, such as when resource management is involved.

        // Manages operations involving a specified type.
        // Owns a helper on the heap, and one in its memory (presumably on the stack).
        // Both helpers are DefaultConstructible, CopyConstructible, and MoveConstructible.
        template<typename T,
                 template<typename> typename HeapHelper,
                 template<typename> typename StackHelper>
        class OperationsManager {
            using MyType = OperationsManager<T, HeapHelper, StackHelper>;
    
            HeapHelper<T>* h_helper;
            StackHelper<T> s_helper;
            // ...
    
          public:
            // Default constructor & Rule of Five.
            OperationsManager() : h_helper(new HeapHelper<T>) {}
            OperationsManager(const MyType& other)
              : h_helper(new HeapHelper<T>(*other.h_helper)), s_helper(other.s_helper) {}
            MyType& operator=(MyType copy) {
                swap(*this, copy);
                return *this;
            }
            ~OperationsManager() {
                if (h_helper) { delete h_helper; }
            }
    
            // Move constructor (without swap()).
            // Takes other's HeapHelper<T>*.
            // Takes other's StackHelper<T>, by forcing the use of StackHelper<T>'s move constructor.
            // Replaces other's HeapHelper<T>* with nullptr, to keep other from deleting our shiny
            //  new helper when it's destroyed.
            OperationsManager(MyType&& other) noexcept
              : h_helper(other.h_helper),
                s_helper(std::move(other.s_helper)) {
                other.h_helper = nullptr;
            }
    
            // Move constructor (with swap()).
            // Places our members in the condition we want other's to be in, then switches members
            //  with other.
            // OperationsManager(MyType&& other) noexcept : h_helper(nullptr) {
            //     swap(*this, other);
            // }

            // Copy/move helper.
            friend void swap(MyType& left, MyType& right) noexcept {
                std::swap(left.h_helper, right.h_helper);
                std::swap(left.s_helper, right.s_helper);
            }
        };

## Move assignment
Similarly to how we can assign a value to an object with an lvalue reference, copying it, we can also move the values from an object to another without constructing a new one. We call this move assignment. We move the values from one object to another existing object.

For this, we will have to overload `operator =`, not so that it takes an lvalue reference, like in copy assignment, but so that it takes an rvalue reference.

    class A {
        int a;
        A& operator= (A&& other) {
            this->a = other.a;
            other.a = 0;
            return *this;
        }
    };

This is the typical syntax to define move assignment. We overload `operator =` so that we can feed it an rvalue reference and it can assign it to another object.

    A a;
    a.a = 1;
    A b;
    b = std::move(a); //calling A& operator= (A&& other)
    std::cout << a.a << std::endl; //0
    std::cout << b.a << std::endl; //1

Thus, we can move assign an object to another one.

## Re-use a moved object


## Using move semantics on containers


