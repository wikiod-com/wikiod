---
title: "anahtar kelimeler"
slug: "anahtar-kelimeler"
draft: false
images: []
weight: 8286
type: docs
toc: true
---

[Anahtar kelimeler](https://msdn.microsoft.com/en-us/library/x53a06bb(v=vs.71).aspx) derleyici için özel anlamı olan önceden tanımlanmış, ayrılmış tanımlayıcılardır. Bunlar, `@` ön eki olmadan programınızda tanımlayıcı olarak kullanılamazlar. Örneğin, "@if" yasal bir tanımlayıcıdır, ancak "if" anahtar kelimesi değildir.

C#, her biri özel bir işleve sahip olan önceden tanımlanmış bir "anahtar sözcük" (veya ayrılmış sözcükler) koleksiyonuna sahiptir. Bu kelimeler, `@` ile ön eki eklenmedikçe tanımlayıcı olarak kullanılamaz (değişkenler, yöntemler, sınıflar vb. adları).

* [`abstract`](https://www.wikiod.com/tr/docs/c%23/26/keywords/2872/abstract)
* [`as`](https://www.wikiod.com/tr/docs/c%23/26/keywords/138/as)
* [`base`](https://www.wikiod.com/tr/docs/c%23/26/keywords/1840/base)
* [`bool`](https://www.wikiod.com/tr/docs/c%23/26/keywords/8712/bool)
* [`break`](https://www.wikiod.com/tr/docs/c%23/26/keywords/2858/break)
* "bayt"
* "vaka"
* [`catch`](https://www.wikiod.com/tr/docs/c%23/26/keywords/148/try-catch-finally-throw)
* [`char`](https://www.wikiod.com/tr/docs/c%23/26/keywords/6009/char)
* [`checked`](https://www.wikiod.com/tr/docs/c%23/26/keywords/192/checked-unchecked)
* 'sınıf'
* [`const`](https://www.wikiod.com/tr/docs/c%23/26/keywords/141/const)
* [`devam`](https://www.wikiod.com/tr/docs/c%23/26/keywords/154/continue)
* [`decimal`](https://www.wikiod.com/tr/docs/c%23/26/keywords/2873/float-double-decimal)
* [`varsayılan`](https://www.wikiod.com/tr/docs/c%23/26/keywords/109/default)
* [`temsilci`](https://www.wikiod.com/tr/docs/c%23/26/keywords/18720/delegate)
* [`do`](https://www.wikiod.com/tr/docs/c%23/26/keywords/12229/do)
* [`double`](https://www.wikiod.com/tr/docs/c%23/26/keywords/2873/float-double-decimal)
* [`else`](https://www.wikiod.com/tr/docs/c%23/26/keywords/11359/if-if-else-if-else-if)
* [`enum`](https://www.wikiod.com/tr/docs/c%23/26/keywords/245/enum)
* [`event`](https://www.wikiod.com/tr/docs/c%23/26/keywords/18722/event)
* "açık"
* [`extern`](https://www.wikiod.com/tr/docs/c%23/26/keywords/8191/extern)
* [`false`](https://www.wikiod.com/tr/docs/c%23/26/keywords/17113/true-false)
* [`son olarak`](https://www.wikiod.com/tr/docs/c%23/26/keywords/148/try-catch-finally-throw)
* [`sabit`](https://www.wikiod.com/tr/docs/c%23/26/keywords/59/fixed)
* [`float`](https://www.wikiod.com/tr/docs/c%23/26/keywords/2873/float-double-decimal)
* [`for`](https://www.wikiod.com/tr/docs/c%23/26/keywords/3722/for)
* [`foreach`](https://www.wikiod.com/tr/docs/c%23/26/keywords/1928/foreach)
* [`goto`](https://www.wikiod.com/tr/docs/c%23/26/keywords/193/goto)
* [`if`](https://www.wikiod.com/tr/docs/c%23/26/keywords/11359/if-if-else-if-else-if)
* [`implicit`](https://www.wikiod.com/tr/docs/c%23/26/keywords/16557/implicit)
* [`in`](https://www.wikiod.com/tr/docs/c%23/26/keywords/4992/in)
* [`int`](https://www.wikiod.com/tr/docs/c%23/26/keywords/5328/int)
* [`arayüz`](https://www.wikiod.com/tr/docs/c%23/26/keywords/14354/interface)
* [`dahili`][1]
* [`is`](https://www.wikiod.com/tr/docs/c%23/26/keywords/139/is)
* [`lock`](https://www.wikiod.com/tr/docs/c%23/26/keywords/6452/lock#t=201607261640175640513)
* [`long`](https://www.wikiod.com/tr/docs/c%23/26/keywords/5329/long)
* [`ad alanı`](https://www.wikiod.com/tr/docs/c%23/26/keywords/142/namespace)
* [`yeni`](https://www.wikiod.com/tr/docs/c%23/26/keywords/5805/virtual-override-new)
* [`null`](https://www.wikiod.com/tr/docs/c%23/26/keywords/6750/null)
* "nesne"
* [`operatör`](https://www.wikiod.com/tr/docs/c%23/26/keywords/12604/operator)
* [`out`](https://www.wikiod.com/tr/docs/c%23/26/keywords/184/ref-out)
* [`override`](https://www.wikiod.com/tr/docs/c%23/26/keywords/5805/virtual-override-new)
* [`params`](https://www.wikiod.com/tr/docs/c%23/26/keywords/2513/params)
* 'özel'
* 'korumalı'
* 'kamu'
* [`salt okunur`](https://www.wikiod.com/tr/docs/c%23/26/keywords/110/readonly)
* [`ref`](https://www.wikiod.com/tr/docs/c%23/26/keywords/184/ref-out)
* [`return`](https://www.wikiod.com/tr/docs/c%23/26/keywords/4600/return)
* [`sbyte`](https://www.wikiod.com/tr/docs/c%23/26/keywords/18290/sbyte)
* [`mühürlü`](https://www.wikiod.com/tr/docs/c%23/26/keywords/5245/sealed)
* "kısa"
* [`sizeof`](https://www.wikiod.com/tr/docs/c%23/26/keywords/5246/sizeof)
* [`stackalloc`](https://www.wikiod.com/tr/docs/c%23/26/keywords/57/stackalloc)
* [`static`](https://www.wikiod.com/tr/docs/c%23/26/keywords/5248/static)
* [`string`](https://www.wikiod.com/tr/docs/c%23/26/keywords/17143/string)
* [`yapı`][2]
* [`switch`](https://www.wikiod.com/tr/docs/c%23/26/keywords/14353/switch)
* [`bu`](https://www.wikiod.com/tr/docs/c%23/26/keywords/2914/this)
* [`throw`](https://www.wikiod.com/tr/docs/c%23/26/keywords/148/try-catch-finally-throw)
* [`true`](https://www.wikiod.com/tr/docs/c%23/26/keywords/17113/true-false)
* [`try`](https://www.wikiod.com/tr/docs/c%23/26/keywords/148/try-catch-finally-throw)
* [`typeof`](https://www.wikiod.com/tr/docs/c%23/26/keywords/140/typeof)
* [`uint`](https://www.wikiod.com/tr/docs/c%23/26/keywords/2874/uint)
* [`ulong`](https://www.wikiod.com/tr/docs/c%23/26/keywords/5330/ulong)
* [`işaretlenmemiş`](https://www.wikiod.com/tr/docs/c%23/26/keywords/192/checked-unchecked)
* [`güvensiz`](https://www.wikiod.com/tr/docs/c%23/26/keywords/15630/unsafe)
* [`ushort`](https://www.wikiod.com/tr/docs/c%23/26/keywords/18289/ushort)
* [`kullanarak` (direktif)](https://www.wikiod.com/tr/docs/c%23/52/using-directive#t=201605012059492751326)
* [`kullanarak` (ifade)](https://www.wikiod.com/tr/docs/c%23/38/using-statement#t=20160501205709291959)
* [`sanal`](https://www.wikiod.com/tr/docs/c%23/26/keywords/5805/virtual-override-new)
* [`void`](https://www.wikiod.com/tr/docs/c%23/26/keywords/2980/void)
* [`volatile`](https://www.wikiod.com/tr/docs/c%23/26/keywords/58/volatile)
* [`ne zaman`](https://www.wikiod.com/tr/docs/c%23/26/keywords/9258/while)
* [`while`](https://www.wikiod.com/tr/docs/c%23/26/keywords/4396/while)

Bunların dışında C#, kodda belirli bir anlam sağlamak için bazı anahtar kelimeler de kullanır. Bunlar bağlamsal anahtar kelimeler olarak adlandırılır. Bağlamsal anahtar kelimeler tanımlayıcı olarak kullanılabilir ve tanımlayıcı olarak kullanıldığında "@" ile ön ek alınmasına gerek yoktur.

* 'ekle'
* "takma ad"
* 'artan'
* [`async`](https://www.wikiod.com/tr/docs/c%23/26/keywords/5993/async-await)
* [`bekliyor`](https://www.wikiod.com/tr/docs/c%23/26/keywords/5993/async-await)
* 'azalan'
* "dinamik"
* 'dan'
* "al"
* "küresel"
* 'grup'
* 'içine'
* 'katıl'
* 'bırak'
* [`nameof`](https://www.wikiod.com/tr/docs/c%23/24/c-sharp-6-0-features/43/operator-nameof)
* 'sipariş'
* [`kısmi`](https://www.wikiod.com/tr/docs/c%23/26/keywords/19199/partial#t=201608110434471554387)
* "kaldır"
* `seç`
* "ayarla"
* "değer"
* [`var`](https://www.wikiod.com/tr/docs/c%23/26/keywords/4503/var)
* [`where`](https://www.wikiod.com/tr/docs/c%23/26/keywords/8137/where-type-constraints)
* [`yield`](https://www.wikiod.com/tr/docs/c%23/61/yield-keyword-in-c#t=201605012045372009603)


[1]: https://www.wikiod.com/tr/docs/c%23/26/keywords/8102/internal#t=201607221603473329189
[2]: https://www.wikiod.com/tr/docs/c%23/26/keywords/13023/struct#t=201607251950535084892

## olarak
"as" anahtar sözcüğü, *cast* benzeri bir işleçtir. Bir atama mümkün değilse, "as" kullanmak, "InvalidCastException" ile sonuçlanmak yerine "null" üretir.

'tür olarak ifade', 'ifade türdür? (type)expression : (type)null', "as"ın yalnızca referans dönüşümlerinde, null yapılabilir dönüşümlerde ve kutulama dönüşümlerinde geçerli olduğu uyarısıyla birlikte. Kullanıcı tanımlı dönüşümler *desteklenmez*; bunun yerine normal bir döküm kullanılmalıdır.

Yukarıdaki genişletme için, derleyici, "ifade" yalnızca bir kez değerlendirilecek ve tek dinamik tür denetimi kullanacak şekilde kod oluşturur (yukarıdaki örnekteki ikisinden farklı olarak).

"as", birkaç türü kolaylaştırmak için bir argüman beklerken faydalı olabilir. Spesifik olarak, kullanıcıya birden fazla seçenek sunar - yayınlamadan önce her olasılığı 'is' ile kontrol etmek veya sadece istisnaları yayınlamak ve yakalamak yerine. Yalnızca bir kutudan çıkarma cezasına neden olacak bir nesneyi yayınlarken/kontrol ederken 'as' kullanmak en iyi uygulamadır. Kontrol etmek için 'is'i kullanmak, daha sonra yayınlamak iki kutudan çıkarma cezasına neden olur.

Bir argümanın belirli bir türün örneği olması bekleniyorsa, amacı okuyucu için daha açık olduğu için düzenli bir döküm tercih edilir.

'as' çağrısı 'null' üretebileceğinden, bir 'NullReferenceException'dan kaçınmak için her zaman sonucu kontrol edin.

**Örnek kullanım**

    object something = "Hello";
    Console.WriteLine(something as string);        //Hello
    Console.Writeline(something as Nullable<int>); //null
    Console.WriteLine(something as int?);          //null
    
    //This does NOT compile:
    //destination type must be a reference type (or a nullable value type)
    Console.WriteLine(something as int);

[.NET Fiddle'da Canlı Demo](https://dotnetfiddle.net/b26q6N)

"as" kullanmadan eşdeğer örnek:

    Console.WriteLine(something is string ? (string)something : (string)null);

Bu, özel sınıflarda "Eşittir" işlevini geçersiz kılarken kullanışlıdır.

    class MyCustomClass
    {

        public override bool Equals(object obj)
        {
            MyCustomClass customObject = obj as MyCustomClass;

            // if it is null it may be really null
            // or it may be of a different type
            if (Object.ReferenceEquals(null, customObject))
            {
                // If it is null then it is not equal to this instance.
                return false;
            }

            // Other equality controls specific to class
        }

    }

## git
"goto", bir etiketle belirtilen kodun içindeki belirli bir satıra atlamak için kullanılabilir.

# "goto" olarak:

## Etiket:

    void InfiniteHello()
    {
        sayHello:
        Console.WriteLine("Hello!");
        goto sayHello;
    }

[.NET Fiddle'da Canlı Demo](https://dotnetfiddle.net/Tpm3LV)

## Vaka ifadesi:

    enum Permissions { Read, Write };

    switch (GetRequestedPermission())
    {
        case Permissions.Read:
            GrantReadAccess();
            break;

        case Permissions.Write:
            GrantWriteAccess();
            goto case Permissions.Read; //People with write access also get read
    }

[.NET Fiddle'da Canlı Demo](https://dotnetfiddle.net/2IV2wC)

Bu, özellikle bir switch deyiminde birden çok davranışın yürütülmesinde kullanışlıdır, çünkü C# [sonsuz vaka bloklarını](http://stackoverflow.com/a/174223/365102) desteklemez.

## İstisna Yeniden Deneme

    var exCount = 0;
    retry:
    try
    {
        //Do work
    }
    catch (IOException)
    {
        exCount++;
        if (exCount < 3)
        {
            Thread.Sleep(100);
            goto retry;
        }
        throw;
    }

[.NET Fiddle'da Canlı Demo](https://dotnetfiddle.net/kc6oiT)

Birçok dilde olduğu gibi, aşağıdaki durumlar dışında goto anahtar sözcüğünün kullanılması önerilmez.

['goto'][wiki]'nin C# için geçerli olan kullanımları:

* Switch deyiminde düşme durumu.
* Çok seviyeli mola. Bunun yerine genellikle LINQ kullanılabilir, ancak genellikle daha kötü performansa sahiptir.
* Sarılmamış düşük seviyeli nesnelerle çalışırken kaynak ayırma. C#'ta düşük seviyeli nesneler genellikle ayrı sınıflara sarılmalıdır.
* Sonlu durum makineleri, örneğin ayrıştırıcılar; derleyici tarafından oluşturulan zaman uyumsuz/bekleme durumu makineleri tarafından dahili olarak kullanılır.

[so]: http://stackoverflow.com/questions/tagged/goto+c%23
[wiki]: https://en.wikipedia.org/wiki/Goto#Common_usage_patterns_of_Goto

## uçucu
Bir alana 'volatile' anahtar sözcüğünü eklemek, derleyiciye alanın değerinin birden çok ayrı iş parçacığı tarafından değiştirilebileceğini belirtir. 'volatile' anahtar sözcüğünün birincil amacı, yalnızca tek iş parçacıklı erişimi varsayan derleyici optimizasyonlarını önlemektir. "Uçucu"nun kullanılması, alan değerinin mevcut olan en son değer olmasını ve değerin geçici olmayan değerlerin önbelleğe alınmasına tabi olmamasını sağlar.

Sahne arkası optimizasyonlarından kaynaklanan beklenmeyen davranışları önlemek için birden çok iş parçacığı tarafından kullanılabilen _her değişkeni_ "geçici" olarak işaretlemek iyi bir uygulamadır. Aşağıdaki kod bloğunu göz önünde bulundurun:

    public class Example
    {
        public int x;

        public void DoStuff()
        {
            x = 5;

            // the compiler will optimize this to y = 15
            var y = x + 10;

            /* the value of x will always be the current value, but y will always be "15" */
            Debug.WriteLine("x = " + x + ", y = " + y);
        }    
    }

Yukarıdaki kod bloğunda, derleyici 'x = 5' ve 'y = x + 10' ifadelerini okur ve 'y'nin değerinin her zaman 15 olacağını belirler. Böylece son ifadeyi şu şekilde optimize edecektir. `y = 15`. Ancak, 'x' değişkeni aslında bir 'genel' alandır ve 'x' değeri çalışma zamanında bu alan üzerinde ayrı olarak hareket eden farklı bir iş parçacığı aracılığıyla değiştirilebilir. Şimdi bu değiştirilmiş kod bloğunu düşünün. "x" alanının artık "geçici" olarak bildirildiğini unutmayın.

    public class Example
    {
        public volatile int x;

        public void DoStuff()
        {
            x = 5;

            // the compiler no longer optimizes this statement
            var y = x + 10;

            /* the value of x and y will always be the correct values */
            Debug.WriteLine("x = " + x + ", y = " + y);
        }    
    }

Şimdi, derleyici `x` alanının *okuma* kullanımlarını arar ve alanın mevcut değerinin her zaman alınmasını sağlar. Bu, birden fazla iş parçacığı bu alana okuyup yazıyor olsa bile, geçerli `x` değerinin her zaman alınmasını sağlar.

"uçucu" yalnızca "sınıflar" veya "yapılar" içindeki alanlarda kullanılabilir. Aşağıdakiler [*geçerli değildir][2]:

<pre>genel geçersiz MyMethod()
{
    <strike>volatile</strike> int x;
}</pre>

"uçucu" yalnızca aşağıdaki türlerdeki alanlara uygulanabilir:
- referans türleri veya referans türleri olarak bilinen genel tür parametreleri
- "sbyte", "byte", "short", "ushort", "int", "uint", "char", "float" ve "bool" gibi ilkel türler
- "byte", "sbyte", "short", "ushort", "int" veya "uint"e dayalı türleri sıralar
- "IntPtr" ve "UIntPtr"

----------
**Notlar:**

- [`volatile`][1] değiştiricisi genellikle erişimi seri hale getirmek için lock deyimi kullanılmadan birden çok iş parçacığı tarafından erişilen bir alan için kullanılır.
- 'volatile' anahtar sözcüğü, referans türlerinin alanlarına uygulanabilir
- 'volatile' anahtar sözcüğü, 32 bitlik bir platformda 64 bit ilkel öğeler üzerinde çalışmayı atomik hale getirmez. Bu platformlarda güvenli çoklu iş parçacıklı erişim için [`Interlocked.Read`][3] ve [`Interlocked.Exchange`][4] gibi kilitli işlemler hala kullanılmalıdır.


[1]: http://stackoverflow.com/questions/72275/When-should-the-volatile-keyword-be-used-in-c
[2]: https://msdn.microsoft.com/en-us/library/x13ttww7.aspx
[3]: https://msdn.microsoft.com/en-us/library/system.threading.interlocked.read(v=vs.110).aspx
[4]: https://msdn.microsoft.com/en-us/library/dk0121zy(v=vs.110).aspx

## işaretlendi, işaretlenmemiş
"İşaretli" ve "işaretsiz" anahtar sözcükleri, işlemlerin matematiksel taşmayı nasıl ele alacağını tanımlar. "Kontrol edilmiş" ve "işlenmemiş" anahtar sözcükleri bağlamındaki "taşma", bir tamsayı aritmetik işleminin, hedef veri türünün temsil edebileceğinden daha büyük bir değerle sonuçlanmasıdır.

Bir "kontrollü" blok içinde taşma meydana geldiğinde (veya derleyici global olarak kontrol edilen aritmetiği kullanacak şekilde ayarlandığında), istenmeyen davranışa karşı uyarmak için bir istisna atılır. Bu arada, "denetlenmemiş" bir blokta, taşma sessizdir: hiçbir istisna atılmaz ve değer basitçe karşı sınıra sarılır. Bu, ince, bulunması zor hatalara yol açabilir.

Çoğu aritmetik işlem, taşacak kadar büyük veya küçük olmayan değerler üzerinde yapıldığından, çoğu zaman bir bloğu 'checked' olarak açıkça tanımlamaya gerek yoktur. Örneğin özyinelemeli işlevlerde aritmetik yaparken veya kullanıcı girdisi alırken taşmaya neden olabilecek sınırsız girdi üzerinde aritmetik yaparken dikkatli olunmalıdır.

_Ne "işaretli" ne de "işaretsiz", kayan nokta aritmetik işlemlerini etkilemez._

Bir blok veya ifade "işaretsiz" olarak bildirildiğinde, içindeki herhangi bir aritmetik işlemin hataya neden olmadan taşmasına izin verilir. Bu davranışın *istendiği* bir örnek, hesaplama sırasında değerin "sarılmasına" izin verilen bir sağlama toplamının hesaplanması olabilir:

    byte Checksum(byte[] data) {
        byte result = 0;
        for (int i = 0; i < data.Length; i++) {
            result = unchecked(result + data[i]); // unchecked expression
        }
        return result;
    }

"Denetlenmemiş" ifadesinin en yaygın kullanımlarından biri, bir tür sağlama toplamı olan "object.GetHashCode()" için özel bir geçersiz kılma uygulamaktır. Anahtar kelimenin kullanımını bu sorunun yanıtlarında görebilirsiniz: http://stackoverflow.com/questions/263400/what-is-the-best-algorithm-for-an-overridden-system-object-gethashcode.

Bir blok veya ifade "işaretli" olarak bildirildiğinde, taşmaya neden olan herhangi bir aritmetik işlem, bir "OverflowException"ın atılmasına neden olur.

    int SafeSum(int x, int y) {
        checked { // checked block
            return x + y; 
        }
    }

Hem işaretli hem de işaretlenmemiş blok ve ifade biçiminde olabilir.

İşaretli ve işaretsiz bloklar, çağrılan yöntemleri etkilemez, yalnızca doğrudan geçerli yöntemde çağrılan operatörler. Örneğin, `Enum.ToObject()`, `Convert.ToInt32()` ve kullanıcı tanımlı operatörler, özel işaretli/işaretsiz bağlamlardan etkilenmez.

***Not**: Varsayılan taşma varsayılan davranışı (işaretli ve işaretlenmemiş) **Proje Özellikleri**'nde veya **/checked[+|-]** komut satırı anahtarı aracılığıyla değiştirilebilir. Hata ayıklama derlemeleri için kontrol edilen işlemler ve sürüm derlemeleri için kontrol edilmeyen işlemler varsayılan olarak yaygındır. "checked" ve "unchecked" anahtar sözcükleri yalnızca bir _default_ yaklaşımının geçerli olmadığı ve doğruluğu sağlamak için açık bir davranışa ihtiyacınız olduğunda kullanılacaktır.*

## sanal, geçersiz kıl, yeni
sanal ve geçersiz kıl
====================

'Sanal' anahtar sözcüğü, bir yöntemin, özelliğin, dizin oluşturucunun veya olayın türetilmiş sınıflar tarafından geçersiz kılınmasına ve polimorfik davranışın sunulmasına izin verir. (Üyeler C#'da varsayılan olarak sanal değildir)

    public class BaseClass
    {
        public virtual void Foo()
        {
            Console.WriteLine("Foo from BaseClass");
        }
    }

Bir üyeyi geçersiz kılmak için türetilmiş sınıflarda 'override' anahtar sözcüğü kullanılır. (Üyelerin imzasının aynı olması gerektiğini unutmayın)

    public class DerivedClass: BaseClass
    {
        public override void Foo()
        {
            Console.WriteLine("Foo from DerivedClass");
        }
    }

Sanal üyelerin polimorfik davranışı, çağrıldığında yürütülmekte olan gerçek üyenin derleme zamanı yerine çalışma zamanında belirlendiği anlamına gelir. Belirli nesnenin bir örneği olduğu en türetilmiş sınıftaki geçersiz kılan üye, yürütülecek olan olacaktır.

Kısacası, nesne derleme zamanında 'BaseClass' türünde bildirilebilir, ancak çalışma zamanında bu bir 'DerivedClass' örneğiyse, geçersiz kılınan üye yürütülür:

    BaseClass obj1 = new BaseClass();
    obj1.Foo(); //Outputs "Foo from BaseClass"

    obj1 = new DerivedClass();
    obj1.Foo(); //Outputs "Foo from DerivedClass"    

Bir yöntemi geçersiz kılmak isteğe bağlıdır:

    public class SecondDerivedClass: DerivedClass {}
    
    var obj1 = new SecondDerivedClass();
    obj1.Foo(); //Outputs "Foo from DerivedClass"    

yeni
====================    
Yalnızca "sanal" olarak tanımlanan üyeler geçersiz kılınabilir ve polimorfik olduğundan, sanal olmayan bir üyeyi yeniden tanımlayan türetilmiş bir sınıf beklenmedik sonuçlara yol açabilir.

    public class BaseClass
    {
        public void Foo()
        {
            Console.WriteLine("Foo from BaseClass");
        }
    }

    public class DerivedClass: BaseClass
    {
        public void Foo()
        {
            Console.WriteLine("Foo from DerivedClass");
        }
    }

    BaseClass obj1 = new BaseClass();
    obj1.Foo(); //Outputs "Foo from BaseClass"

    obj1 = new DerivedClass();
    obj1.Foo(); //Outputs "Foo from BaseClass" too!    

Bu olduğunda, yürütülen üye her zaman nesnenin türüne göre derleme zamanında belirlenir.

- Nesne 'TemelSınıf' türünde bildirilmişse (çalışma zamanında türetilmiş bir sınıfta olsa bile), o zaman 'TemelSınıf' yöntemi yürütülür
- Nesne 'DerivedClass' türünde bildirilirse, 'DerivedClass' yöntemi yürütülür.

Bu genellikle bir kazadır (türetilmiş türe özdeş bir üye eklendikten sonra temel türe bir üye eklendiğinde) ve bu senaryolarda bir derleyici uyarısı **CS0108** oluşturulur.

Eğer kasıtlıysa, derleyici uyarısını bastırmak için 'new' anahtar sözcüğü kullanılır (Ve diğer geliştiricilere niyetinizi bildirin!). davranış aynı kalır, "new" anahtar sözcüğü derleyici uyarısını bastırır.

    public class BaseClass
    {
        public void Foo()
        {
            Console.WriteLine("Foo from BaseClass");
        }
    }

    public class DerivedClass: BaseClass
    {
        public new void Foo()
        {
            Console.WriteLine("Foo from DerivedClass");
        }
    }

    BaseClass obj1 = new BaseClass();
    obj1.Foo(); //Outputs "Foo from BaseClass"

    obj1 = new DerivedClass();
    obj1.Foo(); //Outputs "Foo from BaseClass" too! 

Geçersiz kılmanın kullanımı isteğe bağlı değildir
=======================================
C++'dan farklı olarak, "override" anahtar sözcüğünün kullanımı *isteğe bağlı değildir*:

    public class A
    {
        public virtual void Foo()
        {
        }
    }

    public class B : A
    {
        public void Foo() // Generates CS0108
        {
        }
    }

Yukarıdaki örnek ayrıca **CS0108** uyarısına neden olur, çünkü "B.Foo()" otomatik olarak "A.Foo()" öğesini geçersiz kılmaz. Temel sınıfı geçersiz kılmak ve polimorfik davranışa neden olmak istendiğinde 'override' ekleyin, polimorfik olmayan davranış istediğinizde 'new' ekleyin ve statik türü kullanarak çağrıyı çözün. İkincisi, ciddi karışıklığa neden olabileceğinden dikkatli kullanılmalıdır.

Aşağıdaki kod bile bir hatayla sonuçlanır:

    public class A
    {
        public void Foo()
        {
        }
    }

    public class B : A
    {
        public override void Foo() // Error: Nothing to override
        {
        }
    }

Türetilmiş sınıflar polimorfizmi tanıtabilir
==========================================
Aşağıdaki kod tamamen geçerlidir (nadir de olsa):

        public class A
        {
            public void Foo()
            {
                Console.WriteLine("A");
            }
        }

        public class B : A
        {
            public new virtual void Foo() 
            {
                Console.WriteLine("B");
            }
        }

Şimdi, B'nin (ve türevlerinin) statik referansına sahip tüm nesneler, 'Foo()' çözümlemek için polimorfizm kullanırken, A'nın referansları 'A.Foo()' kullanır.

    A a = new A();
    a.Foo(); // Prints "A";
    a = new B();
    a.Foo(); // Prints "A";
    B b = new B();
    b.Foo(); // Prints "B";

Sanal yöntemler özel olamaz
=================================
C# derleyicisi anlamsız yapıları önleme konusunda katıdır. "Sanal" olarak işaretlenen yöntemler özel olamaz. Türetilmiş bir türden özel bir yöntem görülemediğinden, üzerine de yazılamaz. Bu derleme başarısız olur:

    public class A
    {
        private virtual void Foo() // Error: virtual methods cannot be private
        {
        }
    }

## stackalloc
"stackalloc" anahtar sözcüğü yığında bir bellek bölgesi oluşturur ve bu belleğin başlangıcına bir işaretçi döndürür. Yığın ayrılmış bellek, oluşturulduğu kapsamdan çıkıldığında otomatik olarak kaldırılır.

    //Allocate 1024 bytes. This returns a pointer to the first byte.
    byte* ptr = stackalloc byte[1024];

    //Assign some values...
    ptr[0] = 109;
    ptr[1] = 13;
    ptr[2] = 232;
    ...

<sup>*Güvenli olmayan bir bağlamda kullanıldı.*</sup>

C#'daki tüm işaretçilerde olduğu gibi, okumaları ve atamaları kontrol etmede sınır yoktur. Ayrılan belleğin sınırlarının ötesinde okuma, tahmin edilemez sonuçlara yol açacaktır - bellek içindeki bazı rastgele konumlara erişebilir veya bir erişim ihlali istisnasına neden olabilir.

    //Allocate 1 byte
    byte* ptr = stackalloc byte[1];

    //Unpredictable results...
    ptr[10] = 1;
    ptr[-1] = 2;

Yığın ayrılmış bellek, oluşturulduğu kapsamdan çıkıldığında otomatik olarak kaldırılır. Bu, stackalloc ile oluşturulan belleği asla iade etmemeniz veya kapsamın kullanım süresinin ötesinde saklamamanız gerektiği anlamına gelir.

    unsafe IntPtr Leak() {
        //Allocate some memory on the stack
        var ptr = stackalloc byte[1024];

        //Return a pointer to that memory (this exits the scope of "Leak")
        return new IntPtr(ptr);
    }

    unsafe void Bad() {
         //ptr is now an invalid pointer, using it in any way will have
         //unpredictable results. This is exactly the same as accessing beyond
         //the bounds of the pointer.
         var ptr = Leak();
    }

"stackalloc" yalnızca *ve* değişkenleri başlatılırken bildirilirken kullanılabilir. Aşağıdakiler *geçersizdir*:

    byte* ptr;
    ...
    ptr = stackalloc byte[1024];

----------
**Notlar:**

"stackalloc" yalnızca performans optimizasyonları için kullanılmalıdır (hesaplama veya birlikte çalışma için). Bunun nedeni şudur:

- Bellek yığın yerine yığına ayrıldığından çöp toplayıcı gerekli değildir - değişken kapsam dışına çıkar çıkmaz bellek serbest bırakılır
- Yığın yerine yığına bellek ayırmak daha hızlıdır
- Verilerin yerelliği nedeniyle CPU'da önbellek isabet şansını artırın

## kırmak
Bir döngüde (for, foreach, do, while) 'break' ifadesi en içteki döngünün yürütülmesini iptal eder ve ondan sonraki koda geri döner. Ayrıca bir yineleyicinin sona erdiğini belirten 'verim' ile de kullanılabilir.

    for (var i = 0; i < 10; i++)
    {
        if (i == 5)
        {
            break;
        }
        Console.WriteLine("This will appear only 5 times, as the break will stop the loop.");
    }

[.NET Fiddle'da Canlı Demo](https://dotnetfiddle.net/QtpNyk)
    
    foreach (var stuff in stuffCollection)
    {
        if (stuff.SomeStringProp == null)
            break;
        // If stuff.SomeStringProp for any "stuff" is null, the loop is aborted.
        Console.WriteLine(stuff.SomeStringProp);
    }

break-deyimi aynı zamanda switch-case yapılarında bir vakadan veya varsayılan segmentten çıkmak için kullanılır.

    switch(a)
    {
        case 5:
            Console.WriteLine("a was 5!");
            break;

        default:
            Console.WriteLine("a was something else!");
            break;
    }

Switch deyimlerinde, her case deyiminin sonunda 'break' anahtar sözcüğü gereklidir. Bu, serideki bir sonraki vaka ifadesine 'düşmeye' izin veren bazı dillere aykırıdır. Bunun için geçici çözümler, 'goto' ifadelerini veya 'case' ifadelerini sırayla istiflemeyi içerir.

Aşağıdaki kod `0, 1, 2, ..., 9` rakamlarını verecek ve son satır çalıştırılmayacaktır. 'verim sonu' işlevin sonunu belirtir (sadece bir döngü değil).

    public static IEnumerable<int> GetNumbers()
    {
        int i = 0;
        while (true) {
            if (i < 10) {
                yield return i++;
            } else {
                yield break;
            }
        }
        Console.WriteLine("This line will not be executed");
    }

[.NET Fiddle'da Canlı Demo][1]


Diğer bazı dillerden farklı olarak, C#'ta belirli bir arayı etiketlemenin bir yolu olmadığını unutmayın. Bu, iç içe döngüler durumunda yalnızca en içteki döngünün durdurulacağı anlamına gelir:

    foreach (var outerItem in outerList)
    {
        foreach (var innerItem in innerList)
        {
            if (innerItem.ShoudBreakForWhateverReason)
                // This will only break out of the inner loop, the outer will continue:
                break; 
        }
    }

Buradaki *dış* döngüden çıkmak istiyorsanız, aşağıdakiler gibi birkaç farklı stratejiden birini kullanabilirsiniz:
- Tüm döngü yapısından atlamak için bir **goto** ifadesi.
- Dış döngünün her yinelemesinin sonunda kontrol edilebilen belirli bir bayrak değişkeni (aşağıdaki örnekte 'shouldBreak').
- En içteki döngü gövdesinde bir 'return' ifadesi kullanmak için kodu yeniden düzenleme veya tüm iç içe döngü yapısından tamamen kaçınma.


    bool shouldBreak = false;
    while(comeCondition)
    {
        while(otherCondition)
        {
            if (conditionToBreak)
            {
                // Either tranfer control flow to the label below...
                goto endAllLooping;

                // OR use a flag, which can be checked in the outer loop:
                shouldBreak = true;
            }
        }

        if(shouldBreakNow)
        {
            break; // Break out of outer loop if flag was set to true
        }
    }

    endAllLooping: // label from where control flow will continue



[1]: https://dotnetfiddle.net/IjSyVJ

## sabit
"const", programın ömrü boyunca **asla değişmeyecek** değerleri temsil etmek için kullanılır. Değeri [`salt okunur'](https://www.wikiod.com/tr/docs/c%23/26/keywords/110/readonly) anahtar sözcüğünün aksine, değeri **derleme zamanından** sabittir. çalışma zamanından sabit.

Örneğin ışığın hızı hiçbir zaman değişmeyeceği için onu bir sabitte tutabiliriz.

    const double c = 299792458;  // Speed of light
    
    double CalculateEnergy(double mass)
    {
        return mass * c * c;
    }

Bu, esasen "dönüş kütlesi * 299792458 * 299792458" ile aynıdır, çünkü derleyici doğrudan "c"yi sabit değeriyle değiştirecektir.

Sonuç olarak, "c" bir kez bildirildiğinde değiştirilemez. Aşağıdakiler bir derleme zamanı hatası üretecektir:

    const double c = 299792458;  // Speed of light 
    
    c = 500;  //compile-time error
    
Bir sabit, yöntemlerle aynı erişim değiştiricileri ile ön eklenebilir:

    private const double c = 299792458;
    public const double c = 299792458;
    internal const double c = 299792458;

'const' üyeleri doğası gereği 'statik'tir. Ancak, açıkça "statik" kullanımına izin verilmez.

Ayrıca yöntem-yerel sabitleri de tanımlayabilirsiniz:

    double CalculateEnergy(double mass)
    {
        const c = 299792458;
        return mass * c * c;
    }

Bunlar, tanımlandıkları yöntemde dolaylı olarak yerel olduklarından, bir "private" veya "public" anahtar sözcüğüyle önek olamazlar.

----------

Tüm türler bir "const" bildiriminde kullanılamaz. İzin verilen değer türleri, önceden tanımlanmış türler 'sbyte', 'byte', 'short', 'ushort', 'int', 'uint', 'long', ulong', 'char', ' float', 'double', 'decimal', 'bool' ve tüm 'enum' türleri. Diğer değer türleriyle ("TimeSpan" veya "Guid" gibi) "const" üyelerini bildirmeye çalışmak derleme zamanında başarısız olacaktır.

Özel önceden tanımlanmış referans türü 'string' için, sabitler herhangi bir değerle bildirilebilir. Diğer tüm referans türleri için sabitler bildirilebilir ancak her zaman "null" değerine sahip olmalıdır.

----------

"const" değerleri derleme zamanında bilindiğinden, bir "switch" ifadesinde "case" etiketleri olarak, isteğe bağlı parametreler için standart argümanlar olarak, öznitelik belirtimleri için argümanlar olarak vb. izin verilir.

----------

Farklı derlemeler arasında "const" değerleri kullanılıyorsa, sürüm oluşturma konusunda dikkatli olunmalıdır. Örneğin, A derlemesi bir "public const int MaxRetries = 3;" tanımlıyorsa ve B derlemesi bu sabiti kullanıyorsa, o zaman "MaxRetries" değeri daha sonra A derlemesinde "5" olarak değiştirilirse (daha sonra yeniden derlenir) ), bu değişiklik B derlemesinde etkili olmayacaktır _Asamblesi B de yeniden derlenmedikçe (A'nın yeni sürümüne atıfta bulunularak).

Bu nedenle, programın gelecekteki revizyonlarında bir değer değişebilirse ve değerin herkese açık olması gerekiyorsa, bir şey değiştiğinde tüm bağımlı derlemelerin yeniden derleneceğini bilmiyorsanız, bu değeri 'const' olarak beyan etmeyin. . Alternatif, çalışma zamanında çözülen 'const' yerine 'statik salt okunur' kullanmaktır.

## için
Sözdizimi: `for (başlatıcı; koşul; yineleyici)'

- "for" döngüsü, yineleme sayısı bilindiğinde yaygın olarak kullanılır.
- 'initializer' bölümündeki ifadeler, siz döngüye girmeden önce yalnızca bir kez çalışır.
- "Koşul" bölümü, her döngü yinelemesinin sonunda, döngüden çıkıp çıkmayacağını veya yeniden çalışıp çalışmayacağını belirlemek için değerlendirilen bir boole ifadesi içerir.
- "Yineleyici" bölümü, döngü gövdesinin her yinelemesinden sonra ne olacağını tanımlar.

Bu örnek, bir dizenin karakterleri üzerinde yineleme yapmak için "for"un nasıl kullanılabileceğini gösterir:

    string str = "Hello";
    for (int i = 0; i < str.Length; i++)
    {
        Console.WriteLine(str[i]);                
    }
                     
Çıktı:

>H
>e
>l
>l
>o

[<kbd>.NET Fiddle'da Canlı Demo</kbd>](https://dotnetfiddle.net/Ybg356)

Bir "for" ifadesini tanımlayan tüm ifadeler isteğe bağlıdır; örneğin, sonsuz bir döngü oluşturmak için aşağıdaki ifade kullanılır:

    for( ; ; )
    {
        // Your code here
    }

"Başlatıcı" bölümü, aynı türden oldukları sürece birden çok değişken içerebilir. "Koşul" bölümü, "bool" olarak değerlendirilebilecek herhangi bir ifadeden oluşabilir. Ve "yineleyici" bölümü, virgülle ayrılmış birden çok işlemi gerçekleştirebilir:

    string hello = "hello";
    for (int i = 0, j = 1, k = 9; i < 3 && k > 0; i++, hello += i) {
        Console.WriteLine(hello);
    }

Çıktı:

>merhaba
> merhaba1
> merhaba12

[<kbd>.NET Fiddle'da Canlı Demo</kbd>](https://dotnetfiddle.net/LQcqCv)

## zaman uyumsuz, bekle


'await' anahtar sözcüğü, Visual Studio 2012'den itibaren desteklenen C# 5.0 sürümünün bir parçası olarak eklendi. Çoklu iş parçacığını nispeten daha kolay hale getiren Görev Paralel Kitaplığı'ndan (TPL) yararlanır. "async" ve "await" anahtar sözcükleri, aşağıda gösterildiği gibi aynı işlevde çift olarak kullanılır. 'await' anahtar sözcüğü, beklenen eşzamansız görev tamamlanana ve/veya sonuçları döndürülene kadar mevcut eşzamansız yöntemin yürütülmesini duraklatmak için kullanılır. 'await' anahtar sözcüğünü kullanmak için, onu kullanan yöntemin 'async' anahtar sözcüğü ile işaretlenmesi gerekir.

"async"in "void" ile kullanılması kesinlikle önerilmez. Daha fazla bilgi için [buraya][1] bakabilirsiniz.

Örnek:

    public async Task DoSomethingAsync()
    {    
        Console.WriteLine("Starting a useless process...");
        Stopwatch stopwatch = Stopwatch.StartNew();
        int delay = await UselessProcessAsync(1000);
        stopwatch.Stop();
        Console.WriteLine("A useless process took {0} milliseconds to execute.", stopwatch.ElapsedMilliseconds);
    }
    
    public async Task<int> UselessProcessAsync(int x)
    {
        await Task.Delay(x);
        return x;
    }

Çıktı:

> "İşe yaramaz bir süreç başlatmak..."\
> \
> **... 1 saniye gecikme... **
> 
> "İşe yaramaz bir işlemin yürütülmesi 1000 milisaniye sürdü."

Bir "Görev" veya "Görev<T>" döndürme yöntemi yalnızca tek bir eşzamansız işlem döndürürse, "async" ve "await" anahtar sözcük çiftleri atlanabilir.

*Bunun yerine:*

    public async Task PrintAndDelayAsync(string message, int delay)
    {
        Debug.WriteLine(message);
        await Task.Delay(x);
    }

*Şunu yapmak tercih edilir:*

    public Task PrintAndDelayAsync(string message, int delay)
    {
        Debug.WriteLine(message);
        return Task.Delay(x);
    }
<!-- eğer sürüm [eq 5.0] -->
C# 5.0'da 'await', 'catch' ve 'nihayet' için kullanılamaz.

<!-- eğer --> son sürüm

<!-- eğer [gte 6.0] versiyonu -->
[C# 6.0 ile][2] 'await', 'yakala' ve 'nihayet' için kullanılabilir.
<!-- eğer --> son sürüm


[1]: https://msdn.microsoft.com/en-us/magazine/jj991977.aspx
[2]: https://www.wikiod.com/tr/docs/c%23/24/c-sharp-6-0-features/50/await-in-catch-and-finally#t=201607281146527675886

## Öz
"abstract" anahtar kelimesiyle işaretlenmiş bir sınıf somutlaştırılamaz.

Bir sınıf, soyut üyeler içeriyorsa veya uygulamadığı soyut üyeleri miras alıyorsa, soyut olarak * işaretlenmelidir. Soyut üyeler dahil olmasa bile bir sınıf * soyut olarak işaretlenebilir.

Soyut sınıflar, uygulamanın bir kısmının başka bir bileşen tarafından belirtilmesi gerektiğinde genellikle temel sınıflar olarak kullanılır.

    abstract class Animal 
    {
        string Name { get; set; }
        public abstract void MakeSound();
    }
    
    public class Cat : Animal 
    {
        public override void MakeSound()
        {
            Console.WriteLine("Meov meov");
        }
    }
    
    public class Dog : Animal 
    {   
        public override void MakeSound()
        {
            Console.WriteLine("Bark bark");
        }
    }
    
    Animal cat = new Cat();       // Allowed due to Cat deriving from Animal
    cat.MakeSound();              // will print out "Meov meov"    

    Animal dog = new Dog();       // Allowed due to Dog deriving from Animal
    dog.MakeSound();              // will print out "Bark bark"

    Animal animal = new Animal(); // Not allowed due to being an abstract class

"abstract" anahtar sözcüğüyle işaretlenmiş bir yöntem, özellik veya olay, o üye için uygulamanın bir alt sınıfta sağlanmasının beklendiğini belirtir. Yukarıda belirtildiği gibi, soyut üyeler sadece soyut sınıflarda görünebilir.

    abstract class Animal 
    {
       public abstract string Name { get; set; }
    }
    
    public class Cat : Animal 
    {
        public override string Name { get; set; }
    }
    
    public class Dog : Animal 
    {
        public override string Name { get; set; }
    }

## sabit
Sabit ifade, belleği tek bir konumda sabitler. Bellekteki nesneler genellikle etrafta hareket eder, bu da çöp toplamayı mümkün kılar. Ancak bellek adreslerine güvenli olmayan işaretçiler kullandığımızda, bu bellek taşınmamalıdır.

- Çöp toplayıcının dize verilerini yeniden konumlandırmamasını sağlamak için sabit ifadeyi kullanıyoruz.

<h3>Sabit Değişkenler</h3>

    var myStr = "Hello world!";
    
    fixed (char* ptr = myStr)
    {
        // myStr is now fixed (won't be [re]moved by the Garbage Collector).
        // We can now do something with ptr.
    }

<sup>*Güvenli olmayan bir bağlamda kullanıldı.*</sup>


<h3>Sabit Dizi Boyutu</h3>

    unsafe struct Example
    {
        public fixed byte SomeField[8];
        public fixed char AnotherField[64];
    }

"sabit" yalnızca bir "yapı" içindeki alanlarda kullanılabilir (güvenli olmayan bir bağlamda da kullanılmalıdır).


## varsayılan
Sınıflar, arabirimler, temsilci, dizi, nullable (int? gibi) ve işaretçi türleri için "default(TheType)", "null" değerini döndürür:

    class MyClass {}
    Debug.Assert(default(MyClass) == null);
    Debug.Assert(default(string) == null);

Yapılar ve numaralandırmalar için "default(TheType)", "new TheType()" ile aynı değeri döndürür:

    struct Coordinates
    {
        public int X { get; set; }
        public int Y { get; set; }
    }

    struct MyStruct
    {
        public string Name { get; set; }
        public Coordinates Location { get; set; }
        public Coordinates? SecondLocation { get; set; }
        public TimeSpan Duration { get; set; }
    }

    var defaultStruct = default(MyStruct);
    Debug.Assert(defaultStruct.Equals(new MyStruct()));
    Debug.Assert(defaultStruct.Location.Equals(new Coordinates()));
    Debug.Assert(defaultStruct.Location.X == 0);
    Debug.Assert(defaultStruct.Location.Y == 0);
    Debug.Assert(defaultStruct.SecondLocation == null);
    Debug.Assert(defaultStruct.Name == null);
    Debug.Assert(defaultStruct.Duration == TimeSpan.Zero);

"varsayılan(T)", "T"nin bir referans türü mü yoksa bir değer türü mü olduğuna karar vermek için hiçbir kısıtlamanın bulunmadığı genel bir parametre olduğunda özellikle yararlı olabilir, örneğin:

    public T GetResourceOrDefault<T>(string resourceName)
    {
       if (ResourceExists(resourceName))
       {
          return (T)GetResource(resourceName);
       }
       else
       {
          return default(T);
       }
    }

## dır-dir
Bir nesnenin belirli bir türle uyumlu olup olmadığını, yani bir nesnenin "BaseInterface" türünün bir örneği olup olmadığını veya "BaseInterface"den türetilen bir tür olup olmadığını kontrol eder:

    interface BaseInterface {}
    class BaseClass : BaseInterface {}
    class DerivedClass : BaseClass {}

    var d = new DerivedClass();
    Console.WriteLine(d is DerivedClass);  // True
    Console.WriteLine(d is BaseClass);     // True
    Console.WriteLine(d is BaseInterface); // True
    Console.WriteLine(d is object);        // True
    Console.WriteLine(d is string);        // False
    
    var b = new BaseClass();
    Console.WriteLine(b is DerivedClass);  // False
    Console.WriteLine(b is BaseClass);     // True
    Console.WriteLine(b is BaseInterface); // True
    Console.WriteLine(b is object);        // True
    Console.WriteLine(b is string);        // False

Oyuncu kadrosunun amacı nesneyi kullanmaksa, [`as`](https://www.wikiod.com/tr/docs/c%23/26/keywords/138/as) anahtar sözcüğünü kullanmak en iyi uygulamadır.

    interface BaseInterface {}
    class BaseClass : BaseInterface {}
    class DerivedClass : BaseClass {}

    var d = new DerivedClass();
    Console.WriteLine(d is DerivedClass);  // True - valid use of 'is'
    Console.WriteLine(d is BaseClass);     // True - valid use of 'is'
    
    if(d is BaseClass){
        var castedD = (BaseClass)d;
        castedD.Method(); // valid, but not best practice
    }

    var asD = d as BaseClass;

    if(asD!=null){
        asD.Method(); //prefered method since you incur only one unboxing penalty
    }

Ancak, C# 7'den [`desen eşleştirme'](https://www.wikiod.com/tr/docs/c%23/1936/c-sharp-7-0-features/13323/pattern-matching#t=201707130940065371224) özelliği genişletilir is operatörü, bir türü kontrol etmek ve aynı anda yeni bir değişken bildirmek için kullanılır. C# 7 ile aynı kod parçası:

<!-- eğer sürüm [gte 7.0] -->

    if(d is BaseClass asD ){
        asD.Method();
    }
<!-- eğer --> son sürüm

## Mühürlü
Bir sınıfa uygulandığında, 'sealed' değiştiricisi diğer sınıfların ondan miras almasını engeller.

    class A { }
    sealed class B : A { }
    class C : B { } //error : Cannot derive from the sealed class

Bir "sanal" yönteme (veya sanal özelliğe) uygulandığında, "mühürlü" değiştirici, bu yöntemin (özelliğin) türetilmiş sınıflarda *geçersiz kılınmasını* engeller.

    public class A 
    {
        public sealed override string ToString() // Virtual method inherited from class Object
        {
            return "Do not override me!";
        }
    }

    public class B: A 
    {
        public override string ToString() // Compile time error
        { 
            return "An attempt to override"; 
        }
    }

## Sadece oku
"salt okunur" anahtar sözcüğü bir alan değiştiricidir. Bir alan bildirimi bir "salt okunur" değiştirici içerdiğinde, bu alana atamalar yalnızca bildirimin bir parçası olarak veya aynı sınıftaki bir kurucuda gerçekleşebilir.

"salt okunur" anahtar sözcüğü, "const" anahtar sözcüğünden farklıdır. Bir "const" alanı yalnızca alanın bildirilmesinde başlatılabilir. Bir "salt okunur" alan, ya bildirimde ya da bir kurucuda başlatılabilir. Bu nedenle, "salt okunur" alanlar, kullanılan oluşturucuya bağlı olarak farklı değerlere sahip olabilir.

"salt okunur" anahtar sözcüğü genellikle bağımlılıklar enjekte edilirken kullanılır.

    class Person
    {
        readonly string _name;
        readonly string _surname = "Surname";

        Person(string name)
        {
            _name = name;
        }
        void ChangeName()
        {
            _name = "another name"; // Compile error
            _surname = "another surname"; // Compile error
        }
    }


> Not: Bir alanın *salt okunur* olarak bildirilmesi *değişmezlik* anlamına gelmez. Alan bir *referans türü* ise, nesnenin **içeriği** değiştirilebilir. *Salt okunur* genellikle nesnenin **üzerine yazılmasını** ve yalnızca o nesnenin **örneği** sırasında atanmasını önlemek için kullanılır.

> Not: Yapıcı içinde salt okunur bir alan yeniden atanabilir

    public class Car
    {
        public double Speed {get; set;}
    }

    //In code

    private readonly Car car = new Car();

    private void SomeMethod()
    {
        car.Speed = 100;
    }

## bir çeşit
Bir nesnenin "Tür"ünü, somutlaştırmaya gerek kalmadan döndürür.

    Type type = typeof(string);
    Console.WriteLine(type.FullName); //System.String
    Console.WriteLine("Hello".GetType() == type); //True
    Console.WriteLine("Hello".GetType() == typeof(string)); //True

## Bu
`this` anahtar kelimesi, sınıfın(nesnenin) mevcut örneğini ifade eder. Bu şekilde, biri sınıf düzeyinde (bir alan) ve diğeri bir yöntemin parametresi (veya yerel değişken) olmak üzere aynı ada sahip iki değişken ayırt edilebilir.
    
    public MyClass {
        int a;
    
        void set_a(int a)
        {
            //this.a refers to the variable defined outside of the method,
            //while a refers to the passed parameter.
            this.a = a;
        }
    }

Anahtar kelimenin diğer kullanımları [statik olmayan yapıcı aşırı yüklemelerini zincirleme] şeklindedir:

    public MyClass(int arg) : this(arg, null)
    {
    }

ve [dizinleyiciler][2] yazarak:

    public string this[int idx1, string idx2]
    {
        get { /* ... */ }
        set { /* ... */ }
    }

ve [uzatma yöntemlerini][3] bildirerek:

    public static int Count<TItem>(this IEnumerable<TItem> source)
    {
        // ...
    }

Yerel bir değişken veya parametre ile çakışma yoksa, 'this' kullanılıp kullanılmaması bir stil meselesidir, bu nedenle 'this.MemberOfType' ve 'MemberOfType' bu durumda eşdeğer olacaktır. Ayrıca [`base`][4] anahtar kelimesine bakın.

Geçerli örnekte bir uzantı yöntemi çağrılacaksa, "bu"nun gerekli olduğunu unutmayın. Örneğin, 'IEnumerable<>' uygulayan bir sınıfın statik olmayan bir yönteminin içindeyseniz ve daha önce 'Count' uzantısını çağırmak istiyorsanız, şunları kullanmalısınız:

    this.Count()  // works like StaticClassForExtensionMethod.Count(this)

ve "bu" burada atlanamaz.


[1]: https://www.wikiod.com/tr/docs/c%23/25/constructors-destructors/56/calling-a-constructor-from-another-constructor#t=201607231911138150753
[2]: https://www.wikiod.com/tr/docs/c%23/1660/indexer#t=201607252101420586035
[3]: https://www.wikiod.com/tr/docs/c%23/20/extension-methods#t=20160723191025670507
[4]: https://www.wikiod.com/tr/docs/c%23/26/keywords/1840/base#t=201607261455204441752

## her biri için
"foreach", bir dizinin öğelerini veya [`IEnumerable`][3]✝ uygulayan bir koleksiyon içindeki öğeleri yinelemek için kullanılır.

    var lines = new string[] { 
        "Hello world!", 
        "How are you doing today?", 
        "Goodbye"
    };

    foreach (string line in lines)
    {
        Console.WriteLine(line);
    }

Bu çıktı

> "Merhaba dünya!"
> "Bugün nasılsın?"
> "Hoşçakal"

[.NET Fiddle'da Canlı Demo](https://dotnetfiddle.net/0jy78m)

[break][1] anahtar sözcüğünü kullanarak herhangi bir noktada 'foreach' döngüsünden çıkabilir veya [continue][2] anahtar sözcüğünü kullanarak bir sonraki yinelemeye geçebilirsiniz.

    var numbers = new int[] {1, 2, 3, 4, 5, 6};

    foreach (var number in numbers)
    {
        // Skip if 2
        if (number == 2)
            continue;

        // Stop iteration if 5
        if (number == 5)
            break;

        Console.Write(number + ", ");
    }

    // Prints: 1, 3, 4, 

[.NET Fiddle'da Canlı Demo](https://dotnetfiddle.net/dfSAbF)

Yineleme sırasının *yalnızca* diziler ve "Liste" gibi belirli koleksiyonlar için garanti edildiğine, ancak diğer birçok koleksiyon için **garanti edilmediğine dikkat edin.

----------

✝ "IEnumerable" tipik olarak numaralandırılabilir koleksiyonları belirtmek için kullanılırken, "foreach" yalnızca koleksiyonun "object GetEnumerator()" yöntemini genel olarak göstermesini gerektirir; bu, "bool MoveNext()" yöntemini ve " nesne Geçerli { get; }` özelliği.

[1]: https://www.wikiod.com/tr/docs/c%23/26/keywords/2858/break
[2]: https://www.wikiod.com/tr/docs/c%23/26/keywords/154/continue
[3]: https://msdn.microsoft.com/en-us/library/system.collections.ienumerable(v=vs.110).aspx

## dinamik
"Dynamic" anahtar sözcüğü, [dinamik olarak yazılan nesneler][1] ile birlikte kullanılır. "Dinamik" olarak bildirilen nesneler, derleme zamanı statik denetimlerinden önce gelir ve bunun yerine çalışma zamanında değerlendirilir.

    using System;
    using System.Dynamic;
    
    dynamic info = new ExpandoObject();
    info.Id = 123;
    info.Another = 456;
    
    Console.WriteLine(info.Another);
    // 456
    
    Console.WriteLine(info.DoesntExist);
    // Throws RuntimeBinderException

Aşağıdaki örnek, seri durumdan çıkarılmış bir JSON dosyasından verileri kolayca okumak için Newtonsoft'un Json.NET kitaplığıyla "dinamik"i kullanır.

    try
    {
        string json = @"{ x : 10, y : ""ho""}";
        dynamic deserializedJson = JsonConvert.DeserializeObject(json);
        int x = deserializedJson.x;
        string y = deserializedJson.y;
        // int z = deserializedJson.z; // throws RuntimeBinderException
    }
    catch (RuntimeBinderException e)
    {
        // This exception is thrown when a property
        // that wasn't assigned to a dynamic variable is used
    }

[1]: https://www.wikiod.com/tr/docs/c%23/762/dynamic-type#t=201607212330428041437

Dinamik anahtar kelimeyle ilişkili bazı sınırlamalar vardır. Bunlardan biri uzatma yöntemlerinin kullanılmasıdır. Aşağıdaki örnek, dize için bir uzantı yöntemi ekler: `SayHello`.

    static class StringExtensions
    {
        public static string SayHello(this string s) => $"Hello {s}!";
    }

İlk yaklaşım, onu her zamanki gibi çağırmak olacaktır (bir dizgede olduğu gibi):

    var person = "Person";
    Console.WriteLine(person.SayHello());

    dynamic manager = "Manager";
    Console.WriteLine(manager.SayHello()); // RuntimeBinderException

Derleme hatası yok, ancak çalışma zamanında bir "RuntimeBinderException" alıyorsunuz. Bunun için geçici çözüm, uzatma yöntemini statik sınıf aracılığıyla çağırmak olacaktır:

    var helloManager = StringExtensions.SayHello(manager);
    Console.WriteLine(helloManager);

## dene, yakala, sonunda fırlat
'dene', 'yakala', 'nihayet' ve 'atma', kodunuzdaki istisnaları işlemenize izin verir.

    var processor = new InputProcessor();

    // The code within the try block will be executed. If an exception occurs during execution of
    // this code, execution will pass to the catch block corresponding to the exception type.
    try 
    {
        processor.Process(input);
    }
    // If a FormatException is thrown during the try block, then this catch block
    // will be executed.
    catch (FormatException ex)
    {
        // Throw is a keyword that will manually throw an exception, triggering any catch block that is
        // waiting for that exception type. 
        throw new InvalidOperationException("Invalid input", ex);
    }
    // catch can be used to catch all or any specific exceptions. This catch block,
    // with no type specified, catches any exception that hasn't already been caught
    // in a prior catch block.
    catch
    {
        LogUnexpectedException(); 
        throw; // Re-throws the original exception.
    }
    // The finally block is executed after all try-catch blocks have been; either after the try has
    // succeeded in running all commands or after all exceptions have been caught. 
    finally
    {
        processor.Dispose();
    }

**Not:** 'return' anahtar sözcüğü, 'try' bloğunda kullanılabilir ve 'finally' bloğu yine de yürütülür (geri dönmeden hemen önce). Örneğin:

    try 
    {
        connection.Open();
        return connection.Get(query);
    } 
    finally 
    {
        connection.Close();
    }
 
'connection.Close()' ifadesi, 'connection.Get(query)' sonucu döndürülmeden önce yürütülür.

## ad alanı
"namespace" anahtar sözcüğü, bir kod tabanının nasıl düzenlendiğini anlamamıza yardımcı olan bir organizasyon yapısıdır. C#'daki ad alanları, fiziksel bir klasörde olmak yerine sanal alanlardır.

    namespace StackOverflow
    {
        namespace Documentation
        {
            namespace CSharp.Keywords
            {
                public class Program
                {
                    public static void Main()
                    {
                        Console.WriteLine(typeof(Program).Namespace);
                        //StackOverflow.Documentation.CSharp.Keywords
                    }
                }
            }
        }
    }

C#'daki ad alanları zincirleme sözdiziminde de yazılabilir. Aşağıdaki, yukarıdakine eşdeğerdir:

    namespace StackOverflow.Documentation.CSharp.Keywords
    {
        public class Program
        {
            public static void Main()
            {
                Console.WriteLine(typeof(Program).Namespace);
                //StackOverflow.Documentation.CSharp.Keywords
            }
        }
    }

## geçersiz
Ayrılmış "void" sözcüğü, "System.Void" türünde bir takma addır ve iki kullanımı vardır:

1. Dönüş değeri olmayan bir yöntem bildirin:


    public void DoSomething()
    {
        // Do some work, don't return any value to the caller.
    }

Dönüş türü void olan bir yöntemin gövdesinde yine de 'return' anahtar sözcüğü olabilir. Bu, yöntemin yürütülmesinden çıkmak ve akışı arayana döndürmek istediğinizde kullanışlıdır:

    public void DoSomething()
    {
        // Do some work...

        if (condition)
            return;

        // Do some more work if the condition evaluated to false.
    }

2. Güvenli olmayan bir bağlamda bilinmeyen bir türe işaretçi bildirin.

Güvenli olmayan bir bağlamda tür, işaretçi türü, değer türü veya başvuru türü olabilir. İşaretçi türü bildirimi genellikle "tür* tanımlayıcıdır", burada tür bilinen bir türdür - yani "int* myInt", ancak türün bilinmediği durumlarda "void* tanımlayıcı" da olabilir.

Bir geçersiz işaretçi türü bildirmenin [Microsoft tarafından önerilmez.][1] olduğunu unutmayın.


[1]: https://msdn.microsoft.com/en-us/library/y31yhkeb.aspx

## referans, çıkış
'ref' ve 'out' anahtar sözcükleri, bir argümanın değere göre değil referansa göre iletilmesine neden olur. Değer türleri için bu, değişkenin değerinin aranan tarafından değiştirilebileceği anlamına gelir.

    int x = 5;
    ChangeX(ref x);
    // The value of x could be different now

Referans türleri için, değişkendeki örnek sadece değiştirilemez ('başvuru' olmadan olduğu gibi), aynı zamanda tamamen değiştirilebilir:

    Address a = new Address();
    ChangeFieldInAddress(a);
    // a will be the same instance as before, even if it is modified
    CreateANewInstance(ref a);
    // a could be an entirely new instance now

'out' ve 'ref' anahtar kelimeleri arasındaki temel fark, 'ref' değişkenin arayan tarafından başlatılmasını gerektirirken, 'out' bu sorumluluğu aranan kişiye devreder.

Bir "out" parametresini kullanmak için, hem yöntem tanımı hem de çağrı yöntemi açıkça "out" anahtar sözcüğünü kullanmalıdır.

    int number = 1;
    Console.WriteLine("Before AddByRef: " + number); // number = 1
    AddOneByRef(ref number);
    Console.WriteLine("After AddByRef: " + number);  // number = 2
    SetByOut(out number);
    Console.WriteLine("After SetByOut: " + number);  // number = 34

    void AddOneByRef(ref int value)
    {
        value++;
    }
    
    void SetByOut(out int value)
    {
        value = 34;
    }

[<kbd>.NET Fiddle'da Canlı Demo</kbd>](https://dotnetfiddle.net/ma2ikc)
    
Aşağıdakiler *derlemez*, çünkü "out" parametrelerinin, yöntem dönmeden önce atanmış bir değeri olması gerekir (bunun yerine "ref" kullanılarak derlenir):

    void PrintByOut(out int value)
    {
        Console.WriteLine("Hello!");
    }

**Anahtar kelimeyi Genel Değiştirici olarak kullanmak**

'out' anahtar sözcüğü, genel arabirimler ve temsilciler tanımlanırken genel tür parametrelerinde de kullanılabilir. Bu durumda, "out" anahtar sözcüğü, tür parametresinin kovaryant olduğunu belirtir.

> Kovaryans, genel parametre tarafından belirtilenden daha fazla türetilmiş bir tür kullanmanıza olanak tanır. Bu, değişken arabirimleri uygulayan sınıfların örtük dönüştürülmesine ve temsilci türlerinin örtülü dönüştürülmesine izin verir. Referans türleri için kovaryans ve kontravaryans desteklenir, ancak değer türleri için desteklenmez. -MSDN

    //if we have an interface like this
    interface ICovariant<out R> { }
    
    //and two variables like
    ICovariant<Object> iobj = new Sample<Object>();
    ICovariant<String> istr = new Sample<String>();

    // then the following statement is valid
    // without the out keyword this would have thrown error
    iobj = istr; // implicit conversion occurs here
   

## temel
**`base`** anahtar sözcüğü, bir temel sınıftan üyelere erişmek için kullanılır. Genellikle sanal yöntemlerin temel uygulamalarını çağırmak veya hangi temel oluşturucunun çağrılması gerektiğini belirtmek için kullanılır.

**Bir kurucu seçme**

    public class Child : SomeBaseClass {
        public Child() : base("some string for the base class")
        {
        }
    }

    public class SomeBaseClass {
        public SomeBaseClass()
        {
            // new Child() will not call this constructor, as it does not have a parameter
        }
        public SomeBaseClass(string message)
        {
            // new Child() will use this base constructor because of the specified parameter in Child's constructor
            Console.WriteLine(message);
        }
    }

**Sanal yöntemin çağrı tabanı uygulaması**

    public override void SomeVirtualMethod() {
        // Do something, then call base implementation
        base.SomeVirtualMethod();
    }

Herhangi bir yöntemden bir temel uygulama çağırmak için base anahtar sözcüğünü kullanmak mümkündür. Bu, yöntem çağrısını doğrudan temel uygulamaya bağlar; bu, yeni alt sınıflar bir sanal yöntemi geçersiz kılsa bile, temel uygulamanın yine de çağrılacağı ve bunun dikkatli kullanılması gerektiği anlamına gelir.

    public class Parent
    {
        public virtual int VirtualMethod()
        {
            return 1;
        }
    }

    public class Child : Parent
    {
        public override int VirtualMethod() {
            return 11;
        }

        public int NormalMethod()
        {
            return base.VirtualMethod();
        }

        public void CallMethods()
        {
            Assert.AreEqual(11, VirtualMethod());

            Assert.AreEqual(1, NormalMethod());
            Assert.AreEqual(1, base.VirtualMethod());
        }
    }

    public class GrandChild : Child
    {
        public override int VirtualMethod()
        {
            return 21;
        }

        public void CallAgain()
        {
            Assert.AreEqual(21, VirtualMethod());
            Assert.AreEqual(11, base.VirtualMethod());

            // Notice that the call to NormalMethod below still returns the value
            // from the extreme base class even though the method has been overridden
            // in the child class.
            Assert.AreEqual(1, NormalMethod());
        }
    }



## parametre
"params", bir yöntem parametresinin değişken sayıda argüman almasına izin verir, yani bu parametre için sıfır, bir veya birden fazla argümana izin verilir.

    static int AddAll(params int[] numbers)
    {
        int total = 0;
        foreach (int number in numbers)
        {
            total += number;
        }
        
        return total;
    }

Bu yöntem artık tipik bir "int" argüman listesi veya bir dizi int ile çağrılabilir.

    AddAll(5, 10, 15, 20);                // 50
    AddAll(new int[] { 5, 10, 15, 20 });  // 50

'params' en fazla bir kez görünmelidir ve kullanılıyorsa, sonraki tür dizininkinden farklı olsa bile argüman listesinde **son** olmalıdır.

----

"params" anahtar sözcüğünü kullanırken işlevleri aşırı yüklerken dikkatli olun. C#, "params" ile aşırı yüklemeleri kullanmaya çalışmadan önce daha spesifik aşırı yüklemeleri eşleştirmeyi tercih eder. Örneğin, iki yönteminiz varsa:

    static double Add(params double[] numbers)
    {
        Console.WriteLine("Add with array of doubles");
        double total = 0.0;
        foreach (double number in numbers)
        {
            total += number;
        }
        
        return total;
    }

    static int Add(int a, int b)
    {
        Console.WriteLine("Add with 2 ints");
        return a + b;
    }

Ardından, "params" aşırı yüklemesini denemeden önce belirli 2 argüman aşırı yüklemesi öncelikli olacaktır.

    Add(2, 3);      //prints "Add with 2 ints"
    Add(2, 3.0);    //prints "Add with array of doubles" (doubles are not ints)
    Add(2, 3, 4);   //prints "Add with array of doubles" (no 3 argument overload)


## kayan nokta, çift, ondalık
# batmadan yüzmek #

"float", .NET veri türü "System.Single"ın diğer adıdır. IEEE 754 tek duyarlıklı kayan nokta sayılarının saklanmasına izin verir. Bu veri türü, oluşturduğunuzda her C# projesi tarafından dolaylı olarak başvurulan `mscorlib.dll` dosyasında bulunur.

Yaklaşık aralık: -3.4 × 10<sup>38</sup> - 3.4 × 10<sup>38</sup>

Ondalık hassasiyet: 6-9 anlamlı basamak

**Notasyon**:

    float f = 0.1259;
    var f1 = 0.7895f; // f is literal suffix to represent float values 

> "float" tipinin genellikle önemli sonuçlar doğurduğuna dikkat edilmelidir.
> yuvarlama hataları. Hassasiyetin önemli olduğu uygulamalarda, diğer
> veri türleri dikkate alınmalıdır.


----------
# çift #

"double", .NET veri türü "System.Double"ın diğer adıdır. Çift duyarlıklı 64 bit kayan noktalı bir sayıyı temsil eder. Bu veri türü, herhangi bir C# projesinde dolaylı olarak başvurulan "mscorlib.dll" dosyasında bulunur.

Aralık: ±5.0 × 10<sup>−324</sup> ila ±1.7 × 10<sup>308</sup>

Ondalık kesinlik: 15-16 anlamlı basamak

**Notasyon**:

    double distance = 200.34; // a double value
    double salary = 245; // an integer implicitly type-casted to double value
    var marks = 123.764D; // D is literal suffix to represent double values

----------
# ondalık #

"decimal", .NET veri türü "System.Decimal" için bir diğer addır. Bir anahtar sözcüğü temsil eder, 128 bitlik bir veri türünü belirtir. Kayan noktalı türlerle karşılaştırıldığında, ondalık türün daha hassas ve daha küçük bir aralığı vardır, bu da onu finansal ve parasal hesaplamalar için uygun hale getirir. Bu veri türü, herhangi bir C# projesinde dolaylı olarak başvurulan "mscorlib.dll" dosyasında bulunur.

Aralık: -7,9 × 10<sup>28</sup> - 7,9 × 10<sup>28</sup>

Ondalık hassasiyet: 28-29 anlamlı basamak

**Notasyon**:

    decimal payable = 152.25m; // a decimal value
    var marks = 754.24m; // m is literal suffix to represent decimal values

## karakter
Karakter, bir değişkenin içinde saklanan tek harftir. İki bayt bellek alanı alan yerleşik değer türüdür. Oluşturduğunuzda her C# projesi tarafından örtük olarak başvurulan 'mscorlib.dll' içinde bulunan 'System.Char' veri türünü temsil eder.

Bunu yapmanın birden fazla yolu vardır.
1) `karakter c = 'c';`
2) `karakter c = '\u0063'; //Unicode`
3) `char c = '\x0063'; //Hex`
4) `karakter c = (karakter)99;//İntegral`

Bir karakter dolaylı olarak "ushort, int, uint, long, ulong, float, double" veya "decimal"e dönüştürülebilir ve bu karakterin tamsayı değerini döndürür.

    ushort u = c;
99 vb. döndürür

Ancak, diğer türlerden char'a örtülü dönüşüm yoktur. Bunun yerine onları atmalısınız.
 

    ushort u = 99;
     char c = (char)u;



## Şebeke
Çoğu [yerleşik operatörler][OPERATÖRLER] (dönüştürme operatörleri dahil), "operatör" anahtar kelimesiyle birlikte "genel" ve "statik" değiştiriciler kullanılarak aşırı yüklenebilir.

Operatörler üç biçimde gelir: tekli operatörler, ikili operatörler ve dönüştürme operatörleri.

Birli ve ikili işleçler, içeren türle aynı türde en az bir parametre gerektirir ve bazıları tamamlayıcı bir eşleştirme işleci gerektirir.

Dönüştürme operatörleri, çevreleyen türe veya bu türden dönüştürmelidir.

    public struct Vector32
    {
        
        public Vector32(int x, int y)
        {
            X = x;
            Y = y;
        }
        
        public int X { get; }
        public int Y { get; }

        public static bool operator ==(Vector32 left, Vector32 right)
            => left.X == right.X && left.Y == right.Y;

        public static bool operator !=(Vector32 left, Vector32 right)
            => !(left == right);

        public static Vector32 operator +(Vector32 left, Vector32 right)
            => new Vector32(left.X + right.X, left.Y + right.Y);

        public static Vector32 operator +(Vector32 left, int right)
            => new Vector32(left.X + right, left.Y + right);

        public static Vector32 operator +(int left, Vector32 right)
            => right + left;

        public static Vector32 operator -(Vector32 left, Vector32 right)
            => new Vector32(left.X - right.X, left.Y - right.Y);

        public static Vector32 operator -(Vector32 left, int right)
            => new Vector32(left.X - right, left.Y - right);

        public static Vector32 operator -(int left, Vector32 right)
            => right - left;

        public static implicit operator Vector64(Vector32 vector)
            => new Vector64(vector.X, vector.Y);

        public override string ToString() => $"{{{X}, {Y}}}";

    }

    public struct Vector64
    {

        public Vector64(long x, long y)
        {
            X = x;
            Y = y;
        }

        public long X { get; }
        public long Y { get; }

        public override string ToString() => $"{{{X}, {Y}}}";

    }

**Örnek**

    var vector1 = new Vector32(15, 39);
    var vector2 = new Vector32(87, 64);
            
    Console.WriteLine(vector1 == vector2); // false
    Console.WriteLine(vector1 != vector2); // true
    Console.WriteLine(vector1 + vector2);  // {102, 103}
    Console.WriteLine(vector1 - vector2);  // {-72, -25}

[OPERATÖRLER]: https://msdn.microsoft.com/en-us/library/6a71f45d.aspx

## devam et
Kontrolü hemen çevreleyen döngü yapısının bir sonraki yinelemesine geçirin (for, foreach, do, while):

    for (var i = 0; i < 10; i++)
    {
        if (i < 5)
        {
            continue;
        }
        Console.WriteLine(i);
    }

Çıktı:

> 5
> 6
> 7
> 8
> 9

[<kbd>.NET Fiddle'da Canlı Demo</kbd>](https://dotnetfiddle.net/H2NB0V)

    var stuff = new [] {"a", "b", null, "c", "d"};

    foreach (var s in stuff)
    {
        if (s == null)
        {
            continue;
        }           
        Console.WriteLine(s);
    }

Çıktı:

> bir
> b
> c
> g

[.NET Fiddle'da Canlı Demo](https://dotnetfiddle.net/l1JPiI)

## süre
"while" operatörü, koşullu sorgu yanlış olana veya kod bir [`goto`](https://www.wikiod.com/tr/docs/c%23/26/keywords/193/ ile kesintiye uğrayana kadar) bir kod bloğu üzerinde yinelenir. git), [`return`](https://www.wikiod.com/tr/docs/c%23/26/keywords/4600/return), [`break`](https://www.wikiod.com/tr/docs/c% 23/26/keywords/2858/break) veya 'throw' ifadesi.

"while" anahtar sözcüğü için sözdizimi:

> while( *durum* )
> { *kod bloğu;* }

Örnek:

    int i = 0;
    while (i++ < 5)
    {
        Console.WriteLine("While is on loop number {0}.", i);
    }

Çıktı:

>"1 numaralı döngüdeyken." \
"2 numaralı döngüdeyken."\
"While, 3 numaralı döngüde."\
"While 4 numaralı döngüde."\
"While 5 numaralı döngüde."

[<kbd>.NET Fiddle'da Canlı Demo</kbd>](https://dotnetfiddle.net/KRQjV0)

Koşul, ekteki kod bloğunun yürütülmesinden **önce** kontrol edildiğinden, bir while döngüsü **Giriş Kontrollü**'dür. Bu, koşul yanlışsa while döngüsünün deyimlerini yürütmeyeceği anlamına gelir.

    bool a = false;
    
    while (a == true)
    {
        Console.WriteLine("This will never be printed.");
    }

Bir noktada false olmasını sağlamadan bir "while" koşulu vermek, sonsuz veya sonsuz bir döngüye neden olur. Mümkün olduğunca bundan kaçınılmalıdır, ancak buna ihtiyacınız olduğunda bazı istisnai durumlar olabilir.

Aşağıdaki gibi bir döngü oluşturabilirsiniz:

    while (true)
    {
    //...
    }

C# derleyicisinin aşağıdaki gibi döngüleri dönüştüreceğini unutmayın.

    while (true)
    {
    // ...
    }

veya

    for(;;)
    {
    // ...
    }

içine

    {
    :label
    // ...
    goto label;
    }

Bir while döngüsünün, ne kadar karmaşık olursa olsun, bir boole değeri (bool) olarak değerlendirdiği (veya döndürdüğü) sürece herhangi bir koşulu olabileceğini unutmayın. Ayrıca, bir boole değeri döndüren bir işlev içerebilir (böyle bir işlev, 'a==x' gibi bir ifadeyle aynı türü değerlendirir). Örneğin,

    while (AgriculturalService.MoreCornToPick(myFarm.GetAddress()))
    {
        myFarm.PickCorn();
    }

## dönüş
> MSDN: return ifadesi, içinde bulunulan yöntemin yürütülmesini sonlandırır.
> görünür ve kontrolü çağıran yönteme döndürür. Ayrıca
> isteğe bağlı bir değer döndür. Yöntem bir void türü ise, dönüş
> ifadesi atlanabilir.

    public int Sum(int valueA, int valueB)
    {
        return valueA + valueB;
    }

    
    public void Terminate(bool terminateEarly)
    {
        if (terminateEarly) return; // method returns to caller if true was passed in
        else Console.WriteLine("Not early"); // prints only if terminateEarly was false
    }

## hükümsüz
Başvuru türündeki bir değişken, bir örneğe geçerli bir başvuru ya da boş bir başvuru tutabilir. Boş başvuru, başvuru türü değişkenlerinin yanı sıra null yapılabilir değer türlerinin varsayılan değeridir.

"null", boş bir referansı temsil eden anahtar kelimedir.

Bir ifade olarak, yukarıda belirtilen türlerdeki değişkenlere boş referans atamak için kullanılabilir:

    object a = null;
    string b = null;
    int? c = null;
    List<int> d  = null;

Null yapılamayan değer türlerine boş bir başvuru atanamaz. Aşağıdaki atamaların tümü geçersizdir:

    int a = null; 
    float b = null;
    decimal c = null;

Boş başvuru, aşağıdakiler gibi çeşitli türlerin geçerli örnekleriyle * karıştırılmamalıdır:

- boş bir liste (`new List<int>()`)
- boş bir dize (`""`)
- sıfır sayısı ("0", "0f", "0m")
- boş karakter ( `'\0'` )

Bazen, bir şeyin boş veya boş/varsayılan bir nesne olup olmadığını kontrol etmek anlamlıdır. Bunu kontrol etmek için System.String.IsNullOrEmpty(String) yöntemi kullanılabilir veya kendi eşdeğer yönteminizi uygulayabilirsiniz.

    private void GreetUser(string userName)
    {
        if (String.IsNullOrEmpty(userName))
        {
            //The method that called us either sent in an empty string, or they sent us a null reference. Either way, we need to report the problem.
            throw new InvalidOperationException("userName may not be null or empty.");
        }
        else
        {
            //userName is acceptable.
            Console.WriteLine("Hello, " + userName + "!");
        }
    }

## sicim
"dize", metnin (karakter dizilerinin) depolanmasına izin veren .NET veri türü "System.String"in diğer adıdır.

gösterim:

    string a = "Hello";
    var b = "world";
    var f = new string(new []{ 'h', 'i', '!' }); // hi!

Dizedeki her karakter UTF-16'da kodlanmıştır; bu, her karakterin en az 2 bayt depolama alanı gerektireceği anlamına gelir.

## uint
Bir **işaretsiz tamsayı** veya **uint**, yalnızca pozitif tamsayıları tutabilen sayısal bir veri türüdür. Adından da anlaşılacağı gibi, işaretsiz bir 32-bit tamsayıyı temsil eder. **uint** anahtar sözcüğünün kendisi, "System.UInt32" Ortak Tür Sistem türü için bir takma addır. Bu veri türü, oluşturduğunuzda her C# projesi tarafından örtük olarak başvurulan "mscorlib.dll" dosyasında bulunur. Dört bayt bellek alanı kaplar.

İşaretsiz tamsayılar 0 ile 4,294,967,295 arasında herhangi bir değer alabilir.


*İşaretsiz tam sayıların nasıl ve şimdi bildirilmeyeceğine dair örnekler*

    uint i = 425697; // Valid expression, explicitly stated to compiler
    var i1 = 789247U; // Valid expression, suffix allows compiler to determine datatype
    uint x = 3.0; // Error, there is no implicit conversion

----------

**Lütfen unutmayın:** [Microsoft][1]'e göre, **uint** veri türü CLS uyumlu olmadığından, mümkün olan her yerde **[int][2]** veri türünün kullanılması önerilir.


[1]: https://msdn.microsoft.com/en-us/library/x0sksh43.aspx
[2]: https://www.wikiod.com/tr/docs/c%23/26/keywords#t=201608192209189084166

## kullanarak
Anahtar kelime kullanımının iki türü vardır, "kullanma ifadesi" ve "yönergeyi kullanma":

1. **ifade kullanarak**:

    The `using` keyword ensures that objects that implement the `IDisposable` interface are properly disposed after usage. There is a separate topic for the [using statement][1]
    
2. **yönergeyi kullanma**

'using' yönergesinin üç kullanımı vardır, kullanım yönergesi için [msdn sayfasına[2] bakın. [Kullanım yönergesi][3] için ayrı bir konu vardır.


[1]: https://www.wikiod.com/tr/docs/c%23/38/using-statement#t=201607311905386691069
[2]: https://msdn.microsoft.com/en-us/library/sf0df423.aspx
[3]: https://www.wikiod.com/tr/docs/c%23/52/using-directive#t=201607311908368095223

## statik
'static' değiştiricisi, erişilmesi için somutlaştırılması gerekmeyen, bunun yerine yalnızca adı, yani 'DateTime.Now' aracılığıyla erişilen statik bir üyeyi bildirmek için kullanılır.

'static' sınıflar, alanlar, yöntemler, özellikler, operatörler, olaylar ve kurucularla birlikte kullanılabilir.

Bir sınıfın örneği, sınıfın tüm örnek alanlarının ayrı bir kopyasını içerirken, her statik alanın yalnızca bir kopyası vardır.

    class A
    {
        static public int count = 0;

        public A()
        {
            count++;
        }
    }

    class Program
    {
        static void Main(string[] args)
        {
            A a = new A();
            A b = new A();
            A c = new A();

            Console.WriteLine(A.count); // 3 
        }
    }

"count", "A" sınıfının toplam örnek sayısına eşittir.

Statik değiştirici, bir sınıf için statik bir kurucu bildirmek, statik verileri başlatmak veya yalnızca bir kez çağrılması gereken kodu çalıştırmak için de kullanılabilir. Statik oluşturucular, sınıfa ilk kez başvurulmadan önce çağrılır.

    class A
    {
        static public DateTime InitializationTime;

        // Static constructor
        static A()
        {
            InitializationTime = DateTime.Now;
            // Guaranteed to only run once
            Console.WriteLine(InitializationTime.ToString());
        }
    }

Bir "static class", "static" anahtar sözcüğüyle işaretlenir ve parametreler üzerinde çalışan, ancak bir örneğe bağlanmayı gerektirmeyen bir dizi yöntem için yararlı bir kapsayıcı olarak kullanılabilir. Sınıfın "statik" doğası nedeniyle, somutlaştırılamaz, ancak bir "statik kurucu" içerebilir. Bir "statik sınıfın" bazı özellikleri şunları içerir:

- Miras alınamaz
- "Nesne" dışında hiçbir şeyden miras alınamaz
- Statik bir kurucu içerebilir ancak bir örnek kurucu içeremez
- Yalnızca statik üyeler içerebilir
- Mühürlü

Derleyici aynı zamanda arkadaş canlısıdır ve sınıf içinde herhangi bir örnek üye olup olmadığını geliştiriciye bildirir. Bir örnek, ABD ve Kanada metrikleri arasında dönüştürme yapan statik bir sınıf olabilir:

    static class ConversionHelper {
        private static double oneGallonPerLitreRate = 0.264172;

        public static double litreToGallonConversion(int litres) {
            return litres * oneGallonPerLitreRate;
        }
    }

Sınıflar statik olarak bildirildiğinde:

    public static class Functions
    {
      public static int Double(int value)
      {
        return value + value;
      }
    }

sınıf içindeki tüm işlevler, özellikler veya üyelerin de statik olarak bildirilmesi gerekir. Sınıfın hiçbir örneği oluşturulamaz.
Özünde statik bir sınıf, mantıksal olarak bir arada gruplandırılmış işlev demetleri oluşturmanıza olanak tanır.

C#6 'static', statik üyeleri ve yöntemleri içe aktarmak için 'use' ile birlikte kullanılabilir. Daha sonra sınıf adı olmadan kullanılabilirler.

'Statik kullanmadan' eski yol:
  
    using System;

    public class ConsoleApplication
    {
        public static void Main()
        {
             Console.WriteLine("Hello World!"); //Writeline is method belonging to static class Console
        }

    }
"Statik kullanma" örneği

    using static System.Console;

    public class ConsoleApplication
    {
        public static void Main()
        {
             WriteLine("Hello World!"); //Writeline is method belonging to static class Console
        }

    }

**Dezavantajlar**
---------

Statik sınıflar inanılmaz derecede faydalı olsa da, kendi uyarılarıyla gelirler:

• Statik sınıf çağrıldığında, sınıf belleğe yüklenir ve statik sınıfı barındıran AppDomain kaldırılana kadar çöp toplayıcıdan çalıştırılamaz.

• Statik bir sınıf, bir arabirim uygulayamaz.

## int
"int", imzalı 32 bit tamsayılar için bir veri türü olan "System.Int32" için bir takma addır. Bu veri türü, oluşturduğunuzda her C# projesi tarafından dolaylı olarak başvurulan `mscorlib.dll` içinde bulunabilir.

Aralık: -2.147.483.648 ila 2.147.483.647

    int int1 = -10007;
    var int2 = 2132012521;     

## kafa
İşaretsiz 64 bit tam sayılar için kullanılan anahtar sözcük. Oluşturduğunuzda her C# projesi tarafından dolaylı olarak başvurulan 'mscorlib.dll' içinde bulunan 'System.UInt64' veri türünü temsil eder.

Aralık: 0 ila 18,446,744,073,709,551,615

    ulong veryLargeInt = 18446744073609451315;
    var anotherVeryLargeInt = 15446744063609451315UL;

## kilit
"kilit", aynı işlem içinde yalnızca bir iş parçacığı tarafından erişilebilmesi için bir kod bloğu için iş parçacığı güvenliği sağlar. Örnek:

    private static object _lockObj = new object();
    static void Main(string[] args)
    {
        Task.Run(() => TaskWork());
        Task.Run(() => TaskWork());
        Task.Run(() => TaskWork());
    
        Console.ReadKey();
    }
    
    private static void TaskWork()
    {
        lock(_lockObj)
        {
            Console.WriteLine("Entered");
    
            Task.Delay(3000);
            Console.WriteLine("Done Delaying");
    
            // Access shared resources safely
    
            Console.WriteLine("Leaving");
        }   
    }
    
    Output:

    Entered
    Done Delaying
    Leaving
    Entered
    Done Delaying
    Leaving
    Entered
    Done Delaying
    Leaving

**Kullanım durumları:**

Aynı anda birden fazla iş parçacığı tarafından yürütülürse yan etkiler üretebilecek bir kod bloğunuz olduğunda. Bir **paylaşılan senkronizasyon nesnesi** (örnekte `_objLock`) ile birlikte lock anahtar sözcüğü bunu önlemek için kullanılabilir.

"_objLock" öğesinin "boş" olamayacağını ve kodu yürüten birden çok iş parçacığının aynı nesne örneğini kullanması gerektiğini unutmayın ("statik" bir alan yaparak veya her iki iş parçacığı için aynı sınıf örneğini kullanarak)

Derleyici tarafında, kilit anahtar sözcüğü, 'Monitor.Enter(_lockObj);' ve 'Monitor.Exit(_lockObj);' ile değiştirilen sözdizimsel bir şekerdir. Dolayısıyla, bu iki yöntemle kod bloğunu çevreleyerek kilidi değiştirirseniz, aynı sonuçları alırsınız. Gerçek kodu [C#'ta Sözdizimsel şeker - kilit örneği][1] içinde görebilirsiniz.


[1]: https://www.wikiod.com/tr/docs/c%23/2994/syntactic-sugar-in-c-sharp/10166/lock#t=20160723121800624366

## dahili
[`internal`][1] anahtar sözcüğü, türler ve tür üyeleri için bir erişim değiştiricisidir. Dahili türlere veya üyelere **yalnızca aynı derlemedeki dosyalardan erişilebilir**

*kullanım:*

    public class BaseClass 
    {
        // Only accessible within the same assembly
        internal static int x = 0;
    }


Farklı erişim değiştiricileri arasındaki fark [burada][2] açıklanmıştır

***Erişim değiştiricileri***

> **kamu**

> > Türe veya üyeye, aynı derlemedeki veya ona başvuran başka bir derlemedeki herhangi bir kodla erişilebilir.

> **özel**

> > Türe veya üyeye yalnızca aynı sınıf veya yapıdaki kodla erişilebilir.

> **korumalı**

> > Türe veya üyeye yalnızca aynı sınıf veya yapıdaki veya türetilmiş bir sınıftaki kodla erişilebilir.

> **dahili**

>> Türe veya üyeye, aynı derlemedeki herhangi bir kodla erişilebilir, ancak başka bir derlemeden erişilemez.

> **korumalı dahili**

> > Türe veya üyeye, aynı derlemedeki herhangi bir kod veya başka bir derlemedeki herhangi bir türetilmiş sınıf tarafından erişilebilir.

**erişim değiştiricisi yok** ayarlandığında, varsayılan bir erişim değiştiricisi kullanılır. Bu nedenle, ayarlanmamış olsa bile her zaman bir tür erişim değiştirici vardır.


[1]: https://msdn.microsoft.com/en-us/library/7c5ka91b.aspx
[2]: http://stackoverflow.com/a/614844/266562

## nerede
'where' C#'da iki amaca hizmet edebilir: genel bir bağımsız değişkende tür kısıtlama ve LINQ sorgularını filtreleme.


Genel bir sınıfta, düşünelim

    public class Cup<T>
    {
        // ...
    }

T, bir tür parametresi olarak adlandırılır. Sınıf tanımı, T için sağlanabilecek gerçek türler üzerinde kısıtlamalar getirebilir.

Aşağıdaki kısıtlama türleri uygulanabilir:

* değer türü
* referans türü
* varsayılan kurucu
* miras ve uygulama

**değer türü**

Bu durumda sadece "struct"lar (bu "int", "boolean" vb. gibi "ilkel" veri türlerini içerir) sağlanabilir.

    public class Cup<T> where T : struct
    {
        // ...
    }

**referans türü**

Bu durumda sadece sınıf türleri sağlanabilir

    public class Cup<T> where T : class
    {
        // ...
    }

**karma değer/referans türü**

Bazen tür argümanlarını bir veritabanında mevcut olanlarla sınırlamak istenir ve bunlar genellikle değer türleri ve dizgileriyle eşlenir. Tüm tür kısıtlamalarının karşılanması gerektiğinden, 'where T : struct veya string' belirtmek mümkün değildir (bu geçerli bir sözdizimi değildir). Geçici bir çözüm, tür bağımsız değişkenlerini yerleşik olarak "... Boolean, SByte, Byte, Int16, UInt16, Int32, UInt32, Int64, UInt64, Single, Double, Decimal, DateTime, Char ve String." Diğer nesnelerin IConvertible'ı uygulaması mümkündür, ancak bu pratikte nadirdir.

    public class Cup<T> where T : IConvertible
    {
        // ...
    }

**varsayılan kurucu**

Yalnızca varsayılan kurucu içeren türlere izin verilecektir. Bu, varsayılan (parametresiz) bir kurucu içeren değer türlerini ve sınıfları içerir.


    public class Cup<T> where T : new
    {
        // ...
    }

**miras ve uygulama**

Yalnızca belirli bir temel sınıftan miras alan veya belirli bir arabirimi uygulayan türler sağlanabilir.


    public class Cup<T> where T : Beverage
    {
        // ...
    }


    public class Cup<T> where T : IBeer
    {
        // ...
    }


Kısıtlama, başka bir tür parametresine bile başvurabilir:

    public class Cup<T, U> where U : T
    {
        // ...
    }

Bir tür bağımsız değişkeni için birden çok kısıtlama belirtilebilir:

    public class Cup<T> where T : class, new()
    {
        // ...
    }

Önceki örnekler, bir sınıf tanımındaki genel kısıtlamaları gösterir, ancak kısıtlamalar, bir tür argümanının sağlandığı her yerde kullanılabilir: sınıflar, yapılar, arayüzler, yöntemler, vb.
---

'where' ayrıca bir LINQ yan tümcesi olabilir. Bu durumda SQL'deki 'WHERE' ile benzerdir:

    int[] nums = { 5, 2, 1, 3, 9, 8, 6, 7, 2, 0 };

    var query =
        from num in nums 
        where num < 5
        select num;

        foreach (var n in query)
        {
            Console.Write(n + " ");
        }
        // prints 2 1 3 2 0


[1]: https://msdn.microsoft.com/en-us/library/system.iconvertible(v=vs.110).aspx

## dış
"extern" anahtar sözcüğü, harici olarak uygulanan yöntemleri bildirmek için kullanılır. Bu, Interop hizmetlerini kullanarak yönetilmeyen koda çağrı yapmak için DllImport özniteliği ile birlikte kullanılabilir. ki bu durumda 'statik' değiştirici ile gelecek

Örneğin:

    using System.Runtime.InteropServices;
    public class MyClass
    {
        [DllImport("User32.dll")]
        private static extern int SetForegroundWindow(IntPtr point);
    
        public void ActivateProcessWindow(Process p)
        {
            SetForegroundWindow(p.MainWindowHandle);
        }
    }

Bu, User32.dll kitaplığından içe aktarılan SetForegroundWindow yöntemini kullanır.

Bu aynı zamanda harici bir montaj diğer adı tanımlamak için de kullanılabilir. bu, aynı bileşenlerin farklı sürümlerine tek bir montajdan başvurmamızı sağlar.

Aynı tam nitelikli tür adlarına sahip iki derlemeye başvurmak için, komut isteminde aşağıdaki gibi bir diğer ad belirtilmelidir:

    /r:GridV1=grid.dll
    /r:GridV2=grid20.dll

Bu, GridV1 ve GridV2 harici takma adlarını oluşturur. Bu takma adları bir program içinden kullanmak için, extern anahtar sözcüğünü kullanarak bunlara başvurun. Örneğin:

    extern alias GridV1;
    extern alias GridV2;


## ne zaman
'When', **C# 6**'da eklenen bir anahtar kelimedir ve istisna filtrelemesi için kullanılır.

'When' anahtar sözcüğü kullanılmadan önce, her bir istisna türü için bir catch yan tümceniz olabilirdi; Anahtar kelimenin eklenmesiyle artık daha hassas bir kontrol mümkün.

Bir "ne zaman" ifadesi bir "catch" dalına eklenir ve yalnızca "ne zaman" koşulu "true" ise, "catch" yan tümcesi yürütülür. Aynı istisna sınıfı türleri ve farklı "ne zaman" koşulları ile birden fazla "catch" tümcesine sahip olmak mümkündür.



    private void CatchException(Action action)
    {
        try
        {
            action.Invoke();
        }
        
        // exception filter
        catch (Exception ex) when (ex.Message.Contains("when"))
        {
            Console.WriteLine("Caught an exception with when");
        }
    
        catch (Exception ex)
        {
            Console.WriteLine("Caught an exception without when");
        }
    }

    private void Method1() { throw new Exception("message for exception with when"); }
    private void Method2() { throw new Exception("message for general exception"); }
    
    
    CatchException(Method1);
    CatchException(Method2);

## if, if...else, if... else if
----------


Programın akışını kontrol etmek için 'if' ifadesi kullanılır. Bir "if" ifadesi, "Boolean" ifadesinin değerine dayalı olarak hangi ifadenin çalıştırılacağını tanımlar.

Tek bir ifade için "parantezler"{} isteğe bağlıdır ancak önerilir.

    int a = 4;
    if(a % 2 == 0) 
    {
         Console.WriteLine("a contains an even number");
    }
    // output: "a contains an even number"


----------


'if', koşulun yanlış olarak değerlendirilmesi durumunda yürütülecek bir 'else' yan tümcesine de sahip olabilir:

    int a = 5;
    if(a % 2 == 0) 
    {
         Console.WriteLine("a contains an even number");
    }
    else
    {
         Console.WriteLine("a contains an odd number");
    }
    // output: "a contains an odd number"


----------


'if'...'else if' yapısı, birden çok koşul belirtmenize izin verir:

    int a = 9;
    if(a % 2 == 0) 
    {
         Console.WriteLine("a contains an even number");
    }
    else if(a % 3 == 0) 
    {
         Console.WriteLine("a contains an odd number that is a multiple of 3"); 
    }
    else
    {
         Console.WriteLine("a contains an odd number");
    }
    // output: "a contains an odd number that is a multiple of 3"

*Önemli*, yukarıdaki örnekte bir koşul karşılanırsa, kontrol diğer testleri atlar ve söz konusu if else yapısının sonuna atlar. Bu nedenle, if kullanıyorsanız testlerin *sıralaması* önemlidir. başka eğer inşa
----------

C# Boolean ifadeleri [kısa devre değerlendirmesi][1] kullanır. Bu, değerlendirme koşullarının yan etkilerinin olabileceği durumlarda önemlidir:

    if (someBooleanMethodWithSideEffects() && someOtherBooleanMethodWithSideEffects()) {
      //...
    }
'someOtherBooleanMethodWithSideEffects'in gerçekten çalışacağının garantisi yoktur.

Daha önceki koşulların sonraki koşulları değerlendirmenin "güvenli" olmasını sağladığı durumlarda da önemlidir. Örneğin:

    if (someCollection != null && someCollection.Count > 0) {
       // ..
    }
Bu durumda sıra çok önemlidir çünkü sırayı tersine çevirirsek:

    if (someCollection.Count > 0 && someCollection != null) {
"someCollection" "null" ise bir "NullReferenceException" atar.

[1]: https://en.wikipedia.org/wiki/Short-circuit_evaluation

## yapı
Bir "yapı" türü, genellikle bir dikdörtgenin koordinatları veya bir envanterdeki bir öğenin özellikleri gibi küçük ilgili değişken gruplarını kapsüllemek için kullanılan bir değer türüdür.

> [Sınıflar][1] referans türleridir, yapılar değer türleridir.

    using static System.Console;
    
    namespace ConsoleApplication1
    {
        struct Point
        {
            public int X;
            public int Y;
    
            public override string ToString()
            {
                return $"X = {X}, Y = {Y}";
            }
    
            public void Display(string name)
            {
                WriteLine(name + ": " + ToString());
            }
        }
    
        class Program
        {
            static void Main()
            {
                var point1 = new Point {X = 10, Y = 20};
                // it's not a reference but value type
                var point2 = point1;
                point2.X = 777;
                point2.Y = 888;
                point1.Display(nameof(point1)); // point1: X = 10, Y = 20
                point2.Display(nameof(point2)); // point2: X = 777, Y = 888
    
                ReadKey();
            }
        }
    }

    
----------
Yapılar ayrıca yapıcılar, sabitler, alanlar, yöntemler, özellikler, dizin oluşturucular, işleçler, olaylar ve iç içe türler içerebilir, ancak bu tür birkaç üye gerekliyse bunun yerine türünüzü bir sınıf yapmayı düşünmelisiniz.


----------


**Yapının ne zaman ve sınıfın ne zaman kullanılacağına ilişkin MS'den bazı [öneriler][2]:**

*DÜŞÜNMEK*

türün örnekleri küçük ve genellikle kısa ömürlüyse veya genellikle diğer nesnelere gömülüyse, sınıf yerine bir yapı tanımlamak.

*KAÇINMAK*

tür aşağıdaki özelliklerin tümüne sahip olmadığı sürece bir yapı tanımlama:
 

- İlkel türlere benzer şekilde mantıksal olarak tek bir değeri temsil eder
(int, çift vb.)
- 16 baytın altında bir örnek boyutuna sahiptir.
- Değişmez.
- Sık sık kutulanması gerekmeyecek.


[1]: http://stackoverflow.com/a/3924092/266562
[2]: https://msdn.microsoft.com/en-us/library/ms229017.aspx

## değiştirmek
'switch' ifadesi, bir aday listesinden yürütülecek bir geçiş bölümü seçen bir kontrol ifadesidir. Bir switch ifadesi, bir veya daha fazla switch bölümü içerir. Her geçiş bölümü, bir veya daha fazla "durum" etiketi ve ardından bir veya daha fazla ifade içerir. Durum etiketi eşleşen bir değer içermiyorsa, kontrol varsa 'varsayılan' bölümüne aktarılır. Açıkça söylemek gerekirse, vaka düşüşü C#'da desteklenmez. Ancak, 1 veya daha fazla "durum" etiketi boşsa, yürütme, kodu içeren bir sonraki "vaka" bloğunun kodunu takip edecektir. Bu, aynı uygulamaya sahip birden fazla "vaka" etiketinin gruplandırılmasına izin verir. Aşağıdaki örnekte, "ay" 12'ye eşitse, "vaka" etiketleri "12", "1" ve "2" gruplandığından, "durum 2"deki kod yürütülecektir. Eğer bir "case" bloğu boş değilse, bir sonraki "case" etiketinden önce bir "break" bulunmalıdır, aksi takdirde derleyici bir hata işaretler.

    int month = DateTime.Now.Month; // this is expected to be 1-12 for Jan-Dec

    switch (month)
    {
        case 12: 
        case 1: 
        case 2:
            Console.WriteLine("Winter");
            break;
        case 3: 
        case 4: 
        case 5:
            Console.WriteLine("Spring");
            break;
        case 6: 
        case 7: 
        case 8:
            Console.WriteLine("Summer");
            break;
        case 9:     
        case 10: 
        case 11:
            Console.WriteLine("Autumn");
            break;
        default:
            Console.WriteLine("Incorrect month index");
            break;
    }

Bir "vaka" yalnızca *derleme zamanında* bilinen bir değerle etiketlenebilir (ör. "1", ""str"', "Enum.A"), bu nedenle bir "değişken" geçerli bir "vaka" etiketi değildir , ancak bir "const" veya "Enum" değeri (herhangi bir değişmez değerin yanı sıra).

## güvensiz
'güvensiz' anahtar sözcüğü, tür veya yöntem bildirimlerinde veya bir satır içi blok bildirmek için kullanılabilir.

Bu anahtar sözcüğün amacı, söz konusu blok için C#'ın *güvenli olmayan alt kümesinin* kullanılmasını sağlamaktır. Güvenli olmayan alt küme, işaretçiler, yığın ayırma, C benzeri diziler vb. gibi özellikleri içerir.

Güvenli olmayan kod doğrulanabilir değildir ve bu nedenle kullanımı önerilmez. Güvenli olmayan kodun derlenmesi, bir anahtarın C# derleyicisine geçirilmesini gerektirir. Ayrıca, CLR, çalışan derlemenin tam güvene sahip olmasını gerektirir.

Bu sınırlamalara rağmen, güvenli olmayan kodun bazı işlemleri daha performanslı (örneğin dizi indeksleme) veya daha kolay (örneğin bazı yönetilmeyen kitaplıklarla birlikte çalışma) yapmada geçerli kullanımları vardır.

Çok basit bir örnek olarak

    // compile with /unsafe
    class UnsafeTest
    {
       unsafe static void SquarePtrParam(int* p)
       {
          *p *= *p; // the '*' dereferences the pointer.
          //Since we passed in "the address of i", this becomes "i *= i"
       }
    
       unsafe static void Main()
       {
          int i = 5;
          // Unsafe method: uses address-of operator (&):
          SquarePtrParam(&i); // "&i" means "the address of i". The behavior is similar to "ref i"
          Console.WriteLine(i); // Output: 25
       }
    }

İşaretçilerle çalışırken, bellek konumlarının değerlerini adlarıyla adreslemek yerine doğrudan değiştirebiliriz. Çöp toplayıcı bir şeyleri hareket ettirirken olası bellek bozulmasını önlemek için bunun genellikle [fixed][1] anahtar sözcüğünün kullanılmasını gerektirdiğini unutmayın (aksi halde [hata CS0212][2] alabilirsiniz). "Sabitlenmiş" bir değişkene yazılamadığından, genellikle ilkiyle aynı yeri işaret etmeye başlayan ikinci bir işaretçiye sahip olmamız gerekir.

    void Main()
    {
        int[] intArray = new int[] { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10};

        UnsafeSquareArray(intArray);
        foreach(int i in intArray)
            Console.WriteLine(i);
    }
    
    unsafe static void UnsafeSquareArray(int[] pArr)
    {
        int len = pArr.Length;

        //in C or C++, we could say
        // int* a = &(pArr[0])
        // however, C# requires you to "fix" the variable first 
        fixed(int* fixedPointer = &(pArr[0]))
        {
            //Declare a new int pointer because "fixedPointer" cannot be written to.
            // "p" points to the same address space, but we can modify it
            int* p = fixedPointer;

            for (int i = 0; i < len; i++)
            {
                *p *= *p; //square the value, just like we did in SquarePtrParam, above
                p++;      //move the pointer to the next memory space.
                          // NOTE that the pointer will move 4 bytes since "p" is an
                          // int pointer and an int takes 4 bytes

                //the above 2 lines could be written as one, like this:
                // "*p *= *p++;"
            }
        }
    }

Çıktı:

    1
    4
    9
    16
    25
    36
    49
    64
    81
    100


'güvensiz' ayrıca, C çalışma zamanı kitaplığındaki _alloca gibi yığında bellek ayıracak olan [stackalloc][3] kullanımına da izin verir. Yukarıdaki örneği 'stackalloc'u aşağıdaki gibi kullanacak şekilde değiştirebiliriz:


    unsafe void Main()
    {
        const int len=10;
        int* seedArray = stackalloc int[len];
        
        //We can no longer use the initializer "{ 1, 2, 3, 4, 5, 6, 7, 8, 9, 10}" as before.
        // We have at least 2 options to populate the array. The end result of either
        // option will be the same (doing both will also be the same here).

        //FIRST OPTION:
        int* p = seedArray; // we don't want to lose where the array starts, so we
                            // create a shadow copy of the pointer
        for(int i=1; i<=len; i++)
            *p++ = i;
        //end of first option

        //SECOND OPTION:
        for(int i=0; i<len; i++)
            seedArray[i] = i+1;
        //end of second option

        UnsafeSquareArray(seedArray, len);
        for(int i=0; i< len; i++)
            Console.WriteLine(seedArray[i]);
    }
    
    //Now that we are dealing directly in pointers, we don't need to mess around with
    // "fixed", which dramatically simplifies the code
    unsafe static void UnsafeSquareArray(int* p, int len)
    {
        for (int i = 0; i < len; i++)
            *p *= *p++;
    }

(Çıkış yukarıdaki ile aynıdır)


[1]: https://www.wikiod.com/tr/docs/c%23/26/keywords/59/fixed#t=20160802171014149858
[2]: https://msdn.microsoft.com/en-us/library/29ak9b70(v=vs.140).aspx
[3]: https://www.wikiod.com/tr/docs/c%23/26/keywords/57/stackalloc#t=20160802171014149858

## doğru yanlış
"true" ve "false" anahtar sözcüklerinin iki kullanımı vardır:

1. Gerçek Boole değerleri olarak


    var myTrueBool = true;
    var myFalseBool = false;

2. Aşırı yüklenebilen operatörler olarak


    public static bool operator true(MyClass x)
    {
        return x.value >= 0;
    }

    public static bool operator false(MyClass x)
    {
        return x.value < 0;
    }

Yanlış operatörün aşırı yüklenmesi, C# 2.0'dan önce, 'Nullable' türlerin tanıtılmasından önce kullanışlıydı.
"true" operatörünü aşırı yükleyen bir tür, "false" operatörünü de aşırı yüklemelidir.

##
Kullanıcı türü bildirmiş gibi kesin olarak yazılan, örtük olarak yazılan bir yerel değişken. Diğer değişken bildirimlerinden farklı olarak, derleyici, kendisine atanan değere göre bunun temsil ettiği değişkenin türünü belirler.

    var i = 10; // implicitly typed, the compiler must determine what type of variable this is
    int i = 10; // explicitly typed, the type of variable is explicitly stated to the compiler

    // Note that these both represent the same type of variable (int) with the same value (10).

Diğer değişken türlerinden farklı olarak, bu anahtar kelimeyle değişken tanımları, bildirildiğinde başlatılmalıdır. Bunun nedeni, örtük olarak yazılan bir değişkeni temsil eden **var** anahtar kelimesidir.

    var i;
    i = 10;

    // This code will not run as it is not initialized upon declaration.

**var** anahtar sözcüğü, anında yeni veri türleri oluşturmak için de kullanılabilir. Bu yeni veri türleri *anonim türler* olarak bilinir. Bir kullanıcının önce herhangi bir nesne türünü açıkça bildirmek zorunda kalmadan bir dizi özellik tanımlamasına izin verdikleri için oldukça kullanışlıdırlar.

*Sade anonim tip*

    var a = new { number = 1, text = "hi" };

* Anonim bir tür döndüren LINQ sorgusu*

    public class Dog
    {
        public string Name { get; set; }
        public int Age { get; set; }
    }

    public class DogWithBreed
    {
        public Dog Dog { get; set; }
        public string BreedName  { get; set; }
    }

    public void GetDogsWithBreedNames()
    {
        var db = new DogDataContext(ConnectString);
        var result = from d in db.Dogs
                 join b in db.Breeds on d.BreedId equals b.BreedId
                 select new 
                        {
                            DogName = d.Name,
                            BreedName = b.BreedName
                        };

        DoStuff(result);
    }

foreach deyiminde var anahtar sözcüğünü kullanabilirsiniz.

    public bool hasItemInList(List<String> list, string stringToSearch)
    {
        foreach(var item in list)
        {
            if( ( (string)item ).equals(stringToSearch) )
                return true;
        }

        return false;
    }

## Sıralama
"enum" anahtar sözcüğü, derleyiciye bu sınıfın, programcının açıkça miras almasına gerek kalmadan "Enum" soyut sınıfından miras aldığını söyler. "Enum", farklı adlandırılmış sabitler kümesiyle kullanılması amaçlanan "ValueType" öğesinin soyundan gelir.

    public enum DaysOfWeek
    {
        Monday,
        Tuesday,
    }

İsteğe bağlı olarak her biri (veya bazıları) için belirli bir değer belirleyebilirsiniz:

    public enum NotableYear
    {
       EndOfWwI = 1918;
       EnfOfWwII = 1945,
    }

Bu örnekte 0 değerini atladım, bu genellikle kötü bir uygulamadır. Bir "enum" her zaman açık dönüşüm "(YourEnumType) 0" tarafından üretilen varsayılan bir değere sahip olacaktır; burada "YourEnumType", bildirdiğiniz "enume" türünüzdür. 0 değeri tanımlanmadan, bir "enum" başlangıçta tanımlanmış bir değere sahip olmayacaktır.

"Enum"un varsayılan temel türü "int"tir, temel alınan türü "byte", "sbyte", "short", "ushort", "int", "uint", "uzun" dahil olmak üzere herhangi bir integral türüyle değiştirebilirsiniz. ' ve 'ulong'. Aşağıda, "byte" türünde temel alınan bir numaralandırma verilmiştir:

    enum Days : byte
    {
        Sunday = 0,
        Monday,
        Tuesday,
        Wednesday,
        Thursday,
        Friday,
        Saturday
    };

Ayrıca, yalnızca bir döküm ile temel türe/türden dönüştürebileceğinizi unutmayın:

    int value = (int)NotableYear.EndOfWwI;

Bu nedenlerle, kitaplık işlevlerini gösterirken her zaman bir "enum"un geçerli olup olmadığını kontrol etmeniz daha iyi olur:

    void PrintNotes(NotableYear year)
    {
        if (!Enum.IsDefined(typeof(NotableYear), year))
            throw InvalidEnumArgumentException("year", (int)year, typeof(NotableYear));
    
        // ...
    }



## içinde
`in` anahtar sözcüğünün üç kullanımı vardır:

a) Bir "foreach" ifadesindeki sözdiziminin bir parçası olarak veya bir LINQ sorgusundaki sözdiziminin bir parçası olarak

    foreach (var member in sequence)
    {
        // ...
    }

b) Genel arabirimler ve genel temsilci türleri bağlamında, söz konusu tür parametresi için _contravariance_ anlamına gelir:

    public interface IComparer<in T>
    {
        // ...
    }

c) LINQ sorgusu bağlamında, sorgulanan koleksiyona atıfta bulunur.

    var query = from x in source select new { x.Name, x.ID, };


## boyutu
Yönetilmeyen bir tür için bayt cinsinden boyutu elde etmek için kullanılır

    int byteSize = sizeof(byte) // 1
    int sbyteSize = sizeof(sbyte) // 1
    int shortSize = sizeof(short) // 2
    int ushortSize = sizeof(ushort) // 2
    int intSize = sizeof(int) // 4
    int uintSize = sizeof(uint) // 4
    int longSize = sizeof(long) // 8
    int ulongSize = sizeof(ulong) // 8
    int charSize = sizeof(char) // 2(Unicode)
    int floatSize = sizeof(float) // 4
    int doubleSize = sizeof(double) // 8
    int decimalSize = sizeof(decimal) // 16
    int boolSize = sizeof(bool) // 1

## uzun
**long** anahtar sözcüğü, imzalı 64 bit tam sayıları temsil etmek için kullanılır. "mscorlib.dll"de bulunan "System.Int64" veri türü için bir takma addır ve bunları oluşturduğunuzda her C# projesi tarafından örtük olarak başvurulur.

*Herhangi bir **uzun** değişken hem açık hem de örtük olarak bildirilebilir:*

    long long1 = 9223372036854775806;  // explicit declaration, long keyword used
    var long2 = -9223372036854775806L; // implicit declaration, 'L' suffix used

Bir **uzun** değişkeni –9,223,372,036,854,775,808 ile 9,223,372,036,854,775,807 arasında herhangi bir değeri tutabilir ve bir değişkenin diğer değişkenlerin sınırlarını aşan bir değere sahip olması gereken durumlarda yararlı olabilir ([**int**][ gibi) 1] değişken) tutabilir.


[1]: https://www.wikiod.com/tr/docs/c%23/26/keywords#t=201608201800043158849

## bool
"true" ve "false" Boole değerlerini depolamak için anahtar sözcük. bool, System.Boolean'ın bir diğer adıdır.

Bir bool'un varsayılan değeri yanlıştır.

    bool b; // default value is false
    b = true; // true
    b = ((5 + 2) == 6); // false

Bir bool'un boş değerlere izin vermesi için bool? olarak başlatılması gerekir.

Bir bool'un varsayılan değeri? boş.

    bool? a // default value is null

## işaretlenmemiş
'unchecked' anahtar sözcüğü, derleyicinin taşmaları/yetersiz akışları denetlemesini engeller.

Örneğin:

    const int ConstantMax = int.MaxValue;
    unchecked
    {
        int1 = 2147483647 + 10;
    }
    int1 = unchecked(ConstantMax + 10);

'unchecked' anahtar sözcüğü olmadan, iki toplama işleminin hiçbiri derlenmez.

## Bu ne zaman işe yarar?

Bu, taşma kontrolü zaman aldığından veya bir taşma/yetersiz taşma istendiğinde (örneğin, bir karma kodu oluştururken) kesinlikle taşmayacak hesaplamaları hızlandırmaya yardımcı olabileceğinden kullanışlıdır.

## yapmak
do operatörü, koşullu bir sorgu false değerine eşit olana kadar bir kod bloğu üzerinde yinelenir. Do-while döngüsü ayrıca bir [`goto`](https://www.wikiod.com/tr/docs/c%23/26/keywords/193/goto), [`return`](http:// stackoverflow.com/documentation/c%23/26/keywords/4600/return), [`break`](https://www.wikiod.com/tr/docs/c%23/26/keywords/2858/break) veya `throw ` beyanı.

"do" anahtar sözcüğünün sözdizimi şöyledir:

> yap
> { *kod bloğu;* }
> while( *durum*);


Örnek:

    int i = 0;

    do
    {
        Console.WriteLine("Do is on loop number {0}.", i);
    } while (i++ < 5);


Çıktı:

>"Yap, 1 numaralı döngüde." \
"Yap, 2 numaralı döngüde."\
"Yap, 3 numaralı döngüde."\
"Do, 4 numaralı döngüde."\
"Yap, 5 numaralı döngüde."


[`while`](https://www.wikiod.com/tr/docs/c%23/26/keywords/4396/while) döngüsünün aksine, do-while döngüsü **Çıkış Kontrollü**'dür. Bu, koşul ilk seferde başarısız olsa bile, do-while döngüsünün deyimlerini en az bir kez çalıştıracağı anlamına gelir.


    bool a = false;

    do
    {
        Console.WriteLine("This will be printed once, even if a is false.");
    } while (a == true);

## arayüz
Bir [`arayüz`][1] yöntemlerin, özelliklerin ve olayların [imzalarını][2] içerir. Türetilmiş sınıflar, arabirimin yalnızca üyelerin bildirimini içerdiği için üyeleri tanımlar.

"interface" anahtar sözcüğü kullanılarak bir arayüz bildirilir.

    interface IProduct
    {
        decimal Price { get; }
    }
    
    class Product : IProduct
    {
        const decimal vat = 0.2M;
        
        public Product(decimal price)
        {
            _price = price;
        }
        
        private decimal _price;
        public decimal Price { get { return _price * (1 + vat); } }
    }


[1]: http://stackoverflow.com/questions/tagged/interface+c%23
[2]: http://stackoverflow.com/questions/tagged/signature+c%23

## örtük
"Örtük" anahtar kelime, bir dönüştürme operatörünü aşırı yüklemek için kullanılır. Örneğin, gerektiğinde otomatik olarak 'double'a dönüştürülmesi gereken ve otomatik olarak 'int'den dönüştürülebilen bir 'Fraction' sınıfı bildirebilirsiniz:

    class Fraction(int numerator, int denominator)
    {
        public int Numerator { get; } = numerator;
        public int Denominator { get; } = denominator;
        // ...
        public static implicit operator double(Fraction f)
        {
            return f.Numerator / (double) f.Denominator;
        }
        public static implicit operator Fraction(int i)
        {
            return new Fraction(i, 1);
        }
    }

## kısa
16 bitlik pozitif tam sayıları depolamak için kullanılan sayısal bir tür. "ushort", "System.UInt16" için bir takma addır ve 2 bayt bellek kaplar.

Geçerli aralık "0" ile "65535" arasındadır.

```
ushort a = 50; // 50
ushort b = 65536; // Error, cannot be converted
ushort c = unchecked((ushort)65536); // Overflows (wraps around to 0)
```

## temsilci
Temsilciler, bir yönteme başvuruyu temsil eden türlerdir. Yöntemleri diğer yöntemlere argüman olarak geçirmek için kullanılırlar.

Temsilciler statik yöntemler, örnek yöntemler, anonim yöntemler veya lambda ifadeleri tutabilir.
   
```
class DelegateExample
{
    public void Run()
    {
        //using class method
        InvokeDelegate( WriteToConsole ); 
        
        //using anonymous method
        DelegateInvoker di = delegate ( string input ) 
        { 
            Console.WriteLine( string.Format( "di: {0} ", input ) );
            return true; 
        };
        InvokeDelegate( di ); 
        
        //using lambda expression
        InvokeDelegate( input => false ); 
    }

    public delegate bool DelegateInvoker( string input );

    public void InvokeDelegate(DelegateInvoker func)
    {
        var ret = func( "hello world" );
        Console.WriteLine( string.Format( " > delegate returned {0}", ret ) );
    }

    public bool WriteToConsole( string input )
    {
        Console.WriteLine( string.Format( "WriteToConsole: '{0}'", input ) );
        return true;
    }
}
```

Bir temsilciye yöntem atarken, yöntemin parametrelerle birlikte aynı dönüş türüne sahip olması gerektiğini unutmamak önemlidir. Bu, yalnızca parametrelerin yöntemin imzasını tanımladığı 'normal' yöntem aşırı yüklemesinden farklıdır.

Etkinlikler delegeler üzerine kuruludur.

## kısmi
Tip tanımının birkaç dosyaya bölünmesine izin vermek için sınıf, yapı veya arayüzün tip tanımı sırasında 'kısmi' anahtar kelimesi kullanılabilir. Bu, otomatik olarak oluşturulan koda yeni özellikler eklemek için kullanışlıdır.

**Dosya1.cs**

    namespace A
    {
        public partial class Test
        {
            public string Var1 {get;set;}
        }
    }

**File2.cs**

    namespace A
    {
        public partial class Test
        {
            public string Var2 {get;set;}
        }
    }

**Not:** Bir sınıf herhangi bir sayıda dosyaya bölünebilir. Ancak, tüm bildirimler aynı ad alanı ve aynı derleme altında olmalıdır.

Metotlar ayrıca 'kısmi' anahtar sözcüğü kullanılarak kısmi olarak bildirilebilir. Bu durumda bir dosya yalnızca yöntem tanımını içerecek ve başka bir dosya uygulamayı içerecektir.

> Kısmi yöntemin imzası, kısmi türün bir bölümünde tanımlanmış ve uygulaması türün başka bir bölümünde tanımlanmış. Kısmi yöntemler, sınıf tasarımcılarının, geliştiricilerin uygulayıp uygulamamaya karar verebileceği olay işleyicilerine benzer yöntem kancaları sağlamasına olanak tanır. Geliştirici bir uygulama sağlamazsa, derleyici derleme zamanında imzayı kaldırır. Kısmi yöntemler için aşağıdaki koşullar geçerlidir:
> * Kısmi türün her iki bölümündeki imzalar eşleşmelidir.
> * Yöntem, void döndürmelidir.
> * Erişim değiştiricilere izin verilmez. Kısmi yöntemler dolaylı olarak özeldir.
>
> -- MSDN

**Dosya1.cs**

    namespace A
    {
        public partial class Test
        {
            public string Var1 {get;set;}
            public partial Method1(string str);
        }
    }

**File2.cs**

    namespace A
    {
        public partial class Test
        {
            public string Var2 {get;set;}
            public partial Method1(string str)
            {
                Console.WriteLine(str);
            }
        }
    }


**Not:** Kısmi yöntemi içeren tür de kısmi olarak bildirilmelidir.

 




## sbyte
8 bitlik *işaretli* tam sayıları depolamak için kullanılan sayısal bir tür. "sbyte", "System.SByte" için bir takma addır ve 1 bayt bellek kaplar. İmzasız eşdeğer için "bayt" kullanın.

Geçerli aralık "-127" ile "127" arasındadır (artık, işareti saklamak için kullanılır).

```
sbyte a = 127; // 127
sbyte b = -127; // -127
sbyte c = 200; // Error, cannot be converted
sbyte d = unchecked((sbyte)129); // -127 (overflows)
```

## Etkinlik
Bir "olay", geliştiricinin bir bildirim kalıbı uygulamasına izin verir.

**Basit örnek**

    public class Server
    {
        // defines the event
        public event EventHandler DataChangeEvent;

        void RaiseEvent()
        {
            var ev = DataChangeEvent;
            if(ev != null)
            {
                ev(this, EventArgs.Empty);
            }
        }
    }

    public class Client
    {
        public void Client(Server server)
        {
            // client subscribes to the server's DataChangeEvent
            server.DataChangeEvent += server_DataChanged;
        }

        private void server_DataChanged(object sender, EventArgs args)
        {
            // notified when the server raises the DataChangeEvent
        }
    }

[MSDN referansı][1]


[1]: https://msdn.microsoft.com/en-CA/library/awbftdfh.aspx

