---
title: "Palavras-chave"
slug: "palavras-chave"
draft: false
images: []
weight: 8286
type: docs
toc: true
---

[Palavras-chave](https://msdn.microsoft.com/en-us/library/x53a06bb(v=vs.71).aspx) são identificadores reservados predefinidos com significado especial para o compilador. Eles não podem ser usados ​​como identificadores em seu programa sem o prefixo `@`. Por exemplo, `@if` é um identificador legal, mas não a palavra-chave `if`.

C# tem uma coleção predefinida de "palavras-chave" (ou palavras reservadas), cada uma com uma função especial. Essas palavras não podem ser usadas como identificadores (nomes para variáveis, métodos, classes, etc.) a menos que tenham o prefixo `@`.

* [`resumo`](https://www.wikiod.com/pt/docs/c%23/26/keywords/2872/abstract)
* [`as`](https://www.wikiod.com/pt/docs/c%23/26/keywords/138/as)
* [`base`](https://www.wikiod.com/pt/docs/c%23/26/keywords/1840/base)
* [`bool`](https://www.wikiod.com/pt/docs/c%23/26/keywords/8712/bool)
* [`break`](https://www.wikiod.com/pt/docs/c%23/26/keywords/2858/break)
* `byte`
* `caso`
* [`catch`](https://www.wikiod.com/pt/docs/c%23/26/keywords/148/try-catch-finally-throw)
* [`char`](https://www.wikiod.com/pt/docs/c%23/26/keywords/6009/char)
* [`checked`](https://www.wikiod.com/pt/docs/c%23/26/keywords/192/checked-unchecked)
* `classe`
* [`const`](https://www.wikiod.com/pt/docs/c%23/26/keywords/141/const)
* [`continuar`](https://www.wikiod.com/pt/docs/c%23/26/keywords/154/continue)
* [`decimal`](https://www.wikiod.com/pt/docs/c%23/26/keywords/2873/float-double-decimal)
* [`padrão`](https://www.wikiod.com/pt/docs/c%23/26/keywords/109/default)
* [`delegate`](https://www.wikiod.com/pt/docs/c%23/26/keywords/18720/delegate)
* [`do`](https://www.wikiod.com/pt/docs/c%23/26/keywords/12229/do)
* [`double`](https://www.wikiod.com/pt/docs/c%23/26/keywords/2873/float-double-decimal)
* [`else`](https://www.wikiod.com/pt/docs/c%23/26/keywords/11359/if-if-else-if-else-if)
* [`enum`](https://www.wikiod.com/pt/docs/c%23/26/keywords/245/enum)
* [`evento`](https://www.wikiod.com/pt/docs/c%23/26/keywords/18722/event)
* `explícito`
* [`extern`](https://www.wikiod.com/pt/docs/c%23/26/keywords/8191/extern)
* [`false`](https://www.wikiod.com/pt/docs/c%23/26/keywords/17113/true-false)
* [`finalmente`](https://www.wikiod.com/pt/docs/c%23/26/keywords/148/try-catch-finally-throw)
* [`fixed`](https://www.wikiod.com/pt/docs/c%23/26/keywords/59/fixed)
* [`float`](https://www.wikiod.com/pt/docs/c%23/26/keywords/2873/float-double-decimal)
* [`para`](https://www.wikiod.com/pt/docs/c%23/26/keywords/3722/for)
* [`foreach`](https://www.wikiod.com/pt/docs/c%23/26/keywords/1928/foreach)
* [`goto`](https://www.wikiod.com/pt/docs/c%23/26/keywords/193/goto)
* [`if`](https://www.wikiod.com/pt/docs/c%23/26/keywords/11359/if-if-else-if-else-if)
* [`implícito`](https://www.wikiod.com/pt/docs/c%23/26/keywords/16557/implicit)
* [`in`](https://www.wikiod.com/pt/docs/c%23/26/keywords/4992/in)
* [`int`](https://www.wikiod.com/pt/docs/c%23/26/keywords/5328/int)
* [`interface`](https://www.wikiod.com/pt/docs/c%23/26/keywords/14354/interface)
* [`interno`][1]
* [`é`](https://www.wikiod.com/pt/docs/c%23/26/keywords/139/is)
* [`lock`](https://www.wikiod.com/pt/docs/c%23/26/keywords/6452/lock#t=201607261640175640513)
* [`longo`](https://www.wikiod.com/pt/docs/c%23/26/keywords/5329/long)
* [`namespace`](https://www.wikiod.com/pt/docs/c%23/26/keywords/142/namespace)
* [`novo`](https://www.wikiod.com/pt/docs/c%23/26/keywords/5805/virtual-override-new)
* [`null`](https://www.wikiod.com/pt/docs/c%23/26/keywords/6750/null)
* `objeto`
* [`operador`](https://www.wikiod.com/pt/docs/c%23/26/keywords/12604/operator)
* [`out`](https://www.wikiod.com/pt/docs/c%23/26/keywords/184/ref-out)
* [`substituir`](https://www.wikiod.com/pt/docs/c%23/26/keywords/5805/virtual-override-new)
* [`params`](https://www.wikiod.com/pt/docs/c%23/26/keywords/2513/params)
* `privado`
* `protegido`
* `público`
* [`readonly`](https://www.wikiod.com/pt/docs/c%23/26/keywords/110/readonly)
* [`ref`](https://www.wikiod.com/pt/docs/c%23/26/keywords/184/ref-out)
* [`return`](https://www.wikiod.com/pt/docs/c%23/26/keywords/4600/return)
* [`sbyte`](https://www.wikiod.com/pt/docs/c%23/26/keywords/18290/sbyte)
* [`selado`](https://www.wikiod.com/pt/docs/c%23/26/keywords/5245/selado)
* `curta`
* [`sizeof`](https://www.wikiod.com/pt/docs/c%23/26/keywords/5246/sizeof)
* [`stackalloc`](https://www.wikiod.com/pt/docs/c%23/26/keywords/57/stackalloc)
* [`static`](https://www.wikiod.com/pt/docs/c%23/26/keywords/5248/static)
* [`string`](https://www.wikiod.com/pt/docs/c%23/26/keywords/17143/string)
* [`estrutura`][2]
* [`switch`](https://www.wikiod.com/pt/docs/c%23/26/keywords/14353/switch)
* [`this`](https://www.wikiod.com/pt/docs/c%23/26/keywords/2914/this)
* [`throw`](https://www.wikiod.com/pt/docs/c%23/26/keywords/148/try-catch-finally-throw)
* [`true`](https://www.wikiod.com/pt/docs/c%23/26/keywords/17113/true-false)
* [`tente`](https://www.wikiod.com/pt/docs/c%23/26/keywords/148/try-catch-finally-throw)
* [`typeof`](https://www.wikiod.com/pt/docs/c%23/26/keywords/140/typeof)
* [`uint`](https://www.wikiod.com/pt/docs/c%23/26/keywords/2874/uint)
* [`ulong`](https://www.wikiod.com/pt/docs/c%23/26/keywords/5330/ulong)
* [`unchecked`](https://www.wikiod.com/pt/docs/c%23/26/keywords/192/checked-unchecked)
* [`inseguro`](https://www.wikiod.com/pt/docs/c%23/26/keywords/15630/unsafe)
* [`ushort`](https://www.wikiod.com/pt/docs/c%23/26/keywords/18289/ushort)
* [`usando` (diretiva)](https://www.wikiod.com/pt/docs/c%23/52/using-directive#t=201605012059492751326)
* [`usando` (declaração)](https://www.wikiod.com/pt/docs/c%23/38/using-statement#t=20160501205709291959)
* [`virtual`](https://www.wikiod.com/pt/docs/c%23/26/keywords/5805/virtual-override-new)
* [`void`](https://www.wikiod.com/pt/docs/c%23/26/keywords/2980/void)
* [`volatile`](https://www.wikiod.com/pt/docs/c%23/26/keywords/58/volatile)
* [`quando`](https://www.wikiod.com/pt/docs/c%23/26/keywords/9258/when)
* [`while`](https://www.wikiod.com/pt/docs/c%23/26/keywords/4396/while)

Além disso, o C# também usa algumas palavras-chave para fornecer um significado específico no código. Eles são chamados de palavras-chave contextuais. Palavras-chave contextuais podem ser usadas como identificadores e não precisam ser prefixadas com `@` quando usadas como identificadores.

* `adicionar`
* `alias`
* `ascendente`
* [`async`](https://www.wikiod.com/pt/docs/c%23/26/keywords/5993/async-await)
* [`await`](https://www.wikiod.com/pt/docs/c%23/26/keywords/5993/async-await)
* `descendente`
* `dinâmico`
* `de`
* `obter`
* `global`
* `grupo`
* `dentro`
* `juntar`
* `deixe`
* [`nameof`](https://www.wikiod.com/pt/docs/c%23/24/c-sharp-6-0-features/43/operator-nameof)
* `pedido por`
* [`parcial`](https://www.wikiod.com/pt/docs/c%23/26/keywords/19199/partial#t=201608110434471554387)
* `remover`
* `selecionar`
* `definir`
* `valor`
* [`var`](https://www.wikiod.com/pt/docs/c%23/26/keywords/4503/var)
* [`onde`](https://www.wikiod.com/pt/docs/c%23/26/keywords/8137/where-type-constraints)
* [`rendimento`](https://www.wikiod.com/pt/docs/c%23/61/yield-keyword-in-c#t=201605012045372009603)


[1]: https://www.wikiod.com/pt/docs/c%23/26/keywords/8102/internal#t=201607221603473329189
[2]: https://www.wikiod.com/pt/docs/c%23/26/keywords/13023/struct#t=201607251950535084892

## Como
A palavra-chave `as` é um operador semelhante a um *cast*. Se uma conversão não for possível, usar `as` produz `null` em vez de resultar em uma `InvalidCastException`.

`expression as type` é equivalente a `expression is type ? (type)expression : (type)null` com a ressalva de que `as` só é válido em conversões de referência, conversões anuláveis ​​e conversões de caixa. As conversões definidas pelo usuário *não* são suportadas; um elenco regular deve ser usado em seu lugar.

Para a expansão acima, o compilador gera código de forma que `expression` seja avaliada apenas uma vez e use uma única verificação de tipo dinâmico (diferente das duas no exemplo acima).

`as` pode ser útil quando se espera que um argumento facilite vários tipos. Especificamente, ele concede várias opções ao usuário - em vez de verificar todas as possibilidades com `is` antes de lançar, ou apenas lançar e capturar exceções. É uma prática recomendada usar 'como' ao lançar/verificar um objeto que causará apenas uma penalidade de unboxing. Usando `is` para verificar, o casting causará duas penalidades de unboxing.

Se se espera que um argumento seja uma instância de um tipo específico, uma conversão regular é preferida, pois seu objetivo é mais claro para o leitor.

Como uma chamada para `as` pode produzir `null`, sempre verifique o resultado para evitar uma `NullReferenceException`.

**Exemplo de uso**

    object something = "Hello";
    Console.WriteLine(something as string);        //Hello
    Console.Writeline(something as Nullable<int>); //null
    Console.WriteLine(something as int?);          //null
    
    //This does NOT compile:
    //destination type must be a reference type (or a nullable value type)
    Console.WriteLine(something as int);

[Demonstração ao vivo no .NET Fiddle](https://dotnetfiddle.net/b26q6N)

Exemplo equivalente sem usar `as`:

    Console.WriteLine(something is string ? (string)something : (string)null);

Isso é útil ao substituir a função `Equals` em classes personalizadas.

    class MyCustomClass
    {

        public override bool Equals(object obj)
        {
            MyCustomClass customObject = obj as MyCustomClass;

            // if it is null it may be really null
            // or it may be of a different type
            if (Object.ReferenceEquals(null, customObject))
            {
                // If it is null then it is not equal to this instance.
                return false;
            }

            // Other equality controls specific to class
        }

    }

## Vá para
`goto` pode ser usado para pular para uma linha específica dentro do código, especificada por um rótulo.

# `goto` como:

## Etiqueta:

    void InfiniteHello()
    {
        sayHello:
        Console.WriteLine("Hello!");
        goto sayHello;
    }

[Demonstração ao vivo no .NET Fiddle](https://dotnetfiddle.net/Tpm3LV)

## Declaração do caso:

    enum Permissions { Read, Write };

    switch (GetRequestedPermission())
    {
        case Permissions.Read:
            GrantReadAccess();
            break;

        case Permissions.Write:
            GrantWriteAccess();
            goto case Permissions.Read; //People with write access also get read
    }

[Demonstração ao vivo no .NET Fiddle](https://dotnetfiddle.net/2IV2wC)

Isso é particularmente útil na execução de vários comportamentos em uma instrução switch, pois o C# não oferece suporte a [blocos de caso de fall-through](http://stackoverflow.com/a/174223/365102).

## Tentativa de Exceção

    var exCount = 0;
    retry:
    try
    {
        //Do work
    }
    catch (IOException)
    {
        exCount++;
        if (exCount < 3)
        {
            Thread.Sleep(100);
            goto retry;
        }
        throw;
    }

[Demonstração ao vivo no .NET Fiddle](https://dotnetfiddle.net/kc6oiT)

Semelhante a muitos idiomas, o uso da palavra-chave goto é desencorajado, exceto nos casos abaixo.

[Usos válidos de `goto`][wiki] que se aplicam a C#:

* Caso de fall-through na instrução switch.
* Quebra de vários níveis. O LINQ geralmente pode ser usado, mas geralmente tem um desempenho pior.
* Desalocação de recursos ao trabalhar com objetos de baixo nível desempacotados. Em C#, objetos de baixo nível geralmente devem ser agrupados em classes separadas.
* Máquinas de estado finito, por exemplo, analisadores; usado internamente por máquinas de estado async/await geradas pelo compilador.

[so]: http://stackoverflow.com/questions/tagged/goto+c%23
[wiki]: https://en.wikipedia.org/wiki/Goto#Common_usage_patterns_of_Goto

## volátil
Adicionar a palavra-chave `volatile` a um campo indica ao compilador que o valor do campo pode ser alterado por vários threads separados. O objetivo principal da palavra-chave `volatile` é evitar otimizações do compilador que assumem apenas acesso single-thread. O uso de `volátil` garante que o valor do campo seja o valor mais recente disponível e que o valor não esteja sujeito ao armazenamento em cache que os valores não voláteis são.

É uma boa prática marcar _toda variável_ que pode ser usada por vários threads como `volátil` para evitar comportamentos inesperados devido a otimizações nos bastidores. Considere o seguinte bloco de código:

    public class Example
    {
        public int x;

        public void DoStuff()
        {
            x = 5;

            // the compiler will optimize this to y = 15
            var y = x + 10;

            /* the value of x will always be the current value, but y will always be "15" */
            Debug.WriteLine("x = " + x + ", y = " + y);
        }    
    }

No bloco de código acima, o compilador lê as instruções `x = 5` e `y = x + 10` e determina que o valor de `y` sempre terminará como 15. Assim, ele otimizará a última instrução como `y = 15`. No entanto, a variável `x` é de fato um campo `public` e o valor de `x` pode ser modificado em tempo de execução através de uma thread diferente atuando neste campo separadamente. Agora considere este bloco de código modificado. Observe que o campo `x` agora é declarado como `volátil`.

    public class Example
    {
        public volatile int x;

        public void DoStuff()
        {
            x = 5;

            // the compiler no longer optimizes this statement
            var y = x + 10;

            /* the value of x and y will always be the correct values */
            Debug.WriteLine("x = " + x + ", y = " + y);
        }    
    }

Agora, o compilador procura por usos *read* do campo `x` e garante que o valor atual do campo seja sempre recuperado. Isso garante que, mesmo que vários threads estejam lendo e gravando nesse campo, o valor atual de `x` sempre será recuperado.

`volatile` só pode ser usado em campos dentro de `class`es ou `struct`s. O seguinte [*não* é válido][2]:

<pre>public void MeuMétodo()
{
    <strike>volatile</strike> int x;
}</pre>

`volatile` só pode ser aplicado a campos dos seguintes tipos:
- tipos de referência ou parâmetros de tipo genéricos conhecidos como tipos de referência
- tipos primitivos como `sbyte`, `byte`, `short`, `ushort`, `int`, `uint`, `char`, `float` e `bool`
- tipos enums baseados em `byte`, `sbyte`, `short`, `ushort`, `int` ou `uint`
- `IntPtr` e `UIntPtr`

----------
**Observações:**

- O modificador [`volatile`][1] geralmente é usado para um campo que é acessado por vários threads sem usar a instrução lock para serializar o acesso.
- A palavra-chave `volatile` pode ser aplicada a campos de tipos de referência
- A palavra-chave `volatile` não tornará a operação em primitivas de 64 bits em uma plataforma de 32 bits atômica. Operações interligadas, como [`Interlocked.Read`][3] e [`Interlocked.Exchange`][4] ainda devem ser usadas para acesso multi-thread seguro nessas plataformas.


[1]: http://stackoverflow.com/questions/72275/when-should-the-volatile-keyword-be-used-in-c
[2]: https://msdn.microsoft.com/en-us/library/x13ttww7.aspx
[3]: https://msdn.microsoft.com/en-us/library/system.threading.interlocked.read(v=vs.110).aspx
[4]: https://msdn.microsoft.com/en-us/library/dk0121zy(v=vs.110).aspx

## marcado, desmarcado
As palavras-chave `checked` e `unchecked` definem como as operações lidam com estouro matemático. "Estouro" no contexto das palavras-chave `checked` e `unchecked` é quando uma operação aritmética inteira resulta em um valor que é maior em magnitude do que o tipo de dados de destino pode representar.

Quando o estouro ocorre dentro de um bloco `checked` (ou quando o compilador está configurado para usar globalmente a aritmética verificada), uma exceção é lançada para avisar sobre um comportamento indesejado. Enquanto isso, em um bloco `unchecked`, o overflow é silencioso: nenhuma exceção é lançada, e o valor simplesmente vai para o limite oposto. Isso pode levar a bugs sutis e difíceis de encontrar.

Como a maioria das operações aritméticas são feitas em valores que não são grandes ou pequenos o suficiente para estourar, na maioria das vezes, não há necessidade de definir explicitamente um bloco como `checked`. É preciso ter cuidado ao fazer aritmética em entradas ilimitadas que podem causar estouro, por exemplo, ao fazer aritmética em funções recursivas ou ao receber entradas do usuário.

_Nem `checked` nem `unchecked` afetam as operações aritméticas de ponto flutuante._

Quando um bloco ou expressão é declarado como `unchecked`, quaisquer operações aritméticas dentro dele podem transbordar sem causar um erro. Um exemplo em que esse comportamento é *desejado* seria o cálculo de uma soma de verificação, onde o valor pode ser "envolvido" durante o cálculo:

    byte Checksum(byte[] data) {
        byte result = 0;
        for (int i = 0; i < data.Length; i++) {
            result = unchecked(result + data[i]); // unchecked expression
        }
        return result;
    }

Um dos usos mais comuns para `unchecked` é implementar uma substituição personalizada para `object.GetHashCode()`, um tipo de soma de verificação. Você pode ver o uso da palavra-chave nas respostas a esta pergunta: http://stackoverflow.com/questions/263400/what-is-the-best-algorithm-for-an-overridden-system-object-gethashcode.

Quando um bloco ou expressão é declarado como `checked`, qualquer operação aritmética que causa um estouro resulta em uma `OverflowException` sendo lançada.

    int SafeSum(int x, int y) {
        checked { // checked block
            return x + y; 
        }
    }

Ambos marcados e desmarcados podem estar em forma de bloco e expressão.

Blocos marcados e desmarcados não afetam os métodos chamados, apenas os operadores chamados diretamente no método atual. Por exemplo, `Enum.ToObject()`, `Convert.ToInt32()` e operadores definidos pelo usuário não são afetados por contextos personalizados marcados/desmarcados.

***Observação**: O comportamento padrão de estouro padrão (marcado versus desmarcado) pode ser alterado nas **Propriedades do projeto** ou por meio da opção de linha de comando **/checked[+|-]**. É comum usar como padrão as operações marcadas para compilações de depuração e desmarcadas para compilações de lançamento. As palavras-chave `checked` e `unchecked` seriam usadas apenas onde uma abordagem _default_ não se aplica e você precisa de um comportamento explícito para garantir a correção.*

## virtual, substituir, novo
virtual e substituir
====================

A palavra-chave `virtual` permite que um método, propriedade, indexador ou evento seja substituído por classes derivadas e apresente comportamento polimórfico. (Membros não são virtuais por padrão em C#)

    public class BaseClass
    {
        public virtual void Foo()
        {
            Console.WriteLine("Foo from BaseClass");
        }
    }

Para substituir um membro, a palavra-chave `override` é usada nas classes derivadas. (Observe que a assinatura dos membros deve ser idêntica)

    public class DerivedClass: BaseClass
    {
        public override void Foo()
        {
            Console.WriteLine("Foo from DerivedClass");
        }
    }

O comportamento polimórfico de membros virtuais significa que, quando invocado, o membro real que está sendo executado é determinado em tempo de execução em vez de em tempo de compilação. O membro de substituição na classe mais derivada da qual o objeto específico é uma instância será aquele executado.

Em resumo, o objeto pode ser declarado do tipo `BaseClass` em tempo de compilação, mas se em tempo de execução for uma instância de `DerivedClass`, o membro substituído será executado:

    BaseClass obj1 = new BaseClass();
    obj1.Foo(); //Outputs "Foo from BaseClass"

    obj1 = new DerivedClass();
    obj1.Foo(); //Outputs "Foo from DerivedClass"    

Substituir um método é opcional:

    public class SecondDerivedClass: DerivedClass {}
    
    var obj1 = new SecondDerivedClass();
    obj1.Foo(); //Outputs "Foo from DerivedClass"    

novo
====================    
Como apenas membros definidos como 'virtuais' são substituíveis e polimórficos, uma classe derivada redefinindo um membro não virtual pode levar a resultados inesperados.

    public class BaseClass
    {
        public void Foo()
        {
            Console.WriteLine("Foo from BaseClass");
        }
    }

    public class DerivedClass: BaseClass
    {
        public void Foo()
        {
            Console.WriteLine("Foo from DerivedClass");
        }
    }

    BaseClass obj1 = new BaseClass();
    obj1.Foo(); //Outputs "Foo from BaseClass"

    obj1 = new DerivedClass();
    obj1.Foo(); //Outputs "Foo from BaseClass" too!    

Quando isso acontece, o membro executado é sempre determinado em tempo de compilação com base no tipo do objeto.

- Se o objeto for declarado do tipo `BaseClass` (mesmo que em tempo de execução seja de uma classe derivada) então o método de `BaseClass` é executado
- Se o objeto for declarado do tipo `DerivedClass` então o método de `DerivedClass` será executado.

Isso geralmente é um acidente (quando um membro é adicionado ao tipo base depois que um idêntico foi adicionado ao tipo derivado) e um aviso do compilador **CS0108** é gerado nesses cenários.

Se foi intencional, então a palavra-chave `new` é usada para suprimir o aviso do compilador (e informar outros desenvolvedores de suas intenções!). o comportamento permanece o mesmo, a palavra-chave `new` apenas suprime o aviso do compilador.

    public class BaseClass
    {
        public void Foo()
        {
            Console.WriteLine("Foo from BaseClass");
        }
    }

    public class DerivedClass: BaseClass
    {
        public new void Foo()
        {
            Console.WriteLine("Foo from DerivedClass");
        }
    }

    BaseClass obj1 = new BaseClass();
    obj1.Foo(); //Outputs "Foo from BaseClass"

    obj1 = new DerivedClass();
    obj1.Foo(); //Outputs "Foo from BaseClass" too! 

O uso de substituição é _não_ opcional
=======================================
Ao contrário do C++, o uso da palavra-chave `override` *não* é opcional:

    public class A
    {
        public virtual void Foo()
        {
        }
    }

    public class B : A
    {
        public void Foo() // Generates CS0108
        {
        }
    }

O exemplo acima também causa o aviso **CS0108**, porque `B.Foo()` não está substituindo automaticamente `A.Foo()`. Adicione `override` quando a intenção for substituir a classe base e causar comportamento polimórfico, adicione `new` quando desejar um comportamento não polimórfico e resolva a chamada usando o tipo estático. Este último deve ser usado com cautela, pois pode causar confusão grave.

O código a seguir ainda resulta em um erro:

    public class A
    {
        public void Foo()
        {
        }
    }

    public class B : A
    {
        public override void Foo() // Error: Nothing to override
        {
        }
    }

Classes derivadas podem introduzir polimorfismo
==========================================
O código a seguir é perfeitamente válido (embora raro):

        public class A
        {
            public void Foo()
            {
                Console.WriteLine("A");
            }
        }

        public class B : A
        {
            public new virtual void Foo() 
            {
                Console.WriteLine("B");
            }
        }

Agora todos os objetos com uma referência estática de B (e suas derivadas) usam polimorfismo para resolver `Foo()`, enquanto as referências de A usam `A.Foo()`.

    A a = new A();
    a.Foo(); // Prints "A";
    a = new B();
    a.Foo(); // Prints "A";
    B b = new B();
    b.Foo(); // Prints "B";

Métodos virtuais não podem ser privados
=================================
O compilador C# é rigoroso na prevenção de construções sem sentido. Métodos marcados como `virtuais` não podem ser privados. Como um método privado não pode ser visto a partir de um tipo derivado, ele também não pode ser substituído. Isso falha ao compilar:

    public class A
    {
        private virtual void Foo() // Error: virtual methods cannot be private
        {
        }
    }

## stackalloc
A palavra-chave `stackalloc` cria uma região de memória na pilha e retorna um ponteiro para o início dessa memória. A memória alocada em pilha é removida automaticamente quando o escopo em que foi criado é encerrado.

    //Allocate 1024 bytes. This returns a pointer to the first byte.
    byte* ptr = stackalloc byte[1024];

    //Assign some values...
    ptr[0] = 109;
    ptr[1] = 13;
    ptr[2] = 232;
    ...

<sup>*Usado em um contexto inseguro.*</sup>

Como acontece com todos os ponteiros em C#, não há verificação de limites em leituras e atribuições. A leitura além dos limites da memória alocada terá resultados imprevisíveis - pode acessar algum local arbitrário na memória ou pode causar uma exceção de violação de acesso.

    //Allocate 1 byte
    byte* ptr = stackalloc byte[1];

    //Unpredictable results...
    ptr[10] = 1;
    ptr[-1] = 2;

A memória alocada em pilha é removida automaticamente quando o escopo em que foi criado é encerrado. Isso significa que você nunca deve retornar a memória criada com stackalloc ou armazená-la além do tempo de vida do escopo.

    unsafe IntPtr Leak() {
        //Allocate some memory on the stack
        var ptr = stackalloc byte[1024];

        //Return a pointer to that memory (this exits the scope of "Leak")
        return new IntPtr(ptr);
    }

    unsafe void Bad() {
         //ptr is now an invalid pointer, using it in any way will have
         //unpredictable results. This is exactly the same as accessing beyond
         //the bounds of the pointer.
         var ptr = Leak();
    }

`stackalloc` só pode ser usado ao declarar *e* variáveis ​​de inicialização. O seguinte *não* é válido:

    byte* ptr;
    ...
    ptr = stackalloc byte[1024];

----------
**Observações:**

`stackalloc` deve ser usado apenas para otimizações de desempenho (para computação ou interoperabilidade). Isso se deve ao fato de que:

- O coletor de lixo não é necessário, pois a memória é alocada na pilha em vez do heap - a memória é liberada assim que a variável sai do escopo
- É mais rápido alocar memória na pilha do que no heap
- Aumente a chance de acertos de cache na CPU devido à localidade dos dados

## parar
Em um loop (for, foreach, do, while) a instrução `break` aborta a execução do loop mais interno e retorna ao código depois dele. Também pode ser usado com `yield` no qual especifica que um iterador chegou ao fim.

    for (var i = 0; i < 10; i++)
    {
        if (i == 5)
        {
            break;
        }
        Console.WriteLine("This will appear only 5 times, as the break will stop the loop.");
    }

[Demonstração ao vivo no .NET Fiddle](https://dotnetfiddle.net/QtpNyk)
    
    foreach (var stuff in stuffCollection)
    {
        if (stuff.SomeStringProp == null)
            break;
        // If stuff.SomeStringProp for any "stuff" is null, the loop is aborted.
        Console.WriteLine(stuff.SomeStringProp);
    }

A instrução break também é usada em construções switch-case para quebrar um caso ou segmento padrão.

    switch(a)
    {
        case 5:
            Console.WriteLine("a was 5!");
            break;

        default:
            Console.WriteLine("a was something else!");
            break;
    }

Em instruções switch, a palavra-chave 'break' é necessária no final de cada instrução case. Isso é contrário a algumas linguagens que permitem 'cair' para a próxima instrução case da série. As soluções alternativas para isso incluem instruções 'goto' ou empilhar as instruções 'case' sequencialmente.

O código a seguir fornecerá os números `0, 1, 2, ..., 9` e a última linha não será executada. `yield break` significa o fim da função (não apenas um loop).

    public static IEnumerable<int> GetNumbers()
    {
        int i = 0;
        while (true) {
            if (i < 10) {
                yield return i++;
            } else {
                yield break;
            }
        }
        Console.WriteLine("This line will not be executed");
    }

[Demonstração ao vivo no .NET Fiddle][1]


Observe que, ao contrário de algumas outras linguagens, não há como rotular uma quebra específica em C#. Isso significa que, no caso de loops aninhados, apenas o loop mais interno será interrompido:

    foreach (var outerItem in outerList)
    {
        foreach (var innerItem in innerList)
        {
            if (innerItem.ShoudBreakForWhateverReason)
                // This will only break out of the inner loop, the outer will continue:
                break; 
        }
    }

Se você quiser sair do loop *externo* aqui, você pode usar uma das várias estratégias diferentes, como:
- Uma instrução **goto** para sair de toda a estrutura de loop.
- Uma variável sinalizadora específica (`shouldBreak` no exemplo a seguir) que pode ser verificada no final de cada iteração do loop externo.
- Refatorar o código para usar uma instrução `return` no corpo do loop mais interno ou evitar toda a estrutura de loop aninhada.


    bool shouldBreak = false;
    while(comeCondition)
    {
        while(otherCondition)
        {
            if (conditionToBreak)
            {
                // Either tranfer control flow to the label below...
                goto endAllLooping;

                // OR use a flag, which can be checked in the outer loop:
                shouldBreak = true;
            }
        }

        if(shouldBreakNow)
        {
            break; // Break out of outer loop if flag was set to true
        }
    }

    endAllLooping: // label from where control flow will continue



[1]: https://dotnetfiddle.net/IjSyVJ

## const
`const` é usado para representar valores que **nunca serão alterados** durante a vida útil do programa. Seu valor é constante desde **compile-time**, ao contrário da palavra-chave [`readonly`](https://www.wikiod.com/pt/docs/c%23/26/keywords/110/readonly), cujo valor é constante do tempo de execução.

Por exemplo, como a velocidade da luz nunca mudará, podemos armazená-la em uma constante.

    const double c = 299792458;  // Speed of light
    
    double CalculateEnergy(double mass)
    {
        return mass * c * c;
    }

Isso é essencialmente o mesmo que ter `return mass * 299792458 * 299792458`, pois o compilador substituirá diretamente `c` por seu valor constante.

Como resultado, `c` não pode ser alterado uma vez declarado. O seguinte irá produzir um erro em tempo de compilação:

    const double c = 299792458;  // Speed of light 
    
    c = 500;  //compile-time error
    
Uma constante pode ser prefixada com os mesmos modificadores de acesso que os métodos:

    private const double c = 299792458;
    public const double c = 299792458;
    internal const double c = 299792458;

Os membros `const` são `static` por natureza. No entanto, usar `static` explicitamente não é permitido.

Você também pode definir constantes de método local:

    double CalculateEnergy(double mass)
    {
        const c = 299792458;
        return mass * c * c;
    }

Estes não podem ser prefixados com uma palavra-chave `private` ou `public`, pois são implicitamente locais para o método em que são definidos.

----------

Nem todos os tipos podem ser usados ​​em uma declaração `const`. Os tipos de valor permitidos são os tipos predefinidos `sbyte`, `byte`, `short`, `ushort`, `int`, `uint`, `long`, `ulong`, `char`, ` float`, `double`, `decimal`, `bool` e todos os tipos `enum`. Tentar declarar membros `const` com outros tipos de valor (como `TimeSpan` ou `Guid`) falhará em tempo de compilação.

Para o tipo de referência pré-definido especial `string`, as constantes podem ser declaradas com qualquer valor. Para todos os outros tipos de referência, as constantes podem ser declaradas, mas devem sempre ter o valor `null`.

----------

Como os valores `const` são conhecidos em tempo de compilação, eles são permitidos como rótulos `case` em uma instrução `switch`, como argumentos padrão para parâmetros opcionais, como argumentos para especificações de atributos e assim por diante.

----------

Se os valores `const` forem usados ​​em diferentes assemblies, deve-se tomar cuidado com o controle de versão. Por exemplo, se o assembly A define um `public const int MaxRetries = 3;`, e o assembly B usa essa constante, então se o valor de `MaxRetries` for alterado posteriormente para `5` no assembly A (que é então recompilado ), essa alteração não será efetiva no assembly B _a menos_ que o assembly B também seja recompilado (com uma referência à nova versão de A).

Por esse motivo, se um valor puder ser alterado em futuras revisões do programa, e se o valor precisar ser visível publicamente, não declare esse valor `const` a menos que você saiba que todos os assemblies dependentes serão recompilados sempre que algo for alterado . A alternativa é usar `static readonly` em vez de `const`, que é resolvido em tempo de execução.

## por
Sintaxe: `for (inicializador; condição; iterador)`

- O loop `for` é comumente usado quando o número de iterações é conhecido.
- As instruções na seção `initializer` são executadas apenas uma vez, antes de você entrar no loop.
- A seção `condition` contém uma expressão booleana que é avaliada no final de cada iteração do loop para determinar se o loop deve ser encerrado ou executado novamente.
- A seção `iterator` define o que acontece após cada iteração do corpo do loop.

Este exemplo mostra como `for` pode ser usado para iterar sobre os caracteres de uma string:

    string str = "Hello";
    for (int i = 0; i < str.Length; i++)
    {
        Console.WriteLine(str[i]);                
    }
                     
Resultado:

>H
>e
>l
>l
>o

[<kbd>Demonstração ao vivo no .NET Fiddle</kbd>](https://dotnetfiddle.net/Ybg356)

Todas as expressões que definem uma instrução `for` são opcionais; por exemplo, a seguinte instrução é usada para criar um loop infinito:

    for( ; ; )
    {
        // Your code here
    }

A seção `inicializador` pode conter várias variáveis, desde que sejam do mesmo tipo. A seção `condition` pode consistir em qualquer expressão que possa ser avaliada como um `bool`. E a seção `iterator` pode executar várias ações separadas por vírgula:

    string hello = "hello";
    for (int i = 0, j = 1, k = 9; i < 3 && k > 0; i++, hello += i) {
        Console.WriteLine(hello);
    }

Resultado:

>olá
>olá1
>olá12

[<kbd>Demonstração ao vivo no .NET Fiddle</kbd>](https://dotnetfiddle.net/LQcqCv)

## assíncrono, aguarde


A palavra-chave `await` foi adicionada como parte da versão C# 5.0 que é suportada a partir do Visual Studio 2012 em diante. Ele aproveita a Biblioteca Paralela de Tarefas (TPL), que tornou o multi-threading relativamente mais fácil. As palavras-chave `async` e `await` são usadas em par na mesma função mostrada abaixo. A palavra-chave `await` é usada para pausar a execução do método assíncrono atual até que a tarefa assíncrona esperada seja concluída e/ou seus resultados sejam retornados. Para usar a palavra-chave `await`, o método que a utiliza deve ser marcado com a palavra-chave `async`.

Usar `async` com `void` é fortemente desencorajado. Para mais informações você pode olhar [aqui][1].

Exemplo:

    public async Task DoSomethingAsync()
    {    
        Console.WriteLine("Starting a useless process...");
        Stopwatch stopwatch = Stopwatch.StartNew();
        int delay = await UselessProcessAsync(1000);
        stopwatch.Stop();
        Console.WriteLine("A useless process took {0} milliseconds to execute.", stopwatch.ElapsedMilliseconds);
    }
    
    public async Task<int> UselessProcessAsync(int x)
    {
        await Task.Delay(x);
        return x;
    }

Resultado:

> "Iniciando um processo inútil..."\
> \
> **... 1 segundo de atraso... **
> 
> "Um processo inútil levou 1000 milissegundos para ser executado."

Os pares de palavras-chave `async` e `await` podem ser omitidos se um método de retorno `Task` ou `Task<T>` retornar apenas uma única operação assíncrona.

*Ao invés disso:*

    public async Task PrintAndDelayAsync(string message, int delay)
    {
        Debug.WriteLine(message);
        await Task.Delay(x);
    }

*É preferível fazer isso:*

    public Task PrintAndDelayAsync(string message, int delay)
    {
        Debug.WriteLine(message);
        return Task.Delay(x);
    }
<!-- if versão [eq 5.0] -->
Em C# 5.0 `await` não pode ser usado em `catch` e `finally`.

<!-- versão final if -->

<!-- if versão [gte 6.0] -->
[Com C# 6.0][2] `await` pode ser usado em `catch` e `finally`.
<!-- versão final if -->


[1]: https://msdn.microsoft.com/en-us/magazine/jj991977.aspx
[2]: https://www.wikiod.com/pt/docs/c%23/24/c-sharp-6-0-features/50/await-in-catch-and-finally#t=201607281146527675886

## abstrato
Uma classe marcada com a palavra-chave `abstract` não pode ser instanciada.

Uma classe *deve* ser marcada como abstrata se contiver membros abstratos ou se herdar membros abstratos que não implementa. Uma classe *pode* ser marcada como abstrata mesmo se nenhum membro abstrato estiver envolvido.

As classes abstratas geralmente são usadas como classes base quando alguma parte da implementação precisa ser especificada por outro componente.

    abstract class Animal 
    {
        string Name { get; set; }
        public abstract void MakeSound();
    }
    
    public class Cat : Animal 
    {
        public override void MakeSound()
        {
            Console.WriteLine("Meov meov");
        }
    }
    
    public class Dog : Animal 
    {   
        public override void MakeSound()
        {
            Console.WriteLine("Bark bark");
        }
    }
    
    Animal cat = new Cat();       // Allowed due to Cat deriving from Animal
    cat.MakeSound();              // will print out "Meov meov"    

    Animal dog = new Dog();       // Allowed due to Dog deriving from Animal
    dog.MakeSound();              // will print out "Bark bark"

    Animal animal = new Animal(); // Not allowed due to being an abstract class

Um método, propriedade ou evento marcado com a palavra-chave `abstract` indica que se espera que a implementação desse membro seja fornecida em uma subclasse. Como mencionado acima, membros abstratos só podem aparecer em classes abstratas.

    abstract class Animal 
    {
       public abstract string Name { get; set; }
    }
    
    public class Cat : Animal 
    {
        public override string Name { get; set; }
    }
    
    public class Dog : Animal 
    {
        public override string Name { get; set; }
    }

## fixo
A instrução fixed fixa a memória em um local. Os objetos na memória geralmente estão se movendo, o que possibilita a coleta de lixo. Mas quando usamos ponteiros inseguros para endereços de memória, essa memória não deve ser movida.

- Usamos a instrução fixed para garantir que o coletor de lixo não realoque os dados da string.

<h3>Variáveis ​​fixas</h3>

    var myStr = "Hello world!";
    
    fixed (char* ptr = myStr)
    {
        // myStr is now fixed (won't be [re]moved by the Garbage Collector).
        // We can now do something with ptr.
    }

<sup>*Usado em um contexto inseguro.*</sup>


<h3>Tamanho fixo da matriz</h3>

    unsafe struct Example
    {
        public fixed byte SomeField[8];
        public fixed char AnotherField[64];
    }

`fixed` só pode ser usado em campos em uma `struct` (deve ser usado também em um contexto não seguro).


## predefinição
Para classes, interfaces, delegate, array, nullable (como int?) e tipos de ponteiro, `default(TheType)` retorna `null`:

    class MyClass {}
    Debug.Assert(default(MyClass) == null);
    Debug.Assert(default(string) == null);

Para structs e enums, `default(TheType)` retorna o mesmo que `new TheType()`:

    struct Coordinates
    {
        public int X { get; set; }
        public int Y { get; set; }
    }

    struct MyStruct
    {
        public string Name { get; set; }
        public Coordinates Location { get; set; }
        public Coordinates? SecondLocation { get; set; }
        public TimeSpan Duration { get; set; }
    }

    var defaultStruct = default(MyStruct);
    Debug.Assert(defaultStruct.Equals(new MyStruct()));
    Debug.Assert(defaultStruct.Location.Equals(new Coordinates()));
    Debug.Assert(defaultStruct.Location.X == 0);
    Debug.Assert(defaultStruct.Location.Y == 0);
    Debug.Assert(defaultStruct.SecondLocation == null);
    Debug.Assert(defaultStruct.Name == null);
    Debug.Assert(defaultStruct.Duration == TimeSpan.Zero);

`default(T)` pode ser particularmente útil quando `T` é um parâmetro genérico para o qual nenhuma restrição está presente para decidir se `T` é um tipo de referência ou um tipo de valor, por exemplo:

    public T GetResourceOrDefault<T>(string resourceName)
    {
       if (ResourceExists(resourceName))
       {
          return (T)GetResource(resourceName);
       }
       else
       {
          return default(T);
       }
    }

## é
Verifica se um objeto é compatível com um determinado tipo, ou seja, se um objeto é uma instância do tipo `BaseInterface` ou um tipo que deriva de `BaseInterface`:

    interface BaseInterface {}
    class BaseClass : BaseInterface {}
    class DerivedClass : BaseClass {}

    var d = new DerivedClass();
    Console.WriteLine(d is DerivedClass);  // True
    Console.WriteLine(d is BaseClass);     // True
    Console.WriteLine(d is BaseInterface); // True
    Console.WriteLine(d is object);        // True
    Console.WriteLine(d is string);        // False
    
    var b = new BaseClass();
    Console.WriteLine(b is DerivedClass);  // False
    Console.WriteLine(b is BaseClass);     // True
    Console.WriteLine(b is BaseInterface); // True
    Console.WriteLine(b is object);        // True
    Console.WriteLine(b is string);        // False

Se a intenção da conversão for usar o objeto, é uma prática recomendada usar a palavra-chave [`as`](https://www.wikiod.com/pt/docs/c%23/26/keywords/138/as)'

    interface BaseInterface {}
    class BaseClass : BaseInterface {}
    class DerivedClass : BaseClass {}

    var d = new DerivedClass();
    Console.WriteLine(d is DerivedClass);  // True - valid use of 'is'
    Console.WriteLine(d is BaseClass);     // True - valid use of 'is'
    
    if(d is BaseClass){
        var castedD = (BaseClass)d;
        castedD.Method(); // valid, but not best practice
    }

    var asD = d as BaseClass;

    if(asD!=null){
        asD.Method(); //prefered method since you incur only one unboxing penalty
    }

Mas, a partir do C# 7 [`pattern matching`](https://www.wikiod.com/pt/docs/c%23/1936/c-sharp-7-0-features/13323/pattern-matching#t=201707130940065371224) o recurso se estende o operador is para verificar um tipo e declarar uma nova variável ao mesmo tempo. Mesma parte de código com C# 7 :

<!-- if versão [gte 7.0] -->

    if(d is BaseClass asD ){
        asD.Method();
    }
<!-- versão final if -->

## selado
Quando aplicado a uma classe, o modificador `sealed` impede que outras classes herdem dela.

    class A { }
    sealed class B : A { }
    class C : B { } //error : Cannot derive from the sealed class

Quando aplicado a um método `virtual` (ou propriedade virtual), o modificador `sealed` impede que este método (propriedade) seja *substituído* em classes derivadas.

    public class A 
    {
        public sealed override string ToString() // Virtual method inherited from class Object
        {
            return "Do not override me!";
        }
    }

    public class B: A 
    {
        public override string ToString() // Compile time error
        { 
            return "An attempt to override"; 
        }
    }

## somente leitura
A palavra-chave `readonly` é um modificador de campo. Quando uma declaração de campo inclui um modificador `readonly`, as atribuições a esse campo só podem ocorrer como parte da declaração ou em um construtor na mesma classe.

A palavra-chave `readonly` é diferente da palavra-chave `const`. Um campo `const` só pode ser inicializado na declaração do campo. Um campo `readonly` pode ser inicializado na declaração ou em um construtor. Portanto, campos `readonly` podem ter valores diferentes dependendo do construtor usado.

A palavra-chave `readonly` é frequentemente usada ao injetar dependências.

    class Person
    {
        readonly string _name;
        readonly string _surname = "Surname";

        Person(string name)
        {
            _name = name;
        }
        void ChangeName()
        {
            _name = "another name"; // Compile error
            _surname = "another surname"; // Compile error
        }
    }


> Nota: Declarar um campo *readonly* não implica em *imutabilidade*. Se o campo for um *tipo de referência*, o **conteúdo** do objeto poderá ser alterado. *Somente leitura* é normalmente usado para evitar que o objeto seja **substituído** e atribuído apenas durante a **instanciação** desse objeto.

> Nota: Dentro do construtor, um campo somente leitura pode ser reatribuído

    public class Car
    {
        public double Speed {get; set;}
    }

    //In code

    private readonly Car car = new Car();

    private void SomeMethod()
    {
        car.Speed = 100;
    }

## tipo de
Retorna o `Type` de um objeto, sem a necessidade de instanciá-lo.

    Type type = typeof(string);
    Console.WriteLine(type.FullName); //System.String
    Console.WriteLine("Hello".GetType() == type); //True
    Console.WriteLine("Hello".GetType() == typeof(string)); //True

## isto
A palavra-chave `this` refere-se à instância atual de class(object). Dessa forma, duas variáveis ​​com o mesmo nome, uma no nível de classe (um campo) e outra sendo um parâmetro (ou variável local) de um método, podem ser distinguidas.
    
    public MyClass {
        int a;
    
        void set_a(int a)
        {
            //this.a refers to the variable defined outside of the method,
            //while a refers to the passed parameter.
            this.a = a;
        }
    }

Outros usos da palavra-chave são [encadeamento de sobrecargas de construtor não estático][1]:

    public MyClass(int arg) : this(arg, null)
    {
    }

e escrevendo [indexadores][2]:

    public string this[int idx1, string idx2]
    {
        get { /* ... */ }
        set { /* ... */ }
    }

e declarando [métodos de extensão][3]:

    public static int Count<TItem>(this IEnumerable<TItem> source)
    {
        // ...
    }

Se não houver conflito com uma variável ou parâmetro local, é uma questão de estilo usar `this` ou não, então `this.MemberOfType` e `MemberOfType` seriam equivalentes nesse caso. Veja também a palavra-chave [`base`][4].

Observe que se um método de extensão deve ser chamado na instância atual, `this` é obrigatório. Por exemplo, se você está dentro de um método não estático de uma classe que implementa `IEnumerable<>` e deseja chamar a extensão `Count` de antes, você deve usar:

    this.Count()  // works like StaticClassForExtensionMethod.Count(this)

e `this` não pode ser omitido lá.


[1]: https://www.wikiod.com/pt/docs/c%23/25/constructors-destructors/56/calling-a-constructor-from-another-constructor#t=201607231911138150753
[2]: https://www.wikiod.com/pt/docs/c%23/1660/indexer#t=201607252101420586035
[3]: https://www.wikiod.com/pt/docs/c%23/20/extension-methods#t=20160723191025670507
[4]: https://www.wikiod.com/pt/docs/c%23/26/keywords/1840/base#t=201607261455204441752

## para cada
`foreach` é usado para iterar sobre os elementos de um array ou os itens dentro de uma coleção que implementa [`IEnumerable`][3]✝.

    var lines = new string[] { 
        "Hello world!", 
        "How are you doing today?", 
        "Goodbye"
    };

    foreach (string line in lines)
    {
        Console.WriteLine(line);
    }

Isso vai sair

> "Olá mundo!"
> "Como você está hoje?"
> "Adeus"

[Demonstração ao vivo no .NET Fiddle](https://dotnetfiddle.net/0jy78m)

Você pode sair do loop `foreach` a qualquer momento usando a palavra-chave [break][1] ou passar para a próxima iteração usando a palavra-chave [continue][2].

    var numbers = new int[] {1, 2, 3, 4, 5, 6};

    foreach (var number in numbers)
    {
        // Skip if 2
        if (number == 2)
            continue;

        // Stop iteration if 5
        if (number == 5)
            break;

        Console.Write(number + ", ");
    }

    // Prints: 1, 3, 4, 

[Demonstração ao vivo no .NET Fiddle](https://dotnetfiddle.net/dfSAbF)

Observe que a ordem de iteração é garantida *somente* para determinadas coleções, como arrays e `List`, mas **não** garantida para muitas outras coleções.

----------

✝ Enquanto `IEnumerable` é normalmente usado para indicar coleções enumeráveis, `foreach` requer apenas que a coleção exponha publicamente o método `object GetEnumerator()`, que deve retornar um objeto que exponha o método `bool MoveNext()` e o método ` objeto Atual { get; }` propriedade.

[1]: https://www.wikiod.com/pt/docs/c%23/26/keywords/2858/break
[2]: https://www.wikiod.com/pt/docs/c%23/26/keywords/154/continue
[3]: https://msdn.microsoft.com/en-us/library/system.collections.ienumerable(v=vs.110).aspx

## dinâmico
A palavra-chave `dynamic` é usada com [objetos tipados dinamicamente][1]. Objetos declarados como `dinâmicos` dispensam verificações estáticas em tempo de compilação e são avaliados em tempo de execução.

    using System;
    using System.Dynamic;
    
    dynamic info = new ExpandoObject();
    info.Id = 123;
    info.Another = 456;
    
    Console.WriteLine(info.Another);
    // 456
    
    Console.WriteLine(info.DoesntExist);
    // Throws RuntimeBinderException

O exemplo a seguir usa `dynamic` com a biblioteca Json.NET da Newtonsoft, para ler facilmente os dados de um arquivo JSON desserializado.

    try
    {
        string json = @"{ x : 10, y : ""ho""}";
        dynamic deserializedJson = JsonConvert.DeserializeObject(json);
        int x = deserializedJson.x;
        string y = deserializedJson.y;
        // int z = deserializedJson.z; // throws RuntimeBinderException
    }
    catch (RuntimeBinderException e)
    {
        // This exception is thrown when a property
        // that wasn't assigned to a dynamic variable is used
    }

[1]: https://www.wikiod.com/pt/docs/c%23/762/dynamic-type#t=201607212330428041437

Existem algumas limitações associadas à palavra-chave dinâmica. Um deles é o uso de métodos de extensão. O exemplo a seguir adiciona um método de extensão para string: `SayHello`.

    static class StringExtensions
    {
        public static string SayHello(this string s) => $"Hello {s}!";
    }

A primeira abordagem será chamá-lo como de costume (como para uma string):

    var person = "Person";
    Console.WriteLine(person.SayHello());

    dynamic manager = "Manager";
    Console.WriteLine(manager.SayHello()); // RuntimeBinderException

Nenhum erro de compilação, mas em tempo de execução você recebe um `RuntimeBinderException`. A solução para isso será chamar o método de extensão por meio da classe estática:

    var helloManager = StringExtensions.SayHello(manager);
    Console.WriteLine(helloManager);

## tente, pegue, finalmente, jogue
`try`, `catch`, `finally` e `throw` permitem que você lide com exceções em seu código.

    var processor = new InputProcessor();

    // The code within the try block will be executed. If an exception occurs during execution of
    // this code, execution will pass to the catch block corresponding to the exception type.
    try 
    {
        processor.Process(input);
    }
    // If a FormatException is thrown during the try block, then this catch block
    // will be executed.
    catch (FormatException ex)
    {
        // Throw is a keyword that will manually throw an exception, triggering any catch block that is
        // waiting for that exception type. 
        throw new InvalidOperationException("Invalid input", ex);
    }
    // catch can be used to catch all or any specific exceptions. This catch block,
    // with no type specified, catches any exception that hasn't already been caught
    // in a prior catch block.
    catch
    {
        LogUnexpectedException(); 
        throw; // Re-throws the original exception.
    }
    // The finally block is executed after all try-catch blocks have been; either after the try has
    // succeeded in running all commands or after all exceptions have been caught. 
    finally
    {
        processor.Dispose();
    }

**Nota:** A palavra-chave `return` pode ser usada no bloco `try`, e o bloco `finally` ainda será executado (logo antes de retornar). Por exemplo:

    try 
    {
        connection.Open();
        return connection.Get(query);
    } 
    finally 
    {
        connection.Close();
    }
 
A instrução `connection.Close()` será executada antes que o resultado de `connection.Get(query)` seja retornado.

## namespace
A palavra-chave `namespace` é uma construção de organização que nos ajuda a entender como uma base de código é organizada. Namespaces em C# são espaços virtuais em vez de estarem em uma pasta física.

    namespace StackOverflow
    {
        namespace Documentation
        {
            namespace CSharp.Keywords
            {
                public class Program
                {
                    public static void Main()
                    {
                        Console.WriteLine(typeof(Program).Namespace);
                        //StackOverflow.Documentation.CSharp.Keywords
                    }
                }
            }
        }
    }

Namespaces em C# também podem ser escritos em sintaxe encadeada. O seguinte é equivalente ao acima:

    namespace StackOverflow.Documentation.CSharp.Keywords
    {
        public class Program
        {
            public static void Main()
            {
                Console.WriteLine(typeof(Program).Namespace);
                //StackOverflow.Documentation.CSharp.Keywords
            }
        }
    }

## vazio
A palavra reservada `"void"` é um alias do tipo `System.Void` e tem dois usos:

1. Declare um método que não tem valor de retorno:


    public void DoSomething()
    {
        // Do some work, don't return any value to the caller.
    }

Um método com um tipo de retorno void ainda pode ter a palavra-chave `return` em seu corpo. Isso é útil quando você deseja sair da execução do método e retornar o fluxo para o chamador:

    public void DoSomething()
    {
        // Do some work...

        if (condition)
            return;

        // Do some more work if the condition evaluated to false.
    }

2. Declare um ponteiro para um tipo desconhecido em um contexto não seguro.

Em um contexto não seguro, um tipo pode ser um tipo de ponteiro, um tipo de valor ou um tipo de referência. Uma declaração de tipo de ponteiro geralmente é `type* identifier`, onde o tipo é um tipo conhecido - ou seja, `int* myInt`, mas também pode ser `void* identifier`, onde o tipo é desconhecido.

Observe que declarar um tipo de ponteiro nulo é [desencorajado pela Microsoft.][1]


[1]: https://msdn.microsoft.com/en-us/library/y31yhkeb.aspx

## ref, fora
As palavras-chave `ref` e `out` fazem com que um argumento seja passado por referência, não por valor. Para tipos de valor, isso significa que o valor da variável pode ser alterado pelo chamado.

    int x = 5;
    ChangeX(ref x);
    // The value of x could be different now

Para tipos de referência, a instância na variável pode não apenas ser modificada (como é o caso sem `ref`), mas também pode ser substituída completamente:

    Address a = new Address();
    ChangeFieldInAddress(a);
    // a will be the same instance as before, even if it is modified
    CreateANewInstance(ref a);
    // a could be an entirely new instance now

A principal diferença entre as palavras-chave `out` e `ref` é que `ref` requer que a variável seja inicializada pelo chamador, enquanto `out` passa essa responsabilidade para o chamador.

Para usar um parâmetro `out`, tanto a definição do método quanto o método de chamada devem usar explicitamente a palavra-chave `out`.

    int number = 1;
    Console.WriteLine("Before AddByRef: " + number); // number = 1
    AddOneByRef(ref number);
    Console.WriteLine("After AddByRef: " + number);  // number = 2
    SetByOut(out number);
    Console.WriteLine("After SetByOut: " + number);  // number = 34

    void AddOneByRef(ref int value)
    {
        value++;
    }
    
    void SetByOut(out int value)
    {
        value = 34;
    }

[<kbd>Demonstração ao vivo no .NET Fiddle</kbd>](https://dotnetfiddle.net/ma2ikc)
    
O seguinte *não* compila, porque os parâmetros `out` devem ter um valor atribuído antes que o método retorne (ele compilaria usando `ref`):

    void PrintByOut(out int value)
    {
        Console.WriteLine("Hello!");
    }

**usando a palavra-chave como modificador genérico**

A palavra-chave `out` também pode ser usada em parâmetros de tipo genérico ao definir interfaces e delegados genéricos. Nesse caso, a palavra-chave `out` especifica que o parâmetro de tipo é covariante.

> A covariância permite que você use um tipo mais derivado do que o especificado pelo parâmetro genérico. Isso permite a conversão implícita de classes que implementam interfaces variantes e a conversão implícita de tipos delegados. Covariância e contravariância têm suporte para tipos de referência, mas não têm suporte para tipos de valor. - MSDN

    //if we have an interface like this
    interface ICovariant<out R> { }
    
    //and two variables like
    ICovariant<Object> iobj = new Sample<Object>();
    ICovariant<String> istr = new Sample<String>();

    // then the following statement is valid
    // without the out keyword this would have thrown error
    iobj = istr; // implicit conversion occurs here
   

## base
A palavra-chave **`base`** é usada para acessar membros de uma classe base. É comumente usado para chamar implementações de base de métodos virtuais ou para especificar qual construtor de base deve ser chamado.

**Escolhendo um construtor**

    public class Child : SomeBaseClass {
        public Child() : base("some string for the base class")
        {
        }
    }

    public class SomeBaseClass {
        public SomeBaseClass()
        {
            // new Child() will not call this constructor, as it does not have a parameter
        }
        public SomeBaseClass(string message)
        {
            // new Child() will use this base constructor because of the specified parameter in Child's constructor
            Console.WriteLine(message);
        }
    }

**Implementação base de chamada do método virtual**

    public override void SomeVirtualMethod() {
        // Do something, then call base implementation
        base.SomeVirtualMethod();
    }

É possível usar a palavra-chave base para chamar uma implementação base de qualquer método. Isso vincula a chamada de método diretamente à implementação base, o que significa que, mesmo que novas classes filhas substituam um método virtual, a implementação base ainda será chamada, portanto, isso precisa ser usado com cautela.

    public class Parent
    {
        public virtual int VirtualMethod()
        {
            return 1;
        }
    }

    public class Child : Parent
    {
        public override int VirtualMethod() {
            return 11;
        }

        public int NormalMethod()
        {
            return base.VirtualMethod();
        }

        public void CallMethods()
        {
            Assert.AreEqual(11, VirtualMethod());

            Assert.AreEqual(1, NormalMethod());
            Assert.AreEqual(1, base.VirtualMethod());
        }
    }

    public class GrandChild : Child
    {
        public override int VirtualMethod()
        {
            return 21;
        }

        public void CallAgain()
        {
            Assert.AreEqual(21, VirtualMethod());
            Assert.AreEqual(11, base.VirtualMethod());

            // Notice that the call to NormalMethod below still returns the value
            // from the extreme base class even though the method has been overridden
            // in the child class.
            Assert.AreEqual(1, NormalMethod());
        }
    }



## parâmetros
`params` permite que um parâmetro de método receba um número variável de argumentos, ou seja, zero, um ou vários argumentos são permitidos para esse parâmetro.

    static int AddAll(params int[] numbers)
    {
        int total = 0;
        foreach (int number in numbers)
        {
            total += number;
        }
        
        return total;
    }

Este método agora pode ser chamado com uma lista típica de argumentos `int` ou um array de ints.

    AddAll(5, 10, 15, 20);                // 50
    AddAll(new int[] { 5, 10, 15, 20 });  // 50

`params` deve aparecer no máximo uma vez e, se usado, deve ser **último** na lista de argumentos, mesmo que o tipo seguinte seja diferente daquele do array.

----

Tenha cuidado ao sobrecarregar funções ao usar a palavra-chave `params`. C# prefere combinar sobrecargas mais específicas antes de tentar usar sobrecargas com `params`. Por exemplo, se você tiver dois métodos:

    static double Add(params double[] numbers)
    {
        Console.WriteLine("Add with array of doubles");
        double total = 0.0;
        foreach (double number in numbers)
        {
            total += number;
        }
        
        return total;
    }

    static int Add(int a, int b)
    {
        Console.WriteLine("Add with 2 ints");
        return a + b;
    }

Então a sobrecarga específica de 2 argumentos terá precedência antes de tentar a sobrecarga `params`.

    Add(2, 3);      //prints "Add with 2 ints"
    Add(2, 3.0);    //prints "Add with array of doubles" (doubles are not ints)
    Add(2, 3, 4);   //prints "Add with array of doubles" (no 3 argument overload)


## float, double, decimal
# flutua #

`float` é um alias para o tipo de dados .NET `System.Single`. Ele permite que números de ponto flutuante de precisão simples IEEE 754 sejam armazenados. Este tipo de dados está presente em `mscorlib.dll` que é referenciado implicitamente por cada projeto C# quando você os cria.

Faixa aproximada: -3,4 × 10<sup>38</sup> a 3,4 × 10<sup>38</sup>

Precisão decimal: 6-9 dígitos significativos

**Notação**:

    float f = 0.1259;
    var f1 = 0.7895f; // f is literal suffix to represent float values 

> Deve-se notar que o tipo `float` muitas vezes resulta em
> erros de arredondamento. Em aplicações onde a precisão é importante, outros
> tipos de dados devem ser considerados.


----------
# em dobro #

`double` é um alias para o tipo de dados .NET `System.Double`. Ele representa um número de ponto flutuante de 64 bits de precisão dupla. Este tipo de dados está presente em `mscorlib.dll` que é referenciado implicitamente em qualquer projeto C#.

Faixa: ±5,0 × 10<sup>−324</sup> a ±1,7 × 10<sup>308</sup>

Precisão decimal: 15-16 dígitos significativos

**Notação**:

    double distance = 200.34; // a double value
    double salary = 245; // an integer implicitly type-casted to double value
    var marks = 123.764D; // D is literal suffix to represent double values

----------
# decimal #

`decimal` é um alias para o tipo de dados .NET `System.Decimal`. Ele representa uma palavra-chave indica um tipo de dados de 128 bits. Comparado aos tipos de ponto flutuante, o tipo decimal tem mais precisão e um intervalo menor, o que o torna apropriado para cálculos financeiros e monetários. Este tipo de dados está presente em `mscorlib.dll` que é referenciado implicitamente em qualquer projeto C#.

Faixa: -7,9 × 10<sup>28</sup> a 7,9 × 10<sup>28</sup>

Precisão decimal: 28-29 dígitos significativos

**Notação**:

    decimal payable = 152.25m; // a decimal value
    var marks = 754.24m; // m is literal suffix to represent decimal values

## Caracteres
Um char é uma única letra armazenada dentro de uma variável. É um tipo de valor interno que ocupa dois bytes de espaço de memória. Ele representa o tipo de dados `System.Char` encontrado em `mscorlib.dll` que é referenciado implicitamente por cada projeto C# quando você os cria.

Existem várias maneiras de fazer isso.
1) `char c = 'c';`
2) `char c = '\u0063'; //Unicode`
3) `char c = '\x0063'; //Hex`
4) `char c = (char)99;//Integral`

Um caractere pode ser convertido implicitamente em `ushort, int, uint, long, ulong, float, double,` ou `decimal` e retornará o valor inteiro desse caractere.

    ushort u = c;
retorna 99 etc.

No entanto, não há conversões implícitas de outros tipos para char. Em vez disso, você deve lançá-los.
 

    ushort u = 99;
     char c = (char)u;



## operador
A maioria dos [operadores internos][OPERATORS] (incluindo operadores de conversão) podem ser sobrecarregados usando a palavra-chave `operator` junto com os modificadores `public` e `static`.

Os operadores vêm em três formas: operadores unários, operadores binários e operadores de conversão.

Operadores unários e binários requerem pelo menos um parâmetro do mesmo tipo que o tipo que os contém, e alguns requerem um operador de correspondência complementar.

Os operadores de conversão devem converter de ou para o tipo de inclusão.

    public struct Vector32
    {
        
        public Vector32(int x, int y)
        {
            X = x;
            Y = y;
        }
        
        public int X { get; }
        public int Y { get; }

        public static bool operator ==(Vector32 left, Vector32 right)
            => left.X == right.X && left.Y == right.Y;

        public static bool operator !=(Vector32 left, Vector32 right)
            => !(left == right);

        public static Vector32 operator +(Vector32 left, Vector32 right)
            => new Vector32(left.X + right.X, left.Y + right.Y);

        public static Vector32 operator +(Vector32 left, int right)
            => new Vector32(left.X + right, left.Y + right);

        public static Vector32 operator +(int left, Vector32 right)
            => right + left;

        public static Vector32 operator -(Vector32 left, Vector32 right)
            => new Vector32(left.X - right.X, left.Y - right.Y);

        public static Vector32 operator -(Vector32 left, int right)
            => new Vector32(left.X - right, left.Y - right);

        public static Vector32 operator -(int left, Vector32 right)
            => right - left;

        public static implicit operator Vector64(Vector32 vector)
            => new Vector64(vector.X, vector.Y);

        public override string ToString() => $"{{{X}, {Y}}}";

    }

    public struct Vector64
    {

        public Vector64(long x, long y)
        {
            X = x;
            Y = y;
        }

        public long X { get; }
        public long Y { get; }

        public override string ToString() => $"{{{X}, {Y}}}";

    }

**Exemplo**

    var vector1 = new Vector32(15, 39);
    var vector2 = new Vector32(87, 64);
            
    Console.WriteLine(vector1 == vector2); // false
    Console.WriteLine(vector1 != vector2); // true
    Console.WriteLine(vector1 + vector2);  // {102, 103}
    Console.WriteLine(vector1 - vector2);  // {-72, -25}

[OPERADORES]: https://msdn.microsoft.com/en-us/library/6a71f45d.aspx

## Prosseguir
Passe imediatamente o controle para a próxima iteração da construção de loop envolvente (for, foreach, do, while):

    for (var i = 0; i < 10; i++)
    {
        if (i < 5)
        {
            continue;
        }
        Console.WriteLine(i);
    }

Resultado:

> 5
> 6
> 7
> 8
> 9

[<kbd>Demonstração ao vivo no .NET Fiddle</kbd>](https://dotnetfiddle.net/H2NB0V)

    var stuff = new [] {"a", "b", null, "c", "d"};

    foreach (var s in stuff)
    {
        if (s == null)
        {
            continue;
        }           
        Console.WriteLine(s);
    }

Resultado:

> um
> b
> c
> d

[Demonstração ao vivo no .NET Fiddle](https://dotnetfiddle.net/l1JPiI)

## enquanto
O operador `while` itera sobre um bloco de código até que a consulta condicional seja igual a false ou o código seja interrompido com um [`goto`](https://www.wikiod.com/pt/docs/c%23/26/keywords/193/ goto), [`return`](https://www.wikiod.com/pt/docs/c%23/26/keywords/4600/return), [`break`](https://www.wikiod.com/pt/docs/c% 23/26/keywords/2858/break) ou instrução `throw`.

Sintaxe para a palavra-chave `while`:

> while( *condição* )
> { *bloco de código;* }

Exemplo:

    int i = 0;
    while (i++ < 5)
    {
        Console.WriteLine("While is on loop number {0}.", i);
    }

Resultado:

>"Enquanto está no loop número 1." \
"Enquanto está no loop número 2."\
"Enquanto está no loop número 3."\
"Enquanto está no loop número 4."\
"Enquanto está no loop número 5."

[<kbd>Demonstração ao vivo no .NET Fiddle</kbd>](https://dotnetfiddle.net/KRQjV0)

Um loop while é **Controlado por Entrada**, pois a condição é verificada **antes** da execução do bloco de código incluído. Isso significa que o loop while não executaria suas instruções se a condição fosse falsa.

    bool a = false;
    
    while (a == true)
    {
        Console.WriteLine("This will never be printed.");
    }

Dar uma condição `while` sem provisioná-la para se tornar falsa em algum ponto resultará em um loop infinito ou sem fim. Na medida do possível, isso deve ser evitado, no entanto, pode haver algumas circunstâncias excepcionais quando você precisar disso.

Você pode criar um loop assim:

    while (true)
    {
    //...
    }

Observe que o compilador C# transformará loops como

    while (true)
    {
    // ...
    }

ou

    for(;;)
    {
    // ...
    }

em

    {
    :label
    // ...
    goto label;
    }

Observe que um loop while pode ter qualquer condição, não importa quão complexo, desde que avalie (ou retorne) um valor booleano (bool). Ele também pode conter uma função que retorna um valor booleano (como tal função avalia o mesmo tipo que uma expressão como `a==x'). Por exemplo,

    while (AgriculturalService.MoreCornToPick(myFarm.GetAddress()))
    {
        myFarm.PickCorn();
    }

## Retorna
> MSDN: A instrução return encerra a execução do método no qual
> ele aparece e retorna o controle para o método de chamada. Também pode
> retorna um valor opcional. Se o método for do tipo void, o retorno
> declaração pode ser omitida.

    public int Sum(int valueA, int valueB)
    {
        return valueA + valueB;
    }

    
    public void Terminate(bool terminateEarly)
    {
        if (terminateEarly) return; // method returns to caller if true was passed in
        else Console.WriteLine("Not early"); // prints only if terminateEarly was false
    }

## nulo
Uma variável de um tipo de referência pode conter uma referência válida a uma instância ou uma referência nula. A referência nula é o valor padrão de variáveis ​​de tipo de referência, bem como tipos de valor anuláveis.

`null` é a palavra-chave que representa uma referência nula.

Como expressão, pode ser usado para atribuir a referência nula a variáveis ​​dos tipos mencionados:

    object a = null;
    string b = null;
    int? c = null;
    List<int> d  = null;

Os tipos de valor não anuláveis ​​não podem receber uma referência nula. Todas as atribuições a seguir são inválidas:

    int a = null; 
    float b = null;
    decimal c = null;

A referência nula *não* deve ser confundida com instâncias válidas de vários tipos, como:

- uma lista vazia (`new List<int>()`)
- uma string vazia (`""`)
- o número zero (`0`, `0f`, `0m`)
- o caractere nulo ( `'\0'` )

Às vezes, é significativo verificar se algo é nulo ou um objeto vazio/padrão. O método System.String.IsNullOrEmpty(String) pode ser usado para verificar isso, ou você pode implementar seu próprio método equivalente.

    private void GreetUser(string userName)
    {
        if (String.IsNullOrEmpty(userName))
        {
            //The method that called us either sent in an empty string, or they sent us a null reference. Either way, we need to report the problem.
            throw new InvalidOperationException("userName may not be null or empty.");
        }
        else
        {
            //userName is acceptable.
            Console.WriteLine("Hello, " + userName + "!");
        }
    }

## corda
`string` é um alias para o tipo de dados .NET `System.String`, que permite o armazenamento de texto (sequências de caracteres).

Notação:

    string a = "Hello";
    var b = "world";
    var f = new string(new []{ 'h', 'i', '!' }); // hi!

Cada caractere na string é codificado em UTF-16, o que significa que cada caractere exigirá um mínimo de 2 bytes de espaço de armazenamento.

## uint
Um **inteiro sem sinal**, ou **uint**, é um tipo de dados numérico que só pode conter inteiros positivos. Como o nome sugere, representa um inteiro de 32 bits sem sinal. A palavra-chave **uint** em si é um alias para o tipo Common Type System `System.UInt32`. Este tipo de dados está presente em `mscorlib.dll`, que é referenciado implicitamente por cada projeto C# quando você os cria. Ocupa quatro bytes de espaço de memória.

Inteiros sem sinal podem conter qualquer valor de 0 a 4.294.967.295.


*Exemplos de como e agora não declarar inteiros não assinados*

    uint i = 425697; // Valid expression, explicitly stated to compiler
    var i1 = 789247U; // Valid expression, suffix allows compiler to determine datatype
    uint x = 3.0; // Error, there is no implicit conversion

----------

**Observação:** De acordo com [Microsoft][1], é recomendável usar o tipo de dados **[int][2]** sempre que possível, pois o tipo de dados **uint** não é compatível com CLS.


[1]: https://msdn.microsoft.com/en-us/library/x0sksh43.aspx
[2]: https://www.wikiod.com/pt/docs/c%23/26/keywords#t=201608192209189084166

## usando
Existem dois tipos de uso da palavra-chave `using`, `using statement` e `using Directive`:

1. **instrução de uso**:

    The `using` keyword ensures that objects that implement the `IDisposable` interface are properly disposed after usage. There is a separate topic for the [using statement][1]
    
2. **usando diretiva**

A diretiva `using` tem três usos, veja a [página do msdn para a diretiva using][2]. Há um tópico separado para a [diretiva using][3].


[1]: https://www.wikiod.com/pt/docs/c%23/38/using-statement#t=201607311905386691069
[2]: https://msdn.microsoft.com/en-us/library/sf0df423.aspx
[3]: https://www.wikiod.com/pt/docs/c%23/52/using-directive#t=201607311908368095223

## estático
O modificador `static` é usado para declarar um membro estático, que não precisa ser instanciado para ser acessado, mas é acessado simplesmente através de seu nome, ou seja, `DateTime.Now`.

`static` pode ser usado com classes, campos, métodos, propriedades, operadores, eventos e construtores.

Enquanto uma instância de uma classe contém uma cópia separada de todos os campos de instância da classe, há apenas uma cópia de cada campo estático.

    class A
    {
        static public int count = 0;

        public A()
        {
            count++;
        }
    }

    class Program
    {
        static void Main(string[] args)
        {
            A a = new A();
            A b = new A();
            A c = new A();

            Console.WriteLine(A.count); // 3 
        }
    }

`count` é igual ao número total de instâncias da classe `A`.

O modificador static também pode ser usado para declarar um construtor estático para uma classe, para inicializar dados estáticos ou executar código que só precisa ser chamado uma vez. Construtores estáticos são chamados antes que a classe seja referenciada pela primeira vez.

    class A
    {
        static public DateTime InitializationTime;

        // Static constructor
        static A()
        {
            InitializationTime = DateTime.Now;
            // Guaranteed to only run once
            Console.WriteLine(InitializationTime.ToString());
        }
    }

Uma `classe estática` é marcada com a palavra-chave `estática` e pode ser usada como um recipiente benéfico para um conjunto de métodos que funcionam em parâmetros, mas não exigem necessariamente estar vinculados a uma instância. Por causa da natureza `static` da classe, ela não pode ser instanciada, mas pode conter um `construtor estático`. Alguns recursos de uma `classe estática` incluem:

- Não pode ser herdado
- Não pode herdar de nada além de `Object`
- Pode conter um construtor estático, mas não um construtor de instância
- Só pode conter membros estáticos
- Está selado

O compilador também é amigável e informará ao desenvolvedor se existem membros de instância dentro da classe. Um exemplo seria uma classe estática que converte entre métricas dos EUA e do Canadá:

    static class ConversionHelper {
        private static double oneGallonPerLitreRate = 0.264172;

        public static double litreToGallonConversion(int litres) {
            return litres * oneGallonPerLitreRate;
        }
    }

Quando as classes são declaradas estáticas:

    public static class Functions
    {
      public static int Double(int value)
      {
        return value + value;
      }
    }

todas as funções, propriedades ou membros dentro da classe também precisam ser declarados como estáticos. Nenhuma instância da classe pode ser criada.
Em essência, uma classe estática permite que você crie pacotes de funções que são agrupadas logicamente.

Como o C#6 `static` também pode ser usado junto com `using` para importar membros e métodos estáticos. Eles podem ser usados ​​então sem nome de classe.

Maneira antiga, sem `usar static`:
  
    using System;

    public class ConsoleApplication
    {
        public static void Main()
        {
             Console.WriteLine("Hello World!"); //Writeline is method belonging to static class Console
        }

    }
Exemplo com `usando estático`

    using static System.Console;

    public class ConsoleApplication
    {
        public static void Main()
        {
             WriteLine("Hello World!"); //Writeline is method belonging to static class Console
        }

    }

**Desvantagens**
---------

Embora as classes estáticas possam ser incrivelmente úteis, elas vêm com suas próprias ressalvas:

• Após a chamada da classe estática, a classe é carregada na memória e não pode ser executada pelo coletor de lixo até que o AppDomain que contém a classe estática seja descarregado.

• Uma classe estática não pode implementar uma interface.

##int
`int` é um alias para `System.Int32`, que é um tipo de dados para inteiros de 32 bits assinados. Este tipo de dados pode ser encontrado em `mscorlib.dll` que é referenciado implicitamente por cada projeto C# quando você os cria.

Faixa: -2.147.483.648 a 2.147.483.647

    int int1 = -10007;
    var int2 = 2132012521;     

## cabeça
Palavra-chave usada para inteiros de 64 bits sem sinal. Ele representa o tipo de dados `System.UInt64` encontrado em `mscorlib.dll` que é referenciado implicitamente por cada projeto C# quando você os cria.

Faixa: 0 a 18.446.744.073.709.551.615

    ulong veryLargeInt = 18446744073609451315;
    var anotherVeryLargeInt = 15446744063609451315UL;

## trancar
`lock` fornece segurança de thread para um bloco de código, para que possa ser acessado por apenas um thread dentro do mesmo processo. Exemplo:

    private static object _lockObj = new object();
    static void Main(string[] args)
    {
        Task.Run(() => TaskWork());
        Task.Run(() => TaskWork());
        Task.Run(() => TaskWork());
    
        Console.ReadKey();
    }
    
    private static void TaskWork()
    {
        lock(_lockObj)
        {
            Console.WriteLine("Entered");
    
            Task.Delay(3000);
            Console.WriteLine("Done Delaying");
    
            // Access shared resources safely
    
            Console.WriteLine("Leaving");
        }   
    }
    
    Output:

    Entered
    Done Delaying
    Leaving
    Entered
    Done Delaying
    Leaving
    Entered
    Done Delaying
    Leaving

**Casos de uso:**

Sempre que você tiver um bloco de código que possa produzir efeitos colaterais se executado por vários threads ao mesmo tempo. A palavra-chave lock junto com um **objeto de sincronização compartilhado** (`_objLock` no exemplo) pode ser usado para evitar isso.

Observe que `_objLock` não pode ser `null` e vários threads executando o código devem usar a mesma instância de objeto (tornando-o um campo `static` ou usando a mesma instância de classe para ambos os threads)

Do lado do compilador, a palavra-chave lock é um açúcar sintático que é substituído por `Monitor.Enter(_lockObj);` e `Monitor.Exit(_lockObj);`. Portanto, se você substituir o bloqueio envolvendo o bloco de código com esses dois métodos, obterá os mesmos resultados. Você pode ver o código real em [açúcar sintático em C# - exemplo de bloqueio][1]


[1]: https://www.wikiod.com/pt/docs/c%23/2994/syntactic-sugar-in-c-sharp/10166/lock#t=20160723121800624366

## interno
A palavra-chave [`internal`][1] é um modificador de acesso para tipos e membros de tipo. Tipos ou membros internos são **acessíveis apenas em arquivos no mesmo assembly**

*uso:*

    public class BaseClass 
    {
        // Only accessible within the same assembly
        internal static int x = 0;
    }


A diferença entre diferentes modificadores de acesso é esclarecida [aqui][2]

***Modificadores de acesso***

> **público**

> > O tipo ou membro pode ser acessado por qualquer outro código no mesmo assembly ou outro assembly que faça referência a ele.

> **privado**

> > O tipo ou membro só pode ser acessado por código na mesma classe ou estrutura.

> **protegido**

> > O tipo ou membro só pode ser acessado por código na mesma classe ou estrutura, ou em uma classe derivada.

> **interno**

> > O tipo ou membro pode ser acessado por qualquer código no mesmo assembly, mas não de outro assembly.

> **interno protegido**

> > O tipo ou membro pode ser acessado por qualquer código no mesmo assembly ou por qualquer classe derivada em outro assembly.

Quando **sem modificador de acesso** é definido, um modificador de acesso padrão é usado. Portanto, sempre há alguma forma de modificador de acesso, mesmo que não esteja definido.


[1]: https://msdn.microsoft.com/en-us/library/7c5ka91b.aspx
[2]: http://stackoverflow.com/a/614844/266562

## Onde
`where` pode servir a dois propósitos em C#: restrição de tipo em um argumento genérico e filtragem de consultas LINQ.


Em uma classe genérica, vamos considerar

    public class Cup<T>
    {
        // ...
    }

T é chamado de parâmetro de tipo. A definição de classe pode impor restrições aos tipos reais que podem ser fornecidos para T.

Os seguintes tipos de restrições podem ser aplicados:

* tipo de valor
* tipo de referência
* construtor padrão
* herança e implementação

**tipo de valor**

Neste caso, apenas `struct`s (isso inclui tipos de dados 'primitivos' como `int`, `boolean` etc) podem ser fornecidos

    public class Cup<T> where T : struct
    {
        // ...
    }

**tipo de referência**

Neste caso, apenas os tipos de classe podem ser fornecidos

    public class Cup<T> where T : class
    {
        // ...
    }

**valor híbrido/tipo de referência**

Ocasionalmente, deseja-se restringir os argumentos de tipo àqueles disponíveis em um banco de dados, e eles geralmente serão mapeados para tipos de valor e strings. Como todas as restrições de tipo devem ser atendidas, não é possível especificar `where T : struct or string` (esta não é uma sintaxe válida). Uma solução alternativa é restringir os argumentos de tipo para [`IConvertible`][1] que possui tipos internos de "... Boolean, SByte, Byte, Int16, UInt16, Int32, UInt32, Int64, UInt64, Single, Double, Decimal, DateTime, Char e String." É possível que outros objetos implementem IConvertible, embora isso seja raro na prática.

    public class Cup<T> where T : IConvertible
    {
        // ...
    }

**construtor padrão**

Somente os tipos que contêm um construtor padrão serão permitidos. Isso inclui tipos de valor e classes que contêm um construtor padrão (sem parâmetros)


    public class Cup<T> where T : new
    {
        // ...
    }

**herança e implementação**

Apenas os tipos que herdam de uma determinada classe base ou implementam uma determinada interface podem ser fornecidos.


    public class Cup<T> where T : Beverage
    {
        // ...
    }


    public class Cup<T> where T : IBeer
    {
        // ...
    }


A restrição pode até referenciar outro parâmetro de tipo:

    public class Cup<T, U> where U : T
    {
        // ...
    }

Várias restrições podem ser especificadas para um argumento de tipo:

    public class Cup<T> where T : class, new()
    {
        // ...
    }

Os exemplos anteriores mostram restrições genéricas em uma definição de classe, mas as restrições podem ser usadas em qualquer lugar que um argumento de tipo seja fornecido: classes, structs, interfaces, métodos, etc.
---

`where` também pode ser uma cláusula LINQ. Neste caso é análogo a `WHERE` em SQL:

    int[] nums = { 5, 2, 1, 3, 9, 8, 6, 7, 2, 0 };

    var query =
        from num in nums 
        where num < 5
        select num;

        foreach (var n in query)
        {
            Console.Write(n + " ");
        }
        // prints 2 1 3 2 0


[1]: https://msdn.microsoft.com/en-us/library/system.iconvertible(v=vs.110).aspx

## externo
A palavra-chave `extern` é usada para declarar métodos que são implementados externamente. Isso pode ser usado em conjunto com o atributo DllImport para chamar código não gerenciado usando serviços de interoperabilidade. que neste caso virá com o modificador `static`

Por exemplo:

    using System.Runtime.InteropServices;
    public class MyClass
    {
        [DllImport("User32.dll")]
        private static extern int SetForegroundWindow(IntPtr point);
    
        public void ActivateProcessWindow(Process p)
        {
            SetForegroundWindow(p.MainWindowHandle);
        }
    }

Isso usa o método SetForegroundWindow importado da biblioteca User32.dll

Isso também pode ser usado para definir um alias de montagem externa. que nos permite referenciar diferentes versões dos mesmos componentes de uma única montagem.

Para fazer referência a dois assemblies com os mesmos nomes de tipo totalmente qualificados, um alias deve ser especificado em um prompt de comando, da seguinte maneira:

    /r:GridV1=grid.dll
    /r:GridV2=grid20.dll

Isso cria os aliases externos GridV1 e GridV2. Para usar esses aliases de dentro de um programa, faça referência a eles usando a palavra-chave extern. Por exemplo:

    extern alias GridV1;
    extern alias GridV2;


## quando
O `when` é uma palavra-chave adicionada em **C# 6** e é usada para filtragem de exceção.

Antes da introdução da palavra-chave `when`, você poderia ter uma cláusula catch para cada tipo de exceção; com a adição da palavra-chave, um controle mais refinado agora é possível.

Uma expressão `when` é anexada a um branch `catch`, e somente se a condição `when` for `true`, a cláusula `catch` será executada. É possível ter várias cláusulas `catch` com os mesmos tipos de classe de exceção e diferentes condições `when`.



    private void CatchException(Action action)
    {
        try
        {
            action.Invoke();
        }
        
        // exception filter
        catch (Exception ex) when (ex.Message.Contains("when"))
        {
            Console.WriteLine("Caught an exception with when");
        }
    
        catch (Exception ex)
        {
            Console.WriteLine("Caught an exception without when");
        }
    }

    private void Method1() { throw new Exception("message for exception with when"); }
    private void Method2() { throw new Exception("message for general exception"); }
    
    
    CatchException(Method1);
    CatchException(Method2);

## if, if... else, if... else if
----------


A instrução `if` é usada para controlar o fluxo do programa. Uma instrução `if` identifica qual instrução executar com base no valor de uma expressão `booleana`.

Para uma única instrução, as `chaves`{} são opcionais, mas recomendadas.

    int a = 4;
    if(a % 2 == 0) 
    {
         Console.WriteLine("a contains an even number");
    }
    // output: "a contains an even number"


----------


O `if` também pode ter uma cláusula `else`, que será executada caso a condição seja avaliada como falsa:

    int a = 5;
    if(a % 2 == 0) 
    {
         Console.WriteLine("a contains an even number");
    }
    else
    {
         Console.WriteLine("a contains an odd number");
    }
    // output: "a contains an odd number"


----------


A construção `if`...`else if` permite especificar várias condições:

    int a = 9;
    if(a % 2 == 0) 
    {
         Console.WriteLine("a contains an even number");
    }
    else if(a % 3 == 0) 
    {
         Console.WriteLine("a contains an odd number that is a multiple of 3"); 
    }
    else
    {
         Console.WriteLine("a contains an odd number");
    }
    // output: "a contains an odd number that is a multiple of 3"

*Importante observar* que, se uma condição for atendida no exemplo acima, o controle pulará outros testes e pulará para o final dessa construção if else específica. senão se construir
----------

Expressões booleanas C# usam [avaliação de curto-circuito][1]. Isso é importante nos casos em que as condições de avaliação podem ter efeitos colaterais:

    if (someBooleanMethodWithSideEffects() && someOtherBooleanMethodWithSideEffects()) {
      //...
    }
Não há garantia de que `someOtherBooleanMethodWithSideEffects` realmente será executado.

Também é importante nos casos em que as condições anteriores garantem que é "seguro" avaliar as posteriores. Por exemplo:

    if (someCollection != null && someCollection.Count > 0) {
       // ..
    }
A ordem é muito importante neste caso porque, se invertermos a ordem:

    if (someCollection.Count > 0 && someCollection != null) {
ele lançará um `NullReferenceException` se `someCollection` for `null`.

[1]: https://en.wikipedia.org/wiki/Short-circuit_evaluation

## estrutura
Um tipo `struct` é um tipo de valor que normalmente é usado para encapsular pequenos grupos de variáveis ​​relacionadas, como as coordenadas de um retângulo ou as características de um item em um inventário.

> [Classes][1] são tipos de referência, structs são tipos de valor.

    using static System.Console;
    
    namespace ConsoleApplication1
    {
        struct Point
        {
            public int X;
            public int Y;
    
            public override string ToString()
            {
                return $"X = {X}, Y = {Y}";
            }
    
            public void Display(string name)
            {
                WriteLine(name + ": " + ToString());
            }
        }
    
        class Program
        {
            static void Main()
            {
                var point1 = new Point {X = 10, Y = 20};
                // it's not a reference but value type
                var point2 = point1;
                point2.X = 777;
                point2.Y = 888;
                point1.Display(nameof(point1)); // point1: X = 10, Y = 20
                point2.Display(nameof(point2)); // point2: X = 777, Y = 888
    
                ReadKey();
            }
        }
    }

    
----------
Structs também podem conter construtores, constantes, campos, métodos, propriedades, indexadores, operadores, eventos e tipos aninhados, embora se vários desses membros forem necessários, você deve considerar tornar seu tipo uma classe.


----------


**Algumas [sugestões][2] do MS sobre quando usar struct e quando usar class:**

*CONSIDERAR*

definir uma estrutura em vez de uma classe se as instâncias do tipo forem pequenas e geralmente de curta duração ou forem incorporadas a outros objetos.

*EVITAR*

definindo uma estrutura, a menos que o tipo tenha todas as seguintes características:
 

- Representa logicamente um único valor, semelhante aos tipos primitivos
(int, duplo, etc.)
- Tem um tamanho de instância inferior a 16 bytes.
- É imutável.
- Não terá que ser encaixotado com freqüência.


[1]: http://stackoverflow.com/a/3924092/266562
[2]: https://msdn.microsoft.com/en-us/library/ms229017.aspx

## trocar
A instrução `switch` é uma instrução de controle que seleciona uma seção switch para executar a partir de uma lista de candidatos. Uma instrução switch inclui uma ou mais seções switch. Cada seção switch contém um ou mais rótulos `case` seguidos por uma ou mais instruções. Se nenhum rótulo de caso contiver um valor correspondente, o controle será transferido para a seção `default`, se houver. Caso fall-through não é suportado em C#, estritamente falando. No entanto, se 1 ou mais rótulos `case` estiverem vazios, a execução seguirá o código do próximo bloco `case` que contém código. Isso permite o agrupamento de vários rótulos `case` com a mesma implementação. No exemplo a seguir, se `month` for igual a 12, o código em `case 2` será executado, pois os rótulos `case` `12` `1` e `2` são agrupados. Se um bloco `case` não estiver vazio, um `break` deve estar presente antes do próximo rótulo `case`, caso contrário o compilador sinalizará um erro.

    int month = DateTime.Now.Month; // this is expected to be 1-12 for Jan-Dec

    switch (month)
    {
        case 12: 
        case 1: 
        case 2:
            Console.WriteLine("Winter");
            break;
        case 3: 
        case 4: 
        case 5:
            Console.WriteLine("Spring");
            break;
        case 6: 
        case 7: 
        case 8:
            Console.WriteLine("Summer");
            break;
        case 9:     
        case 10: 
        case 11:
            Console.WriteLine("Autumn");
            break;
        default:
            Console.WriteLine("Incorrect month index");
            break;
    }

Um `case` só pode ser rotulado por um valor conhecido em *tempo de compilação* (por exemplo, `1`, `"str"`, `Enum.A`), então uma `variável` não é um rótulo válido de `case` , mas um valor `const` ou `Enum` é (assim como qualquer valor literal).

## inseguro
A palavra-chave `unsafe` pode ser usada em declarações de tipo ou método ou para declarar um bloco inline.

O objetivo dessa palavra-chave é habilitar o uso do *subconjunto inseguro* de C# para o bloco em questão. O subconjunto inseguro inclui recursos como ponteiros, alocação de pilha, matrizes semelhantes a C e assim por diante.

Código inseguro não é verificável e é por isso que seu uso é desencorajado. A compilação de código não seguro requer a passagem de uma opção para o compilador C#. Além disso, o CLR requer que o assembly em execução tenha confiança total.

Apesar dessas limitações, o código inseguro tem usos válidos para tornar algumas operações mais eficientes (por exemplo, indexação de matriz) ou mais fáceis (por exemplo, interoperabilidade com algumas bibliotecas não gerenciadas).

Como um exemplo muito simples

    // compile with /unsafe
    class UnsafeTest
    {
       unsafe static void SquarePtrParam(int* p)
       {
          *p *= *p; // the '*' dereferences the pointer.
          //Since we passed in "the address of i", this becomes "i *= i"
       }
    
       unsafe static void Main()
       {
          int i = 5;
          // Unsafe method: uses address-of operator (&):
          SquarePtrParam(&i); // "&i" means "the address of i". The behavior is similar to "ref i"
          Console.WriteLine(i); // Output: 25
       }
    }

Ao trabalhar com ponteiros, podemos alterar os valores dos locais de memória diretamente, em vez de ter que endereçá-los pelo nome. Observe que isso geralmente requer o uso da palavra-chave [fixed][1] para evitar possível corrupção de memória à medida que o coletor de lixo move as coisas (caso contrário, você pode obter [erro CS0212][2]). Uma vez que uma variável que foi "fixada" não pode ser escrita, muitas vezes também temos que ter um segundo ponteiro que começa apontando para o mesmo local que o primeiro.

    void Main()
    {
        int[] intArray = new int[] { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10};

        UnsafeSquareArray(intArray);
        foreach(int i in intArray)
            Console.WriteLine(i);
    }
    
    unsafe static void UnsafeSquareArray(int[] pArr)
    {
        int len = pArr.Length;

        //in C or C++, we could say
        // int* a = &(pArr[0])
        // however, C# requires you to "fix" the variable first 
        fixed(int* fixedPointer = &(pArr[0]))
        {
            //Declare a new int pointer because "fixedPointer" cannot be written to.
            // "p" points to the same address space, but we can modify it
            int* p = fixedPointer;

            for (int i = 0; i < len; i++)
            {
                *p *= *p; //square the value, just like we did in SquarePtrParam, above
                p++;      //move the pointer to the next memory space.
                          // NOTE that the pointer will move 4 bytes since "p" is an
                          // int pointer and an int takes 4 bytes

                //the above 2 lines could be written as one, like this:
                // "*p *= *p++;"
            }
        }
    }

Resultado:

    1
    4
    9
    16
    25
    36
    49
    64
    81
    100


`unsafe` também permite o uso de [stackalloc][3] que irá alocar memória na pilha como _alloca na biblioteca de tempo de execução C. Podemos modificar o exemplo acima para usar `stackalloc` da seguinte forma:


    unsafe void Main()
    {
        const int len=10;
        int* seedArray = stackalloc int[len];
        
        //We can no longer use the initializer "{ 1, 2, 3, 4, 5, 6, 7, 8, 9, 10}" as before.
        // We have at least 2 options to populate the array. The end result of either
        // option will be the same (doing both will also be the same here).

        //FIRST OPTION:
        int* p = seedArray; // we don't want to lose where the array starts, so we
                            // create a shadow copy of the pointer
        for(int i=1; i<=len; i++)
            *p++ = i;
        //end of first option

        //SECOND OPTION:
        for(int i=0; i<len; i++)
            seedArray[i] = i+1;
        //end of second option

        UnsafeSquareArray(seedArray, len);
        for(int i=0; i< len; i++)
            Console.WriteLine(seedArray[i]);
    }
    
    //Now that we are dealing directly in pointers, we don't need to mess around with
    // "fixed", which dramatically simplifies the code
    unsafe static void UnsafeSquareArray(int* p, int len)
    {
        for (int i = 0; i < len; i++)
            *p *= *p++;
    }

(A saída é a mesma acima)


[1]: https://www.wikiod.com/pt/docs/c%23/26/keywords/59/fixed#t=20160802171014149858
[2]: https://msdn.microsoft.com/en-us/library/29ak9b70(v=vs.140).aspx
[3]: https://www.wikiod.com/pt/docs/c%23/26/keywords/57/stackalloc#t=20160802171014149858

## verdadeiro falso
As palavras-chave `true` e `false` têm dois usos:

1. Como valores booleanos literais


    var myTrueBool = true;
    var myFalseBool = false;

2. Como operadores que podem ser sobrecarregados


    public static bool operator true(MyClass x)
    {
        return x.value >= 0;
    }

    public static bool operator false(MyClass x)
    {
        return x.value < 0;
    }

Sobrecarregar o operador false era útil antes do C# 2.0, antes da introdução dos tipos `Nullable`.
Um tipo que sobrecarrega o operador `true` também deve sobrecarregar o operador `false`.

## foi
Uma variável local de tipo implícito que é fortemente tipada como se o usuário tivesse declarado o tipo. Ao contrário de outras declarações de variáveis, o compilador determina o tipo de variável que isso representa com base no valor atribuído a ela.

    var i = 10; // implicitly typed, the compiler must determine what type of variable this is
    int i = 10; // explicitly typed, the type of variable is explicitly stated to the compiler

    // Note that these both represent the same type of variable (int) with the same value (10).

Ao contrário de outros tipos de variáveis, as definições de variáveis ​​com essa palavra-chave precisam ser inicializadas quando declaradas. Isso ocorre porque a palavra-chave **var** representa uma variável de tipo implícito.

    var i;
    i = 10;

    // This code will not run as it is not initialized upon declaration.

A palavra-chave **var** também pode ser usada para criar novos tipos de dados em tempo real. Esses novos tipos de dados são conhecidos como *tipos anônimos*. Eles são bastante úteis, pois permitem que um usuário defina um conjunto de propriedades sem precisar declarar explicitamente qualquer tipo de objeto primeiro.

*Tipo anônimo simples*

    var a = new { number = 1, text = "hi" };

*Consulta LINQ que retorna um tipo anônimo*

    public class Dog
    {
        public string Name { get; set; }
        public int Age { get; set; }
    }

    public class DogWithBreed
    {
        public Dog Dog { get; set; }
        public string BreedName  { get; set; }
    }

    public void GetDogsWithBreedNames()
    {
        var db = new DogDataContext(ConnectString);
        var result = from d in db.Dogs
                 join b in db.Breeds on d.BreedId equals b.BreedId
                 select new 
                        {
                            DogName = d.Name,
                            BreedName = b.BreedName
                        };

        DoStuff(result);
    }

Você pode usar a palavra-chave var na instrução foreach

    public bool hasItemInList(List<String> list, string stringToSearch)
    {
        foreach(var item in list)
        {
            if( ( (string)item ).equals(stringToSearch) )
                return true;
        }

        return false;
    }

## enumeração
A palavra-chave `enum` diz ao compilador que esta classe herda da classe abstrata `Enum`, sem que o programador precise herdá-la explicitamente. `Enum` é um descendente de `ValueType`, que se destina ao uso com um conjunto distinto de constantes nomeadas.

    public enum DaysOfWeek
    {
        Monday,
        Tuesday,
    }

Você pode opcionalmente especificar um valor específico para cada um (ou alguns deles):

    public enum NotableYear
    {
       EndOfWwI = 1918;
       EnfOfWwII = 1945,
    }

Neste exemplo, omiti um valor para 0, isso geralmente é uma prática ruim. Um `enum` sempre terá um valor padrão produzido pela conversão explícita `(YourEnumType) 0`, onde `YourEnumType` é seu tipo `enume` declarado. Sem um valor de 0 definido, um `enum` não terá um valor definido no início.

O tipo subjacente padrão de `enum` é `int`, você pode alterar o tipo subjacente para qualquer tipo integral, incluindo `byte`, `sbyte`, `short`, `ushort`, `int`, `uint`, `long ` e `ulong`. Abaixo está uma enumeração com o tipo subjacente `byte`:

    enum Days : byte
    {
        Sunday = 0,
        Monday,
        Tuesday,
        Wednesday,
        Thursday,
        Friday,
        Saturday
    };

Observe também que você pode converter de/para o tipo subjacente simplesmente com uma conversão:

    int value = (int)NotableYear.EndOfWwI;

Por esses motivos, é melhor sempre verificar se um `enum` é válido ao expor funções de biblioteca:

    void PrintNotes(NotableYear year)
    {
        if (!Enum.IsDefined(typeof(NotableYear), year))
            throw InvalidEnumArgumentException("year", (int)year, typeof(NotableYear));
    
        // ...
    }



## dentro
A palavra-chave `in` tem três usos:

a) Como parte da sintaxe em uma instrução `foreach` ou como parte da sintaxe em uma consulta LINQ

    foreach (var member in sequence)
    {
        // ...
    }

b) No contexto de interfaces genéricas e tipos delegados genéricos significa _contravariance_ para o parâmetro de tipo em questão:

    public interface IComparer<in T>
    {
        // ...
    }

c) No contexto da consulta LINQ refere-se à coleção que está sendo consultada

    var query = from x in source select new { x.Name, x.ID, };


## tamanho de
Usado para obter o tamanho em bytes de um tipo não gerenciado

    int byteSize = sizeof(byte) // 1
    int sbyteSize = sizeof(sbyte) // 1
    int shortSize = sizeof(short) // 2
    int ushortSize = sizeof(ushort) // 2
    int intSize = sizeof(int) // 4
    int uintSize = sizeof(uint) // 4
    int longSize = sizeof(long) // 8
    int ulongSize = sizeof(ulong) // 8
    int charSize = sizeof(char) // 2(Unicode)
    int floatSize = sizeof(float) // 4
    int doubleSize = sizeof(double) // 8
    int decimalSize = sizeof(decimal) // 16
    int boolSize = sizeof(bool) // 1

## grandes
A palavra-chave **long** é usada para representar inteiros de 64 bits com sinal. É um alias para o tipo de dados `System.Int64` presente em `mscorlib.dll`, que é referenciado implicitamente por cada projeto C# quando você os cria.

*Qualquer variável **longa** pode ser declarada explicitamente e implicitamente:*

    long long1 = 9223372036854775806;  // explicit declaration, long keyword used
    var long2 = -9223372036854775806L; // implicit declaration, 'L' suffix used

Uma variável **longa** pode conter qualquer valor de -9.223.372.036.854.775.808 a 9.223.372.036.854.775.807 e pode ser útil em situações em que uma variável deve conter um valor que exceda os limites de outras variáveis ​​(como [**int**][ 1] variável) pode conter.


[1]: https://www.wikiod.com/pt/docs/c%23/26/keywords#t=201608201800043158849

## bool
Palavra-chave para armazenar os valores booleanos `true` e `false`. bool é um alias de System.Boolean.

O valor padrão de um bool é false.

    bool b; // default value is false
    b = true; // true
    b = ((5 + 2) == 6); // false

Para que um bool permita valores nulos, ele deve ser inicializado como bool?.

O valor padrão de um bool? é nulo.

    bool? a // default value is null

## desmarcado
A palavra-chave `unchecked` evita que o compilador verifique overflows/underflows.

Por exemplo:

    const int ConstantMax = int.MaxValue;
    unchecked
    {
        int1 = 2147483647 + 10;
    }
    int1 = unchecked(ConstantMax + 10);

Sem a palavra-chave `unchecked`, nenhuma das duas operações de adição será compilada.

## Quando isso é útil?

Isso é útil, pois pode ajudar a acelerar cálculos que definitivamente não estourarão, pois a verificação de estouro leva tempo, ou quando um estouro/subfluxo é o comportamento desejado (por exemplo, ao gerar um código hash).

## Faz
O operador do itera sobre um bloco de código até que uma consulta condicional seja igual a false. O loop do-while também pode ser interrompido por um [`goto`](https://www.wikiod.com/pt/docs/c%23/26/keywords/193/goto), [`return`](http:// stackoverflow.com/documentation/c%23/26/keywords/4600/return), [`break`](https://www.wikiod.com/pt/docs/c%23/26/keywords/2858/break) ou `throw ` declaração.

A sintaxe para a palavra-chave `do` é:

> fazer
> { *bloco de código;* }
> while( *condição*);


Exemplo:

    int i = 0;

    do
    {
        Console.WriteLine("Do is on loop number {0}.", i);
    } while (i++ < 5);


Resultado:

>"Do está no loop número 1." \
"Do está no loop número 2."\
"Do está no loop número 3."\
"Do está no loop número 4."\
"Do está no loop número 5."


Ao contrário do loop [`while`](https://www.wikiod.com/pt/docs/c%23/26/keywords/4396/while), o loop do-while é **Exit Controlled**. Isso significa que o loop do-while executaria suas instruções pelo menos uma vez, mesmo se a condição falhar na primeira vez.


    bool a = false;

    do
    {
        Console.WriteLine("This will be printed once, even if a is false.");
    } while (a == true);

## interface
Uma [`interface`][1] contém as [assinaturas][2] de métodos, propriedades e eventos. As classes derivadas definem os membros, pois a interface contém apenas a declaração dos membros.

Uma interface é declarada usando a palavra-chave `interface`.

    interface IProduct
    {
        decimal Price { get; }
    }
    
    class Product : IProduct
    {
        const decimal vat = 0.2M;
        
        public Product(decimal price)
        {
            _price = price;
        }
        
        private decimal _price;
        public decimal Price { get { return _price * (1 + vat); } }
    }


[1]: http://stackoverflow.com/questions/tagged/interface+c%23
[2]: http://stackoverflow.com/questions/tagged/signature+c%23

## implícito
A palavra-chave `implicit` é usada para sobrecarregar um operador de conversão. Por exemplo, você pode declarar uma classe `Fraction` que deve ser convertida automaticamente para um `double` quando necessário, e que pode ser convertida automaticamente de `int`:

    class Fraction(int numerator, int denominator)
    {
        public int Numerator { get; } = numerator;
        public int Denominator { get; } = denominator;
        // ...
        public static implicit operator double(Fraction f)
        {
            return f.Numerator / (double) f.Denominator;
        }
        public static implicit operator Fraction(int i)
        {
            return new Fraction(i, 1);
        }
    }

## ushor
Um tipo numérico usado para armazenar inteiros positivos de 16 bits. `ushort` é um alias para `System.UInt16`, e ocupa 2 bytes de memória.

O intervalo válido é de '0' a '65535'.

```
ushort a = 50; // 50
ushort b = 65536; // Error, cannot be converted
ushort c = unchecked((ushort)65536); // Overflows (wraps around to 0)
```

## delegado
Delegados são tipos que representam uma referência a um método. Eles são usados ​​para passar métodos como argumentos para outros métodos.

Os delegados podem conter métodos estáticos, métodos de instância, métodos anônimos ou expressões lambda.
   
```
class DelegateExample
{
    public void Run()
    {
        //using class method
        InvokeDelegate( WriteToConsole ); 
        
        //using anonymous method
        DelegateInvoker di = delegate ( string input ) 
        { 
            Console.WriteLine( string.Format( "di: {0} ", input ) );
            return true; 
        };
        InvokeDelegate( di ); 
        
        //using lambda expression
        InvokeDelegate( input => false ); 
    }

    public delegate bool DelegateInvoker( string input );

    public void InvokeDelegate(DelegateInvoker func)
    {
        var ret = func( "hello world" );
        Console.WriteLine( string.Format( " > delegate returned {0}", ret ) );
    }

    public bool WriteToConsole( string input )
    {
        Console.WriteLine( string.Format( "WriteToConsole: '{0}'", input ) );
        return true;
    }
}
```

Ao atribuir um método a um delegado, é importante observar que o método deve ter o mesmo tipo de retorno e parâmetros. Isso difere da sobrecarga de método 'normal', onde apenas os parâmetros definem a assinatura do método.

Os eventos são construídos em cima dos delegados.

## parcial
A palavra-chave `partial` pode ser usada durante a definição de tipo de classe, struct ou interface para permitir que a definição de tipo seja dividida em vários arquivos. Isso é útil para incorporar novos recursos no código gerado automaticamente.

**Arquivo1.cs**

    namespace A
    {
        public partial class Test
        {
            public string Var1 {get;set;}
        }
    }

**Arquivo2.cs**

    namespace A
    {
        public partial class Test
        {
            public string Var2 {get;set;}
        }
    }

**Observação:** uma classe pode ser dividida em qualquer número de arquivos. No entanto, todas as declarações devem estar no mesmo namespace e no mesmo assembly.

Os métodos também podem ser declarados parciais usando a palavra-chave `partial`. Neste caso, um arquivo conterá apenas a definição do método e outro arquivo conterá a implementação.

> Um método parcial tem sua assinatura definida em uma parte de um tipo parcial e sua implementação definida em outra parte do tipo. Os métodos parciais permitem que os designers de classe forneçam ganchos de método, semelhantes aos manipuladores de eventos, que os desenvolvedores podem decidir implementar ou não. Se o desenvolvedor não fornecer uma implementação, o compilador removerá a assinatura em tempo de compilação. As seguintes condições se aplicam a métodos parciais:
> * Assinaturas em ambas as partes do tipo parcial devem corresponder.
> * O método deve retornar void.
> * Não são permitidos modificadores de acesso. Os métodos parciais são implicitamente privados.
>
> -- MSDN

**Arquivo1.cs**

    namespace A
    {
        public partial class Test
        {
            public string Var1 {get;set;}
            public partial Method1(string str);
        }
    }

**Arquivo2.cs**

    namespace A
    {
        public partial class Test
        {
            public string Var2 {get;set;}
            public partial Method1(string str)
            {
                Console.WriteLine(str);
            }
        }
    }


**Observação:** o tipo que contém o método parcial também deve ser declarado parcial.

 




## sbyte
Um tipo numérico usado para armazenar inteiros *assinados* de 8 bits. `sbyte` é um alias para `System.SByte` e ocupa 1 byte de memória. Para o equivalente sem sinal, use `byte`.

O intervalo válido é de `-127` a `127` (o restante é usado para armazenar o sinal).

```
sbyte a = 127; // 127
sbyte b = -127; // -127
sbyte c = 200; // Error, cannot be converted
sbyte d = unchecked((sbyte)129); // -127 (overflows)
```

## evento
Um `evento` permite que o desenvolvedor implemente um padrão de notificação.

**Exemplo simples**

    public class Server
    {
        // defines the event
        public event EventHandler DataChangeEvent;

        void RaiseEvent()
        {
            var ev = DataChangeEvent;
            if(ev != null)
            {
                ev(this, EventArgs.Empty);
            }
        }
    }

    public class Client
    {
        public void Client(Server server)
        {
            // client subscribes to the server's DataChangeEvent
            server.DataChangeEvent += server_DataChanged;
        }

        private void server_DataChanged(object sender, EventArgs args)
        {
            // notified when the server raises the DataChangeEvent
        }
    }

[referência do MSDN][1]


[1]: https://msdn.microsoft.com/en-CA/library/awbftdfh.aspx

