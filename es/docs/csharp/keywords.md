---
title: "Palabras clave"
slug: "palabras-clave"
draft: false
images: []
weight: 8286
type: docs
toc: true
---

[Palabras clave](https://msdn.microsoft.com/en-us/library/x53a06bb(v=vs.71).aspx) son identificadores reservados predefinidos con un significado especial para el compilador. No se pueden usar como identificadores en su programa sin el prefijo `@`. Por ejemplo `@if` es un identificador legal pero no la palabra clave `if`.

C# tiene una colección predefinida de "palabras clave" (o palabras reservadas), cada una de las cuales tiene una función especial. Estas palabras no se pueden usar como identificadores (nombres de variables, métodos, clases, etc.) a menos que tengan el prefijo `@`.

* [`resumen`](https://www.wikiod.com/es/docs/c%23/26/keywords/2872/abstract)
* [`como`](https://www.wikiod.com/es/docs/c%23/26/keywords/138/as)
* [`base`](https://www.wikiod.com/es/docs/c%23/26/keywords/1840/base)
* [`bool`](https://www.wikiod.com/es/docs/c%23/26/keywords/8712/bool)
* [`romper`](https://www.wikiod.com/es/docs/c%23/26/keywords/2858/break)
* `byte`
* `caso`
* [`atrapar`](https://www.wikiod.com/es/docs/c%23/26/keywords/148/try-catch-finally-throw)
* [`char`](https://www.wikiod.com/es/docs/c%23/26/keywords/6009/char)
* [`marcado`](https://www.wikiod.com/es/docs/c%23/26/keywords/192/checked-unchecked)
* `clase`
* [`const`](https://www.wikiod.com/es/docs/c%23/26/keywords/141/const)
* [`continuar`](https://www.wikiod.com/es/docs/c%23/26/keywords/154/continuar)
* [`decimal`](https://www.wikiod.com/es/docs/c%23/26/keywords/2873/float-double-decimal)
* [`predeterminado`](https://www.wikiod.com/es/docs/c%23/26/keywords/109/default)
* [`delegado`](https://www.wikiod.com/es/docs/c%23/26/keywords/18720/delegate)
* [`do`](https://www.wikiod.com/es/docs/c%23/26/keywords/12229/do)
* [`doble`](https://www.wikiod.com/es/docs/c%23/26/keywords/2873/float-double-decimal)
* [`else`](https://www.wikiod.com/es/docs/c%23/26/keywords/11359/if-if-else-if-else-if)
* [`enum`](https://www.wikiod.com/es/docs/c%23/26/keywords/245/enum)
* [`evento`](https://www.wikiod.com/es/docs/c%23/26/keywords/18722/event)
* `explícito`
* [`externo`](https://www.wikiod.com/es/docs/c%23/26/keywords/8191/externo)
* [`falso`](https://www.wikiod.com/es/docs/c%23/26/keywords/17113/true-false)
* [`finalmente`](https://www.wikiod.com/es/docs/c%23/26/keywords/148/try-catch-finally-throw)
* [`fijo`](https://www.wikiod.com/es/docs/c%23/26/keywords/59/fixed)
* [`flotante`](https://www.wikiod.com/es/docs/c%23/26/keywords/2873/float-double-decimal)
* [`para`](https://www.wikiod.com/es/docs/c%23/26/keywords/3722/para)
* [`foreach`](https://www.wikiod.com/es/docs/c%23/26/keywords/1928/foreach)
* [`ir a`](https://www.wikiod.com/es/docs/c%23/26/keywords/193/goto)
* [`si`](https://www.wikiod.com/es/docs/c%23/26/keywords/11359/if-if-else-if-else-if)
* [`implícito`](https://www.wikiod.com/es/docs/c%23/26/keywords/16557/implícito)
* [`en`](https://www.wikiod.com/es/docs/c%23/26/keywords/4992/in)
* [`int`](https://www.wikiod.com/es/docs/c%23/26/keywords/5328/int)
* [`interfaz`](https://www.wikiod.com/es/docs/c%23/26/keywords/14354/interface)
* [`interno`][1]
* [`es`](https://www.wikiod.com/es/docs/c%23/26/keywords/139/is)
* [`bloquear`](https://www.wikiod.com/es/docs/c%23/26/keywords/6452/lock#t=201607261640175640513)
* [`largo`](https://www.wikiod.com/es/docs/c%23/26/keywords/5329/long)
* [`espacio de nombres`](https://www.wikiod.com/es/docs/c%23/26/keywords/142/espacio de nombres)
* [`nuevo`](https://www.wikiod.com/es/docs/c%23/26/keywords/5805/virtual-override-new)
* [`null`](https://www.wikiod.com/es/docs/c%23/26/keywords/6750/null)
* `objeto`
* [`operador`](https://www.wikiod.com/es/docs/c%23/26/keywords/12604/operator)
* [`fuera`](https://www.wikiod.com/es/docs/c%23/26/keywords/184/ref-out)
* [`override`](https://www.wikiod.com/es/docs/c%23/26/keywords/5805/virtual-override-new)
* [`parámetros`](https://www.wikiod.com/es/docs/c%23/26/keywords/2513/params)
* `privado`
* `protegido`
* `público`
* [`solo lectura`](https://www.wikiod.com/es/docs/c%23/26/keywords/110/readonly)
* [`ref`](https://www.wikiod.com/es/docs/c%23/26/keywords/184/ref-out)
* [`return`](https://www.wikiod.com/es/docs/c%23/26/keywords/4600/return)
* [`sbyte`](https://www.wikiod.com/es/docs/c%23/26/keywords/18290/sbyte)
* [`sellado`](https://www.wikiod.com/es/docs/c%23/26/keywords/5245/sealed)
* `corto`
* [`tamaño de`](https://www.wikiod.com/es/docs/c%23/26/keywords/5246/sizeof)
* [`stackalloc`](https://www.wikiod.com/es/docs/c%23/26/keywords/57/stackalloc)
* [`estática`](https://www.wikiod.com/es/docs/c%23/26/keywords/5248/static)
* [`cadena`](https://www.wikiod.com/es/docs/c%23/26/keywords/17143/string)
* [`estructura`][2]
* [`cambiar`](https://www.wikiod.com/es/docs/c%23/26/keywords/14353/switch)
* [`esto`](https://www.wikiod.com/es/docs/c%23/26/keywords/2914/this)
* [`lanzar`](https://www.wikiod.com/es/docs/c%23/26/keywords/148/try-catch-finally-throw)
* [`verdadero`](https://www.wikiod.com/es/docs/c%23/26/keywords/17113/true-false)
* [`intentar`](https://www.wikiod.com/es/docs/c%23/26/keywords/148/try-catch-finally-throw)
* [`tipode`](https://www.wikiod.com/es/docs/c%23/26/keywords/140/typeof)
* [`uint`](https://www.wikiod.com/es/docs/c%23/26/keywords/2874/uint)
* [`ulong`](https://www.wikiod.com/es/docs/c%23/26/keywords/5330/ulong)
* [`desmarcado`](https://www.wikiod.com/es/docs/c%23/26/keywords/192/checked-unchecked)
* [`inseguro`](https://www.wikiod.com/es/docs/c%23/26/keywords/15630/inseguro)
* [`ushort`](https://www.wikiod.com/es/docs/c%23/26/keywords/18289/ushort)
* [`usando` (directiva)](https://www.wikiod.com/es/docs/c%23/52/using-directive#t=201605012059492751326)
* [`usando` (declaración)](https://www.wikiod.com/es/docs/c%23/38/using-statement#t=20160501205709291959)
* [`virtual`](https://www.wikiod.com/es/docs/c%23/26/keywords/5805/virtual-override-new)
* [`vacío`](https://www.wikiod.com/es/docs/c%23/26/keywords/2980/void)
* [`volátil`](https://www.wikiod.com/es/docs/c%23/26/keywords/58/volatile)
* [`cuando`](https://www.wikiod.com/es/docs/c%23/26/keywords/9258/cuando)
* [`mientras`](https://www.wikiod.com/es/docs/c%23/26/keywords/4396/while)

Aparte de estos, C# también usa algunas palabras clave para proporcionar un significado específico en el código. Se llaman palabras clave contextuales. Las palabras clave contextuales se pueden usar como identificadores y no es necesario que tengan el prefijo `@` cuando se usan como identificadores.

* `añadir`
* `alias`
* `ascendente`
* [`async`](https://www.wikiod.com/es/docs/c%23/26/keywords/5993/async-await)
* [`esperar`](https://www.wikiod.com/es/docs/c%23/26/keywords/5993/async-await)
* `descendente`
* `dinámica`
* `desde`
* `obtener`
* `globales`
* `grupo`
* `en`
* `unirse`
* `dejar`
* [`nombre de`](https://www.wikiod.com/es/docs/c%23/24/c-sharp-6-0-features/43/operator-nameof)
* `ordenar por`
* [`parcial`](https://www.wikiod.com/es/docs/c%23/26/keywords/19199/partial#t=201608110434471554387)
* `eliminar`
* `seleccionar`
* `conjunto`
* `valor`
* [`var`](https://www.wikiod.com/es/docs/c%23/26/keywords/4503/var)
* [`where`](https://www.wikiod.com/es/docs/c%23/26/keywords/8137/where-type-constraints)
* [`rendimiento`](https://www.wikiod.com/es/docs/c%23/61/yield-keyword-in-c#t=201605012045372009603)


[1]: https://www.wikiod.com/es/docs/c%23/26/keywords/8102/internal#t=201607221603473329189
[2]: https://www.wikiod.com/es/docs/c%23/26/keywords/13023/struct#t=201607251950535084892

## como
La palabra clave `as` es un operador similar a *cast*. Si una conversión no es posible, usar `as` produce `null` en lugar de generar una `InvalidCastException`.

`expresión como tipo` es equivalente a `expresión es tipo? (type)expression : (type)null` con la advertencia de que `as` solo es válido en conversiones de referencia, conversiones anulables y conversiones boxing. Las conversiones definidas por el usuario *no* son compatibles; en su lugar, se debe usar un yeso regular.

Para la expansión anterior, el compilador genera código de modo que `expression` solo se evaluará una vez y usará una verificación de tipo dinámica única (a diferencia de las dos del ejemplo anterior).

`as` puede ser útil cuando se espera que un argumento facilite varios tipos. Específicamente, otorga al usuario múltiples opciones, en lugar de verificar todas las posibilidades con `is` antes de emitir, o simplemente emitir y capturar excepciones. Es una buena práctica usar 'como' al lanzar/verificar un objeto que causará solo una penalización de desempaquetado. El uso de `is` para verificar, luego lanzar causará dos penalizaciones de desempaquetado.

Si se espera que un argumento sea una instancia de un tipo específico, se prefiere una conversión regular ya que su propósito es más claro para el lector.

Dado que una llamada a `as` puede producir `null`, compruebe siempre el resultado para evitar una `NullReferenceException`.

**Ejemplo de uso**

    object something = "Hello";
    Console.WriteLine(something as string);        //Hello
    Console.Writeline(something as Nullable<int>); //null
    Console.WriteLine(something as int?);          //null
    
    //This does NOT compile:
    //destination type must be a reference type (or a nullable value type)
    Console.WriteLine(something as int);

[Demostración en vivo en .NET Fiddle](https://dotnetfiddle.net/b26q6N)

Ejemplo equivalente sin usar `as`:

    Console.WriteLine(something is string ? (string)something : (string)null);

Esto es útil cuando se anula la función `Equals` en clases personalizadas.

    class MyCustomClass
    {

        public override bool Equals(object obj)
        {
            MyCustomClass customObject = obj as MyCustomClass;

            // if it is null it may be really null
            // or it may be of a different type
            if (Object.ReferenceEquals(null, customObject))
            {
                // If it is null then it is not equal to this instance.
                return false;
            }

            // Other equality controls specific to class
        }

    }

## ir
`goto` se puede usar para saltar a una línea específica dentro del código, especificada por una etiqueta.

# `goto` como:

## Etiqueta:

    void InfiniteHello()
    {
        sayHello:
        Console.WriteLine("Hello!");
        goto sayHello;
    }

[Demostración en vivo en .NET Fiddle](https://dotnetfiddle.net/Tpm3LV)

## Declaración del caso:

    enum Permissions { Read, Write };

    switch (GetRequestedPermission())
    {
        case Permissions.Read:
            GrantReadAccess();
            break;

        case Permissions.Write:
            GrantWriteAccess();
            goto case Permissions.Read; //People with write access also get read
    }

[Demostración en vivo en .NET Fiddle](https://dotnetfiddle.net/2IV2wC)

Esto es particularmente útil para ejecutar varios comportamientos en una declaración de cambio, ya que C# no admite [bloques de casos fallidos] (http://stackoverflow.com/a/174223/365102).

## Reintento de excepción

    var exCount = 0;
    retry:
    try
    {
        //Do work
    }
    catch (IOException)
    {
        exCount++;
        if (exCount < 3)
        {
            Thread.Sleep(100);
            goto retry;
        }
        throw;
    }

[Demostración en vivo en .NET Fiddle](https://dotnetfiddle.net/kc6oiT)

Al igual que en muchos idiomas, se desaconseja el uso de la palabra clave goto excepto en los casos a continuación.

[Usos válidos de `goto`][wiki] que se aplican a C#:

* Caso fallido en declaración de cambio.
* Descanso de varios niveles. En su lugar, a menudo se puede usar LINQ, pero generalmente tiene un peor rendimiento.
* Desasignación de recursos cuando se trabaja con objetos de bajo nivel no envueltos. En C#, los objetos de bajo nivel generalmente deben estar envueltos en clases separadas.
* Máquinas de estados finitos, por ejemplo, analizadores; utilizado internamente por las máquinas de estado async/await generadas por el compilador.

[entonces]: http://stackoverflow.com/questions/tagged/goto+c%23
[wiki]: https://en.wikipedia.org/wiki/Goto#Common_usage_patterns_of_Goto

## volátil
Agregar la palabra clave `volátil` a un campo le indica al compilador que el valor del campo puede ser cambiado por varios subprocesos separados. El propósito principal de la palabra clave `volátil` es evitar las optimizaciones del compilador que asumen solo un acceso de subproceso único. El uso de `volátil` garantiza que el valor del campo sea el valor más reciente disponible y que el valor no esté sujeto al almacenamiento en caché que tienen los valores no volátiles.

Es una buena práctica marcar _todas las variables_ que pueden ser utilizadas por varios subprocesos como `volátiles` para evitar comportamientos inesperados debido a optimizaciones en segundo plano. Considere el siguiente bloque de código:

    public class Example
    {
        public int x;

        public void DoStuff()
        {
            x = 5;

            // the compiler will optimize this to y = 15
            var y = x + 10;

            /* the value of x will always be the current value, but y will always be "15" */
            Debug.WriteLine("x = " + x + ", y = " + y);
        }    
    }

En el bloque de código anterior, el compilador lee las declaraciones `x = 5` e `y = x + 10` y determina que el valor de `y` siempre terminará en 15. Por lo tanto, optimizará la última declaración como `y = 15`. Sin embargo, la variable `x` es de hecho un campo `público` y el valor de `x` puede modificarse en tiempo de ejecución a través de un subproceso diferente que actúa sobre este campo por separado. Ahora considere este bloque de código modificado. Tenga en cuenta que el campo `x` ahora se declara como `volátil`.

    public class Example
    {
        public volatile int x;

        public void DoStuff()
        {
            x = 5;

            // the compiler no longer optimizes this statement
            var y = x + 10;

            /* the value of x and y will always be the correct values */
            Debug.WriteLine("x = " + x + ", y = " + y);
        }    
    }

Ahora, el compilador busca usos de *lectura* del campo `x` y se asegura de que siempre se recupere el valor actual del campo. Esto asegura que incluso si varios subprocesos están leyendo y escribiendo en este campo, siempre se recuperará el valor actual de `x`.

`volatile` solo se puede usar en campos dentro de `class`es o `struct`s. Lo siguiente [*no* es válido][2]:

<pre>public void MiMetodo()
{
    <strike>volatile</strike> int x;
}</pre>

`volátil` solo se puede aplicar a campos de los siguientes tipos:
- tipos de referencia o parámetros de tipo genérico que se sabe que son tipos de referencia
- tipos primitivos como `sbyte`, `byte`, `short`, `ushort`, `int`, `uint`, `char`, `float` y `bool`
- tipos de enumeraciones basados ​​en `byte`, `sbyte`, `short`, `ushort`, `int` o `uint`
- `IntPtr` y `UIntPtr`

----------
**Observaciones:**

- El modificador [`volatile`][1] generalmente se usa para un campo al que acceden múltiples subprocesos sin usar la declaración de bloqueo para serializar el acceso.
- La palabra clave `volátil` se puede aplicar a campos de tipos de referencia
- La palabra clave `volátil` no hará que funcione en primitivas de 64 bits en una plataforma atómica de 32 bits. Las operaciones interbloqueadas como [`Interlocked.Read`][3] y [`Interlocked.Exchange`][4] aún deben usarse para el acceso seguro de subprocesos múltiples en estas plataformas.


[1]: http://stackoverflow.com/questions/72275/when-should-the-volatile-keyword-be-used-in-c
[2]: https://msdn.microsoft.com/en-us/library/x13ttww7.aspx
[3]: https://msdn.microsoft.com/en-us/library/system.threading.interlocked.read(v=vs.110).aspx
[4]: https://msdn.microsoft.com/en-us/library/dk0121zy(v=vs.110).aspx

## marcado, desmarcado
Las palabras clave `checked` y `unchecked` definen cómo las operaciones manejan el desbordamiento matemático. "Desbordamiento" en el contexto de las palabras clave `marcado` y `no marcado` es cuando una operación aritmética de enteros da como resultado un valor que es mayor en magnitud que el tipo de datos de destino que puede representar.

Cuando se produce un desbordamiento dentro de un bloque `marcado` (o cuando el compilador está configurado para usar globalmente la aritmética verificada), se lanza una excepción para advertir sobre un comportamiento no deseado. Mientras tanto, en un bloque `sin marcar`, el desbordamiento es silencioso: no se lanzan excepciones, y el valor simplemente se ajustará al límite opuesto. Esto puede conducir a errores sutiles y difíciles de encontrar.

Dado que la mayoría de las operaciones aritméticas se realizan en valores que no son lo suficientemente grandes o pequeños como para desbordarse, la mayoría de las veces no hay necesidad de definir explícitamente un bloque como "marcado". Se debe tener cuidado al hacer operaciones aritméticas con entradas ilimitadas que pueden causar un desbordamiento, por ejemplo, al hacer operaciones aritméticas en funciones recursivas o al tomar entradas del usuario.

_Ni `marcado` ni `no marcado` afectan las operaciones aritméticas de punto flotante._

Cuando un bloque o una expresión se declaran como `sin marcar`, cualquier operación aritmética dentro de él puede desbordarse sin causar un error. Un ejemplo en el que este comportamiento es *deseado* sería el cálculo de una suma de comprobación, donde se permite que el valor se "envuelva" durante el cálculo:

    byte Checksum(byte[] data) {
        byte result = 0;
        for (int i = 0; i < data.Length; i++) {
            result = unchecked(result + data[i]); // unchecked expression
        }
        return result;
    }

Uno de los usos más comunes de `unchecked` es implementar una anulación personalizada para `object.GetHashCode()`, un tipo de suma de comprobación. Puede ver el uso de la palabra clave en las respuestas a esta pregunta: http://stackoverflow.com/questions/263400/what-is-the-best-algorithm-for-an-overridden-system-object-gethashcode.

Cuando un bloque o una expresión se declaran como `verificados`, cualquier operación aritmética que provoque un desbordamiento da como resultado una `OverflowException`.

    int SafeSum(int x, int y) {
        checked { // checked block
            return x + y; 
        }
    }

Tanto las marcadas como las no marcadas pueden estar en forma de bloque y de expresión.

Los bloques marcados y no marcados no afectan a los métodos llamados, solo a los operadores llamados directamente en el método actual. Por ejemplo, `Enum.ToObject()`, `Convert.ToInt32()` y los operadores definidos por el usuario no se ven afectados por contextos marcados/no marcados personalizados.

***Nota**: El comportamiento predeterminado de desbordamiento predeterminado (marcado vs. no marcado) se puede cambiar en **Propiedades del proyecto** o a través del modificador de línea de comando **/marcado[+|-]**. Es común establecer por defecto las operaciones marcadas para compilaciones de depuración y no marcadas para compilaciones de lanzamiento. Las palabras clave "marcadas" y "no marcadas" se usarían solo cuando no se aplique un enfoque _predeterminado_ y se necesite un comportamiento explícito para garantizar la corrección.*

## virtual, anular, nuevo
virtual y anular
====================

La palabra clave `virtual` permite que las clases derivadas anulen un método, una propiedad, un indexador o un evento y presenten un comportamiento polimórfico. (Los miembros no son virtuales de forma predeterminada en C#)

    public class BaseClass
    {
        public virtual void Foo()
        {
            Console.WriteLine("Foo from BaseClass");
        }
    }

Para anular un miembro, la palabra clave `override` se utiliza en las clases derivadas. (Tenga en cuenta que la firma de los miembros debe ser idéntica)

    public class DerivedClass: BaseClass
    {
        public override void Foo()
        {
            Console.WriteLine("Foo from DerivedClass");
        }
    }

El comportamiento polimórfico de los miembros virtuales significa que cuando se invoca, el miembro real que se ejecuta se determina en tiempo de ejecución en lugar de en tiempo de compilación. El miembro superior en la clase más derivada de la que el objeto en particular es una instancia será el que se ejecute.

En resumen, el objeto se puede declarar de tipo `BaseClass` en tiempo de compilación, pero si en tiempo de ejecución es una instancia de `DerivedClass`, se ejecutará el miembro anulado:

    BaseClass obj1 = new BaseClass();
    obj1.Foo(); //Outputs "Foo from BaseClass"

    obj1 = new DerivedClass();
    obj1.Foo(); //Outputs "Foo from DerivedClass"    

Anular un método es opcional:

    public class SecondDerivedClass: DerivedClass {}
    
    var obj1 = new SecondDerivedClass();
    obj1.Foo(); //Outputs "Foo from DerivedClass"    

nuevo
====================    
Dado que solo los miembros definidos como "virtuales" son anulables y polimórficos, una clase derivada que redefina un miembro no virtual podría generar resultados inesperados.

    public class BaseClass
    {
        public void Foo()
        {
            Console.WriteLine("Foo from BaseClass");
        }
    }

    public class DerivedClass: BaseClass
    {
        public void Foo()
        {
            Console.WriteLine("Foo from DerivedClass");
        }
    }

    BaseClass obj1 = new BaseClass();
    obj1.Foo(); //Outputs "Foo from BaseClass"

    obj1 = new DerivedClass();
    obj1.Foo(); //Outputs "Foo from BaseClass" too!    

Cuando esto sucede, el miembro ejecutado siempre se determina en tiempo de compilación en función del tipo de objeto.

- Si el objeto se declara del tipo `BaseClass` (incluso si en tiempo de ejecución es de una clase derivada), entonces se ejecuta el método de `BaseClass`
- Si el objeto se declara del tipo `DerivedClass`, se ejecuta el método de `DerivedClass`.

Esto suele ser un accidente (cuando se agrega un miembro al tipo base después de agregar uno idéntico al tipo derivado) y se genera una advertencia del compilador **CS0108** en esos escenarios.

Si fue intencional, entonces la palabra clave `nuevo` se usa para suprimir la advertencia del compilador (¡e informar a otros desarrolladores de sus intenciones!). el comportamiento sigue siendo el mismo, la palabra clave `nuevo` simplemente suprime la advertencia del compilador.

    public class BaseClass
    {
        public void Foo()
        {
            Console.WriteLine("Foo from BaseClass");
        }
    }

    public class DerivedClass: BaseClass
    {
        public new void Foo()
        {
            Console.WriteLine("Foo from DerivedClass");
        }
    }

    BaseClass obj1 = new BaseClass();
    obj1.Foo(); //Outputs "Foo from BaseClass"

    obj1 = new DerivedClass();
    obj1.Foo(); //Outputs "Foo from BaseClass" too! 

El uso de anulación es _no_ opcional
=======================================
A diferencia de C++, el uso de la palabra clave `override` *no* es opcional:

    public class A
    {
        public virtual void Foo()
        {
        }
    }

    public class B : A
    {
        public void Foo() // Generates CS0108
        {
        }
    }

El ejemplo anterior también provoca la advertencia **CS0108**, porque `B.Foo()` no anula automáticamente `A.Foo()`. Agregue `override` cuando la intención sea anular la clase base y causar un comportamiento polimórfico, agregue `new` cuando desee un comportamiento no polimórfico y resuelva la llamada usando el tipo estático. Este último debe usarse con precaución, ya que puede causar una gran confusión.

El siguiente código incluso da como resultado un error:

    public class A
    {
        public void Foo()
        {
        }
    }

    public class B : A
    {
        public override void Foo() // Error: Nothing to override
        {
        }
    }

Las clases derivadas pueden introducir polimorfismo.
==========================================
El siguiente código es perfectamente válido (aunque raro):

        public class A
        {
            public void Foo()
            {
                Console.WriteLine("A");
            }
        }

        public class B : A
        {
            public new virtual void Foo() 
            {
                Console.WriteLine("B");
            }
        }

Ahora todos los objetos con una referencia estática de B (y sus derivados) usan polimorfismo para resolver `Foo()`, mientras que las referencias de A usan `A.Foo()`.

    A a = new A();
    a.Foo(); // Prints "A";
    a = new B();
    a.Foo(); // Prints "A";
    B b = new B();
    b.Foo(); // Prints "B";

Los métodos virtuales no pueden ser privados.
=================================
El compilador de C# es estricto en la prevención de construcciones sin sentido. Los métodos marcados como "virtuales" no pueden ser privados. Debido a que un método privado no se puede ver desde un tipo derivado, tampoco se puede sobrescribir. Esto falla al compilar:

    public class A
    {
        private virtual void Foo() // Error: virtual methods cannot be private
        {
        }
    }

## stackalloc
La palabra clave `stackalloc` crea una región de memoria en la pila y devuelve un puntero al inicio de esa memoria. La memoria asignada a la pila se elimina automáticamente cuando se sale del ámbito en el que se creó.

    //Allocate 1024 bytes. This returns a pointer to the first byte.
    byte* ptr = stackalloc byte[1024];

    //Assign some values...
    ptr[0] = 109;
    ptr[1] = 13;
    ptr[2] = 232;
    ...

<sup>*Usado en un contexto inseguro.*</sup>

Al igual que con todos los punteros en C#, no hay límites para verificar lecturas y asignaciones. Leer más allá de los límites de la memoria asignada tendrá resultados impredecibles: puede acceder a alguna ubicación arbitraria dentro de la memoria o puede causar una excepción de violación de acceso.

    //Allocate 1 byte
    byte* ptr = stackalloc byte[1];

    //Unpredictable results...
    ptr[10] = 1;
    ptr[-1] = 2;

La memoria asignada a la pila se elimina automáticamente cuando se sale del ámbito en el que se creó. Esto significa que nunca debe devolver la memoria creada con stackalloc ni almacenarla más allá de la vida útil del alcance.

    unsafe IntPtr Leak() {
        //Allocate some memory on the stack
        var ptr = stackalloc byte[1024];

        //Return a pointer to that memory (this exits the scope of "Leak")
        return new IntPtr(ptr);
    }

    unsafe void Bad() {
         //ptr is now an invalid pointer, using it in any way will have
         //unpredictable results. This is exactly the same as accessing beyond
         //the bounds of the pointer.
         var ptr = Leak();
    }

`stackalloc` solo se puede usar al declarar *e* inicializar variables. Lo siguiente *no* es válido:

    byte* ptr;
    ...
    ptr = stackalloc byte[1024];

----------
**Observaciones:**

`stackalloc` solo debe usarse para optimizaciones de rendimiento (ya sea para computación o interoperabilidad). Esto se debe al hecho de que:

- El recolector de basura no es necesario ya que la memoria se asigna en la pila en lugar de en el montón - la memoria se libera tan pronto como la variable queda fuera del alcance
- Es más rápido asignar memoria en la pila que en el montón
- Aumente la posibilidad de aciertos de caché en la CPU debido a la localidad de los datos

## descanso
En un bucle (for, foreach, do, while) la instrucción `break` aborta la ejecución del bucle más interno y vuelve al código posterior. También se puede usar con `yield` en el que especifica que un iterador ha llegado a su fin.

    for (var i = 0; i < 10; i++)
    {
        if (i == 5)
        {
            break;
        }
        Console.WriteLine("This will appear only 5 times, as the break will stop the loop.");
    }

[Demostración en vivo en .NET Fiddle](https://dotnetfiddle.net/QtpNyk)
    
    foreach (var stuff in stuffCollection)
    {
        if (stuff.SomeStringProp == null)
            break;
        // If stuff.SomeStringProp for any "stuff" is null, the loop is aborted.
        Console.WriteLine(stuff.SomeStringProp);
    }

La instrucción break también se usa en construcciones switch-case para salir de un caso o segmento predeterminado.

    switch(a)
    {
        case 5:
            Console.WriteLine("a was 5!");
            break;

        default:
            Console.WriteLine("a was something else!");
            break;
    }

En declaraciones de cambio, se requiere la palabra clave 'romper' al final de cada declaración de caso. Esto es contrario a algunos lenguajes que permiten "fallar" a la siguiente declaración de caso de la serie. Las soluciones alternativas para esto incluirían declaraciones 'goto' o apilar las declaraciones 'case' secuencialmente.

El siguiente código dará los números `0, 1, 2, ..., 9` y la última línea no se ejecutará. `Ruptura de rendimiento` significa el final de la función (no solo un ciclo).

    public static IEnumerable<int> GetNumbers()
    {
        int i = 0;
        while (true) {
            if (i < 10) {
                yield return i++;
            } else {
                yield break;
            }
        }
        Console.WriteLine("This line will not be executed");
    }

[Demostración en vivo en .NET Fiddle][1]


Tenga en cuenta que, a diferencia de otros lenguajes, no hay forma de etiquetar una interrupción en particular en C#. Esto significa que, en el caso de bucles anidados, solo se detendrá el bucle más interno:

    foreach (var outerItem in outerList)
    {
        foreach (var innerItem in innerList)
        {
            if (innerItem.ShoudBreakForWhateverReason)
                // This will only break out of the inner loop, the outer will continue:
                break; 
        }
    }

Si desea salir del bucle *externo* aquí, puede usar una de varias estrategias diferentes, como:
- Una instrucción **goto** para saltar fuera de toda la estructura de bucle.
- Una variable indicadora específica (`shouldBreak` en el siguiente ejemplo) que se puede verificar al final de cada iteración del ciclo externo.
- Refactorizar el código para usar una instrucción `return` en el cuerpo del bucle más interno, o evitar por completo la estructura de bucle anidado.


    bool shouldBreak = false;
    while(comeCondition)
    {
        while(otherCondition)
        {
            if (conditionToBreak)
            {
                // Either tranfer control flow to the label below...
                goto endAllLooping;

                // OR use a flag, which can be checked in the outer loop:
                shouldBreak = true;
            }
        }

        if(shouldBreakNow)
        {
            break; // Break out of outer loop if flag was set to true
        }
    }

    endAllLooping: // label from where control flow will continue



[1]: https://dotnetfiddle.net/IjSyVJ

## constante
`const` se usa para representar valores que **nunca cambiarán** a lo largo de la vida útil del programa. Su valor es constante desde **compile-time**, a diferencia de la palabra clave [`readonly`](https://www.wikiod.com/es/docs/c%23/26/keywords/110/readonly), cuyo valor es constante desde el tiempo de ejecución.

Por ejemplo, dado que la velocidad de la luz nunca cambiará, podemos almacenarla en una constante.

    const double c = 299792458;  // Speed of light
    
    double CalculateEnergy(double mass)
    {
        return mass * c * c;
    }

Esto es esencialmente lo mismo que tener `return mass * 299792458 * 299792458`, ya que el compilador sustituirá directamente `c` por su valor constante.

Como resultado, `c` no se puede cambiar una vez declarada. Lo siguiente producirá un error en tiempo de compilación:

    const double c = 299792458;  // Speed of light 
    
    c = 500;  //compile-time error
    
Una constante puede tener como prefijo los mismos modificadores de acceso que los métodos:

    private const double c = 299792458;
    public const double c = 299792458;
    internal const double c = 299792458;

Los miembros `const` son `estáticos` por naturaleza. Sin embargo, no se permite el uso explícito de `static`.

También puede definir constantes locales de método:

    double CalculateEnergy(double mass)
    {
        const c = 299792458;
        return mass * c * c;
    }

Estos no pueden tener el prefijo de una palabra clave `private` o `public`, ya que son implícitamente locales al método en el que están definidos.

----------

No todos los tipos se pueden usar en una declaración `const`. Los tipos de valores que están permitidos son los tipos predefinidos `sbyte`, `byte`, `short`, `ushort`, `int`, `uint`, `long`, `ulong`, `char`, ` float`, `double`, `decimal`, `bool` y todos los tipos `enum`. Intentar declarar miembros `const` con otros tipos de valores (como `TimeSpan` o `Guid`) fallará en tiempo de compilación.

Para el tipo de referencia especial predefinido `cadena`, las constantes se pueden declarar con cualquier valor. Para todos los demás tipos de referencia, se pueden declarar constantes, pero siempre deben tener el valor `null`.

----------

Debido a que los valores `const` se conocen en tiempo de compilación, se permiten como etiquetas `case` en una instrucción `switch`, como argumentos estándar para parámetros opcionales, como argumentos para especificaciones de atributos, etc.

----------

Si se utilizan valores `const` en diferentes ensamblajes, se debe tener cuidado con el control de versiones. Por ejemplo, si el ensamblado A define `public const int MaxRetries = 3;`, y el ensamblado B usa esa constante, entonces si el valor de `MaxRetries` se cambia posteriormente a `5` en el ensamblado A (que luego se vuelve a compilar ), ese cambio no será efectivo en el ensamblado B _a menos que_ el ensamblado B también se vuelva a compilar (con una referencia a la nueva versión de A).

Por esa razón, si un valor puede cambiar en futuras revisiones del programa, y ​​si el valor necesita ser visible públicamente, no declare ese valor 'const' a menos que sepa que todos los ensamblajes dependientes se volverán a compilar cada vez que se cambie algo. . La alternativa es usar `solo lectura estática` en lugar de `const`, que se resuelve en tiempo de ejecución.

## por
Sintaxis: `for (inicializador; condición; iterador)`

- El bucle `for` se usa comúnmente cuando se conoce el número de iteraciones.
- Las declaraciones en la sección `inicializador` se ejecutan solo una vez, antes de ingresar al ciclo.
- La sección `condición` contiene una expresión booleana que se evalúa al final de cada iteración del ciclo para determinar si el ciclo debe salir o ejecutarse nuevamente.
- La sección `iterador` define lo que sucede después de cada iteración del cuerpo del ciclo.

Este ejemplo muestra cómo se puede usar `for` para iterar sobre los caracteres de una cadena:

    string str = "Hello";
    for (int i = 0; i < str.Length; i++)
    {
        Console.WriteLine(str[i]);                
    }
                     
Producción:

>H
>e
>l
>l
>u

[<kbd>Demostración en vivo en .NET Fiddle</kbd>](https://dotnetfiddle.net/Ybg356)

Todas las expresiones que definen una sentencia `for` son opcionales; por ejemplo, la siguiente declaración se usa para crear un bucle infinito:

    for( ; ; )
    {
        // Your code here
    }

La sección `inicializador` puede contener múltiples variables, siempre que sean del mismo tipo. La sección `condición` puede consistir en cualquier expresión que pueda evaluarse como `bool`. Y la sección `iterador` puede realizar varias acciones separadas por comas:

    string hello = "hello";
    for (int i = 0, j = 1, k = 9; i < 3 && k > 0; i++, hello += i) {
        Console.WriteLine(hello);
    }

Producción:

> hola
>hola1
>hola12

[<kbd>Demostración en vivo en .NET Fiddle</kbd>](https://dotnetfiddle.net/LQcqCv)

## asíncrono, espera


La palabra clave `await` se agregó como parte de la versión C# 5.0, que es compatible con Visual Studio 2012 en adelante. Aprovecha la biblioteca paralela de tareas (TPL), lo que hizo que los subprocesos múltiples fueran relativamente más fáciles. Las palabras clave `async` y `await` se usan juntas en la misma función, como se muestra a continuación. La palabra clave `await` se usa para pausar la ejecución del método asíncrono actual hasta que se complete la tarea asíncrona esperada y/o se devuelvan sus resultados. Para usar la palabra clave `await`, el método que la usa debe estar marcado con la palabra clave `async`.

Se desaconseja encarecidamente el uso de `async` con `void`. Para obtener más información, puede consultar [aquí] [1].

Ejemplo:

    public async Task DoSomethingAsync()
    {    
        Console.WriteLine("Starting a useless process...");
        Stopwatch stopwatch = Stopwatch.StartNew();
        int delay = await UselessProcessAsync(1000);
        stopwatch.Stop();
        Console.WriteLine("A useless process took {0} milliseconds to execute.", stopwatch.ElapsedMilliseconds);
    }
    
    public async Task<int> UselessProcessAsync(int x)
    {
        await Task.Delay(x);
        return x;
    }

Producción:

> "Iniciando un proceso inútil..."\
> \
> **... 1 segundo de retraso... **
> 
> "Un proceso inútil tardó 1000 milisegundos en ejecutarse".

Los pares de palabras clave `async` y `await` se pueden omitir si un método de devolución `Task` o `Task<T>` solo devuelve una única operación asincrónica.

*En vez de esto:*

    public async Task PrintAndDelayAsync(string message, int delay)
    {
        Debug.WriteLine(message);
        await Task.Delay(x);
    }

*Es preferible hacer esto:*

    public Task PrintAndDelayAsync(string message, int delay)
    {
        Debug.WriteLine(message);
        return Task.Delay(x);
    }
<!-- si la versión [eq 5.0] -->
En C# 5.0 `await` no se puede usar en `catch` y `finally`.

<!-- versión final si -->

<!-- si la versión [gte 6.0] -->
[Con C# 6.0][2] `await` se puede usar en `catch` y `finally`.
<!-- versión final si -->


[1]: https://msdn.microsoft.com/en-us/magazine/jj991977.aspx
[2]: https://www.wikiod.com/es/docs/c%23/24/c-sharp-6-0-features/50/await-in-catch-and-finally#t=201607281146527675886

## resumen
Una clase marcada con la palabra clave `resumen` no se puede instanciar.

Una clase *debe* marcarse como abstracta si contiene miembros abstractos o si hereda miembros abstractos que no implementa. Una clase *puede* marcarse como abstracta incluso si no hay miembros abstractos involucrados.

Las clases abstractas generalmente se usan como clases base cuando alguna parte de la implementación necesita ser especificada por otro componente.

    abstract class Animal 
    {
        string Name { get; set; }
        public abstract void MakeSound();
    }
    
    public class Cat : Animal 
    {
        public override void MakeSound()
        {
            Console.WriteLine("Meov meov");
        }
    }
    
    public class Dog : Animal 
    {   
        public override void MakeSound()
        {
            Console.WriteLine("Bark bark");
        }
    }
    
    Animal cat = new Cat();       // Allowed due to Cat deriving from Animal
    cat.MakeSound();              // will print out "Meov meov"    

    Animal dog = new Dog();       // Allowed due to Dog deriving from Animal
    dog.MakeSound();              // will print out "Bark bark"

    Animal animal = new Animal(); // Not allowed due to being an abstract class

Un método, propiedad o evento marcado con la palabra clave `abstract` indica que se espera que la implementación de ese miembro se proporcione en una subclase. Como se mencionó anteriormente, los miembros abstractos solo pueden aparecer en clases abstractas.

    abstract class Animal 
    {
       public abstract string Name { get; set; }
    }
    
    public class Cat : Animal 
    {
        public override string Name { get; set; }
    }
    
    public class Dog : Animal 
    {
        public override string Name { get; set; }
    }

## fijado
La instrucción fixed fija la memoria en una ubicación. Los objetos en la memoria generalmente se mueven, esto hace posible la recolección de basura. Pero cuando usamos punteros inseguros a direcciones de memoria, esa memoria no debe moverse.

- Usamos la declaración fija para garantizar que el recolector de basura no reubique los datos de la cadena.

<h3>Variables Fijas</h3>

    var myStr = "Hello world!";
    
    fixed (char* ptr = myStr)
    {
        // myStr is now fixed (won't be [re]moved by the Garbage Collector).
        // We can now do something with ptr.
    }

<sup>*Usado en un contexto inseguro.*</sup>


<h3>Tamaño de matriz fijo</h3>

    unsafe struct Example
    {
        public fixed byte SomeField[8];
        public fixed char AnotherField[64];
    }

`fixed` solo puede usarse en campos en una `struct` (también debe usarse en un contexto no seguro).


## defecto
Para clases, interfaces, delegados, arreglos, anulables (como int?) y tipos de punteros, `default(TheType)` devuelve `null`:

    class MyClass {}
    Debug.Assert(default(MyClass) == null);
    Debug.Assert(default(string) == null);

Para estructuras y enumeraciones, `default(TheType)` devuelve lo mismo que `new TheType()`:

    struct Coordinates
    {
        public int X { get; set; }
        public int Y { get; set; }
    }

    struct MyStruct
    {
        public string Name { get; set; }
        public Coordinates Location { get; set; }
        public Coordinates? SecondLocation { get; set; }
        public TimeSpan Duration { get; set; }
    }

    var defaultStruct = default(MyStruct);
    Debug.Assert(defaultStruct.Equals(new MyStruct()));
    Debug.Assert(defaultStruct.Location.Equals(new Coordinates()));
    Debug.Assert(defaultStruct.Location.X == 0);
    Debug.Assert(defaultStruct.Location.Y == 0);
    Debug.Assert(defaultStruct.SecondLocation == null);
    Debug.Assert(defaultStruct.Name == null);
    Debug.Assert(defaultStruct.Duration == TimeSpan.Zero);

`default(T)` puede ser particularmente útil cuando `T` es un parámetro genérico para el cual no existe ninguna restricción para decidir si `T` es un tipo de referencia o un tipo de valor, por ejemplo:

    public T GetResourceOrDefault<T>(string resourceName)
    {
       if (ResourceExists(resourceName))
       {
          return (T)GetResource(resourceName);
       }
       else
       {
          return default(T);
       }
    }

## es
Comprueba si un objeto es compatible con un tipo determinado, es decir, si un objeto es una instancia del tipo `BaseInterface` o un tipo que se deriva de `BaseInterface`:

    interface BaseInterface {}
    class BaseClass : BaseInterface {}
    class DerivedClass : BaseClass {}

    var d = new DerivedClass();
    Console.WriteLine(d is DerivedClass);  // True
    Console.WriteLine(d is BaseClass);     // True
    Console.WriteLine(d is BaseInterface); // True
    Console.WriteLine(d is object);        // True
    Console.WriteLine(d is string);        // False
    
    var b = new BaseClass();
    Console.WriteLine(b is DerivedClass);  // False
    Console.WriteLine(b is BaseClass);     // True
    Console.WriteLine(b is BaseInterface); // True
    Console.WriteLine(b is object);        // True
    Console.WriteLine(b is string);        // False

Si la intención del lanzamiento es usar el objeto, se recomienda usar la palabra clave [`as`](https://www.wikiod.com/es/docs/c%23/26/keywords/138/as)'

    interface BaseInterface {}
    class BaseClass : BaseInterface {}
    class DerivedClass : BaseClass {}

    var d = new DerivedClass();
    Console.WriteLine(d is DerivedClass);  // True - valid use of 'is'
    Console.WriteLine(d is BaseClass);     // True - valid use of 'is'
    
    if(d is BaseClass){
        var castedD = (BaseClass)d;
        castedD.Method(); // valid, but not best practice
    }

    var asD = d as BaseClass;

    if(asD!=null){
        asD.Method(); //prefered method since you incur only one unboxing penalty
    }

Pero, desde C# 7 [`coincidencia de patrones`](https://www.wikiod.com/es/docs/c%23/1936/c-sharp-7-0-features/13323/pattern-matching#t=201707130940065371224) la característica se extiende el operador es para verificar un tipo y declarar una nueva variable al mismo tiempo. La misma parte del código con C# 7:

<!-- si la versión [gte 7.0] -->

    if(d is BaseClass asD ){
        asD.Method();
    }
<!-- versión final si -->

## sellado
Cuando se aplica a una clase, el modificador 'sellado' evita que otras clases hereden de él.

    class A { }
    sealed class B : A { }
    class C : B { } //error : Cannot derive from the sealed class

Cuando se aplica a un método `virtual` (o propiedad virtual), el modificador `sellado` evita que este método (propiedad) sea *anulado* en clases derivadas.

    public class A 
    {
        public sealed override string ToString() // Virtual method inherited from class Object
        {
            return "Do not override me!";
        }
    }

    public class B: A 
    {
        public override string ToString() // Compile time error
        { 
            return "An attempt to override"; 
        }
    }

## solo lectura
La palabra clave `readonly` es un modificador de campo. Cuando una declaración de campo incluye un modificador `solo lectura`, las asignaciones a ese campo solo pueden ocurrir como parte de la declaración o en un constructor en la misma clase.

La palabra clave `readonly` es diferente de la palabra clave `const`. Un campo `const` solo se puede inicializar en la declaración del campo. Un campo `solo lectura` se puede inicializar en la declaración o en un constructor. Por lo tanto, los campos `solo lectura` pueden tener diferentes valores según el constructor utilizado.

La palabra clave `solo lectura` se usa a menudo cuando se inyectan dependencias.

    class Person
    {
        readonly string _name;
        readonly string _surname = "Surname";

        Person(string name)
        {
            _name = name;
        }
        void ChangeName()
        {
            _name = "another name"; // Compile error
            _surname = "another surname"; // Compile error
        }
    }


> Nota: Declarar un campo *readonly* no implica *inmutabilidad*. Si el campo es un *tipo de referencia*, entonces se puede cambiar el **contenido** del objeto. *Readonly* generalmente se usa para evitar que el objeto se **sobrescriba** y se asigne solo durante la **creación de instancias** de ese objeto.

> Nota: dentro del constructor se puede reasignar un campo de solo lectura

    public class Car
    {
        public double Speed {get; set;}
    }

    //In code

    private readonly Car car = new Car();

    private void SomeMethod()
    {
        car.Speed = 100;
    }

## tipo de
Devuelve el `Tipo` de un objeto, sin necesidad de instanciarlo.

    Type type = typeof(string);
    Console.WriteLine(type.FullName); //System.String
    Console.WriteLine("Hello".GetType() == type); //True
    Console.WriteLine("Hello".GetType() == typeof(string)); //True

## este
La palabra clave `this` se refiere a la instancia actual de clase (objeto). De esa manera, se pueden distinguir dos variables con el mismo nombre, una a nivel de clase (un campo) y otra que es un parámetro (o variable local) de un método.
    
    public MyClass {
        int a;
    
        void set_a(int a)
        {
            //this.a refers to the variable defined outside of the method,
            //while a refers to the passed parameter.
            this.a = a;
        }
    }

Otros usos de la palabra clave son [encadenar sobrecargas de constructores no estáticos][1]:

    public MyClass(int arg) : this(arg, null)
    {
    }

y escribiendo [indexadores][2]:

    public string this[int idx1, string idx2]
    {
        get { /* ... */ }
        set { /* ... */ }
    }

y declarando [métodos de extensión][3]:

    public static int Count<TItem>(this IEnumerable<TItem> source)
    {
        // ...
    }

Si no hay conflicto con una variable o parámetro local, es una cuestión de estilo si se usa `this` o no, por lo que `this.MemberOfType` y `MemberOfType` serían equivalentes en ese caso. Consulte también la palabra clave [`base`][4].

Tenga en cuenta que si se va a llamar a un método de extensión en la instancia actual, se requiere `this`. Por ejemplo, si está dentro de un método no estático de una clase que implementa `IEnumerable<>` y desea llamar a la extensión `Count` desde antes, debe usar:

    this.Count()  // works like StaticClassForExtensionMethod.Count(this)

y 'esto' no se puede omitir allí.


[1]: https://www.wikiod.com/es/docs/c%23/25/constructors-destructors/56/calling-a-constructor-from-another-constructor#t=201607231911138150753
[2]: https://www.wikiod.com/es/docs/c%23/1660/indexer#t=201607252101420586035
[3]: https://www.wikiod.com/es/docs/c%23/20/extension-methods#t=20160723191025670507
[4]: https://www.wikiod.com/es/docs/c%23/26/keywords/1840/base#t=201607261455204441752

## para cada
`foreach` se usa para iterar sobre los elementos de una matriz o los elementos dentro de una colección que implementa [`IEnumerable`][3]✝.

    var lines = new string[] { 
        "Hello world!", 
        "How are you doing today?", 
        "Goodbye"
    };

    foreach (string line in lines)
    {
        Console.WriteLine(line);
    }

Esto generará

> "¡Hola mundo!"
> "¿Cómo te va hoy?"
> "Adiós"

[Demostración en vivo en .NET Fiddle](https://dotnetfiddle.net/0jy78m)

Puede salir del ciclo `foreach` en cualquier momento usando la palabra clave [break][1] o pasar a la siguiente iteración usando la palabra clave [continue][2].

    var numbers = new int[] {1, 2, 3, 4, 5, 6};

    foreach (var number in numbers)
    {
        // Skip if 2
        if (number == 2)
            continue;

        // Stop iteration if 5
        if (number == 5)
            break;

        Console.Write(number + ", ");
    }

    // Prints: 1, 3, 4, 

[Demostración en vivo en .NET Fiddle](https://dotnetfiddle.net/dfSAbF)

Tenga en cuenta que el orden de iteración está garantizado *solo* para ciertas colecciones, como matrices y `List`, pero **no** garantizado para muchas otras colecciones.

----------

✝ Mientras que `IEnumerable` se usa normalmente para indicar colecciones enumerables, `foreach` solo requiere que la colección exponga públicamente el método `objeto GetEnumerator()`, que debe devolver un objeto que exponga el método `bool MoveNext()` y el ` objeto Actual { obtener; }` propiedad.

[1]: https://www.wikiod.com/es/docs/c%23/26/keywords/2858/break
[2]: https://www.wikiod.com/es/docs/c%23/26/keywords/154/continue
[3]: https://msdn.microsoft.com/en-us/library/system.collections.ienumerable(v=vs.110).aspx

## dinámico
La palabra clave `dynamic` se utiliza con [objetos tipificados dinámicamente][1]. Los objetos declarados como "dinámicos" renuncian a las comprobaciones estáticas en tiempo de compilación y, en cambio, se evalúan en tiempo de ejecución.

    using System;
    using System.Dynamic;
    
    dynamic info = new ExpandoObject();
    info.Id = 123;
    info.Another = 456;
    
    Console.WriteLine(info.Another);
    // 456
    
    Console.WriteLine(info.DoesntExist);
    // Throws RuntimeBinderException

El siguiente ejemplo utiliza `dynamic` con la biblioteca Json.NET de Newtonsoft para leer fácilmente los datos de un archivo JSON deserializado.

    try
    {
        string json = @"{ x : 10, y : ""ho""}";
        dynamic deserializedJson = JsonConvert.DeserializeObject(json);
        int x = deserializedJson.x;
        string y = deserializedJson.y;
        // int z = deserializedJson.z; // throws RuntimeBinderException
    }
    catch (RuntimeBinderException e)
    {
        // This exception is thrown when a property
        // that wasn't assigned to a dynamic variable is used
    }

[1]: https://www.wikiod.com/es/docs/c%23/762/dynamic-type#t=201607212330428041437

Hay algunas limitaciones asociadas con la palabra clave dinámica. Uno de ellos es el uso de métodos de extensión. El siguiente ejemplo agrega un método de extensión para la cadena: `SayHello`.

    static class StringExtensions
    {
        public static string SayHello(this string s) => $"Hello {s}!";
    }

El primer enfoque será llamarlo como de costumbre (como para una cadena):

    var person = "Person";
    Console.WriteLine(person.SayHello());

    dynamic manager = "Manager";
    Console.WriteLine(manager.SayHello()); // RuntimeBinderException

No hay error de compilación, pero en el tiempo de ejecución obtienes una `RuntimeBinderException`. La solución para esto será llamar al método de extensión a través de la clase estática:

    var helloManager = StringExtensions.SayHello(manager);
    Console.WriteLine(helloManager);

## intentar, atrapar, finalmente, lanzar
`try`, `catch`, `finally` y `throw` le permiten manejar excepciones en su código.

    var processor = new InputProcessor();

    // The code within the try block will be executed. If an exception occurs during execution of
    // this code, execution will pass to the catch block corresponding to the exception type.
    try 
    {
        processor.Process(input);
    }
    // If a FormatException is thrown during the try block, then this catch block
    // will be executed.
    catch (FormatException ex)
    {
        // Throw is a keyword that will manually throw an exception, triggering any catch block that is
        // waiting for that exception type. 
        throw new InvalidOperationException("Invalid input", ex);
    }
    // catch can be used to catch all or any specific exceptions. This catch block,
    // with no type specified, catches any exception that hasn't already been caught
    // in a prior catch block.
    catch
    {
        LogUnexpectedException(); 
        throw; // Re-throws the original exception.
    }
    // The finally block is executed after all try-catch blocks have been; either after the try has
    // succeeded in running all commands or after all exceptions have been caught. 
    finally
    {
        processor.Dispose();
    }

**Nota:** La palabra clave `return` se puede usar en el bloque `try`, y el bloque `finally` aún se ejecutará (justo antes de regresar). Por ejemplo:

    try 
    {
        connection.Open();
        return connection.Get(query);
    } 
    finally 
    {
        connection.Close();
    }
 
La sentencia `connection.Close()` se ejecutará antes de que se devuelva el resultado de `connection.Get(query)`.

## espacio de nombres
La palabra clave `namespace` es una construcción de organización que nos ayuda a comprender cómo se organiza una base de código. Los espacios de nombres en C# son espacios virtuales en lugar de estar en una carpeta física.

    namespace StackOverflow
    {
        namespace Documentation
        {
            namespace CSharp.Keywords
            {
                public class Program
                {
                    public static void Main()
                    {
                        Console.WriteLine(typeof(Program).Namespace);
                        //StackOverflow.Documentation.CSharp.Keywords
                    }
                }
            }
        }
    }

Los espacios de nombres en C# también se pueden escribir en sintaxis encadenada. Lo siguiente es equivalente a lo anterior:

    namespace StackOverflow.Documentation.CSharp.Keywords
    {
        public class Program
        {
            public static void Main()
            {
                Console.WriteLine(typeof(Program).Namespace);
                //StackOverflow.Documentation.CSharp.Keywords
            }
        }
    }

## vacío
La palabra reservada `"void"` es un alias del tipo `System.Void` y tiene dos usos:

1. Declare un método que no tenga un valor de retorno:


    public void DoSomething()
    {
        // Do some work, don't return any value to the caller.
    }

Un método con un tipo de devolución de vacío aún puede tener la palabra clave `return` en su cuerpo. Esto es útil cuando desea salir de la ejecución del método y devolver el flujo a la persona que llama:

    public void DoSomething()
    {
        // Do some work...

        if (condition)
            return;

        // Do some more work if the condition evaluated to false.
    }

2. Declarar un puntero a un tipo desconocido en un contexto inseguro.

En un contexto no seguro, un tipo puede ser un tipo de puntero, un tipo de valor o un tipo de referencia. Una declaración de tipo de puntero suele ser `tipo* identificador`, donde el tipo es un tipo conocido, es decir, `int* myInt`, pero también puede ser `vacío* identificador`, donde el tipo es desconocido.

Tenga en cuenta que declarar un tipo de puntero vacío [Microsoft desaconseja] [1]


[1]: https://msdn.microsoft.com/en-us/library/y31yhkeb.aspx

## referencia, fuera
Las palabras clave `ref` y `out` hacen que un argumento se pase por referencia, no por valor. Para los tipos de valor, esto significa que el destinatario de la llamada puede cambiar el valor de la variable.

    int x = 5;
    ChangeX(ref x);
    // The value of x could be different now

Para los tipos de referencia, la instancia en la variable no solo se puede modificar (como es el caso sin `ref`), sino que también se puede reemplazar por completo:

    Address a = new Address();
    ChangeFieldInAddress(a);
    // a will be the same instance as before, even if it is modified
    CreateANewInstance(ref a);
    // a could be an entirely new instance now

La principal diferencia entre la palabra clave `out` y `ref` es que `ref` requiere que la variable sea inicializada por la persona que llama, mientras que `out` pasa esa responsabilidad a la persona que recibe la llamada.

Para usar un parámetro `out`, tanto la definición del método como el método de llamada deben usar explícitamente la palabra clave `out`.

    int number = 1;
    Console.WriteLine("Before AddByRef: " + number); // number = 1
    AddOneByRef(ref number);
    Console.WriteLine("After AddByRef: " + number);  // number = 2
    SetByOut(out number);
    Console.WriteLine("After SetByOut: " + number);  // number = 34

    void AddOneByRef(ref int value)
    {
        value++;
    }
    
    void SetByOut(out int value)
    {
        value = 34;
    }

[<kbd>Demostración en vivo en .NET Fiddle</kbd>](https://dotnetfiddle.net/ma2ikc)
    
Lo siguiente *no* compila, porque los parámetros `out` deben tener un valor asignado antes de que el método regrese (se compilaría usando `ref` en su lugar):

    void PrintByOut(out int value)
    {
        Console.WriteLine("Hello!");
    }

**utilizando la palabra clave como modificador genérico**

La palabra clave `out` también se puede utilizar en parámetros de tipo genérico al definir interfaces genéricas y delegados. En este caso, la palabra clave `out` especifica que el parámetro de tipo es covariante.

> La covarianza le permite utilizar un tipo más derivado que el especificado por el parámetro genérico. Esto permite la conversión implícita de clases que implementan interfaces variantes y la conversión implícita de tipos delegados. La covarianza y la contravarianza se admiten para los tipos de referencia, pero no para los tipos de valor. -MSDN

    //if we have an interface like this
    interface ICovariant<out R> { }
    
    //and two variables like
    ICovariant<Object> iobj = new Sample<Object>();
    ICovariant<String> istr = new Sample<String>();

    // then the following statement is valid
    // without the out keyword this would have thrown error
    iobj = istr; // implicit conversion occurs here
   

## base
La palabra clave **`base`** se utiliza para acceder a los miembros de una clase base. Se usa comúnmente para llamar implementaciones base de métodos virtuales, o para especificar a qué constructor base se debe llamar.

**Elegir un constructor**

    public class Child : SomeBaseClass {
        public Child() : base("some string for the base class")
        {
        }
    }

    public class SomeBaseClass {
        public SomeBaseClass()
        {
            // new Child() will not call this constructor, as it does not have a parameter
        }
        public SomeBaseClass(string message)
        {
            // new Child() will use this base constructor because of the specified parameter in Child's constructor
            Console.WriteLine(message);
        }
    }

**Implementación base de llamadas del método virtual**

    public override void SomeVirtualMethod() {
        // Do something, then call base implementation
        base.SomeVirtualMethod();
    }

Es posible usar la palabra clave base para llamar a una implementación base desde cualquier método. Esto vincula la llamada al método directamente con la implementación base, lo que significa que incluso si las nuevas clases secundarias anulan un método virtual, se seguirá llamando a la implementación base, por lo que debe usarse con precaución.

    public class Parent
    {
        public virtual int VirtualMethod()
        {
            return 1;
        }
    }

    public class Child : Parent
    {
        public override int VirtualMethod() {
            return 11;
        }

        public int NormalMethod()
        {
            return base.VirtualMethod();
        }

        public void CallMethods()
        {
            Assert.AreEqual(11, VirtualMethod());

            Assert.AreEqual(1, NormalMethod());
            Assert.AreEqual(1, base.VirtualMethod());
        }
    }

    public class GrandChild : Child
    {
        public override int VirtualMethod()
        {
            return 21;
        }

        public void CallAgain()
        {
            Assert.AreEqual(21, VirtualMethod());
            Assert.AreEqual(11, base.VirtualMethod());

            // Notice that the call to NormalMethod below still returns the value
            // from the extreme base class even though the method has been overridden
            // in the child class.
            Assert.AreEqual(1, NormalMethod());
        }
    }



## parámetros
`params` permite que un parámetro de método reciba un número variable de argumentos, es decir, se permiten cero, uno o múltiples argumentos para ese parámetro.

    static int AddAll(params int[] numbers)
    {
        int total = 0;
        foreach (int number in numbers)
        {
            total += number;
        }
        
        return total;
    }

Ahora se puede llamar a este método con una lista típica de argumentos `int`, o una matriz de enteros.

    AddAll(5, 10, 15, 20);                // 50
    AddAll(new int[] { 5, 10, 15, 20 });  // 50

`params` debe aparecer como máximo una vez y, si se usa, debe ser **último** en la lista de argumentos, incluso si el tipo subsiguiente es diferente al de la matriz.

----

Tenga cuidado al sobrecargar funciones al usar la palabra clave `params`. C# prefiere hacer coincidir sobrecargas más específicas antes de intentar usar sobrecargas con `params`. Por ejemplo, si tiene dos métodos:

    static double Add(params double[] numbers)
    {
        Console.WriteLine("Add with array of doubles");
        double total = 0.0;
        foreach (double number in numbers)
        {
            total += number;
        }
        
        return total;
    }

    static int Add(int a, int b)
    {
        Console.WriteLine("Add with 2 ints");
        return a + b;
    }

Entonces, la sobrecarga específica de 2 argumentos tendrá prioridad antes de intentar la sobrecarga `params`.

    Add(2, 3);      //prints "Add with 2 ints"
    Add(2, 3.0);    //prints "Add with array of doubles" (doubles are not ints)
    Add(2, 3, 4);   //prints "Add with array of doubles" (no 3 argument overload)


## flotante, doble, decimal
# flotar #

`float` es un alias del tipo de datos .NET `System.Single`. Permite almacenar números de punto flotante de precisión simple IEEE 754. Este tipo de datos está presente en `mscorlib.dll`, al que todos los proyectos de C# hacen referencia implícitamente cuando los crea.

Rango aproximado: -3,4 × 10<sup>38</sup> a 3,4 × 10<sup>38</sup>

Precisión decimal: 6-9 dígitos significativos

**Notación**:

    float f = 0.1259;
    var f1 = 0.7895f; // f is literal suffix to represent float values 

> Debe tenerse en cuenta que el tipo `flotante` a menudo da como resultado
> errores de redondeo. En aplicaciones donde la precisión es importante, otros
> tipos de datos deben ser considerados.


----------
# doble #

`doble` es un alias para el tipo de datos .NET `System.Double`. Representa un número de coma flotante de 64 bits de doble precisión. Este tipo de datos está presente en `mscorlib.dll`, al que se hace referencia implícitamente en cualquier proyecto de C#.

Rango: ±5,0 × 10<sup>−324</sup> a ±1,7 × 10<sup>308</sup>

Precisión decimal: 15-16 dígitos significativos

**Notación**:

    double distance = 200.34; // a double value
    double salary = 245; // an integer implicitly type-casted to double value
    var marks = 123.764D; // D is literal suffix to represent double values

----------
# decimal #

`decimal` es un alias del tipo de datos .NET `System.Decimal`. Representa una palabra clave que indica un tipo de datos de 128 bits. Comparado con los tipos de coma flotante, el tipo decimal tiene más precisión y un rango más pequeño, lo que lo hace apropiado para cálculos financieros y monetarios. Este tipo de datos está presente en `mscorlib.dll`, al que se hace referencia implícitamente en cualquier proyecto de C#.

Rango: -7,9 × 10<sup>28</sup> a 7,9 × 10<sup>28</sup>

Precisión decimal: 28-29 dígitos significativos

**Notación**:

    decimal payable = 152.25m; // a decimal value
    var marks = 754.24m; // m is literal suffix to represent decimal values

## carácter
Un char es una sola letra almacenada dentro de una variable. Es un tipo de valor integrado que ocupa dos bytes de espacio de memoria. Representa el tipo de datos `System.Char` que se encuentra en `mscorlib.dll`, al que todos los proyectos de C# hacen referencia implícitamente cuando los crea.

Hay varias maneras de hacer esto.
1) `carácter c = 'c';`
2) `char c = '\u0063'; //Unicode`
3) `char c = '\x0063'; //hexadecimal`
4) `carácter c = (carácter)99;//Integral`

Un carácter se puede convertir implícitamente a `ushort, int, uint, long, ulong, float, double` o `decimal` y devolverá el valor entero de ese carácter.

    ushort u = c;
devuelve 99 etc

Sin embargo, no hay conversiones implícitas de otros tipos a char. En su lugar, debes lanzarlos.
 

    ushort u = 99;
     char c = (char)u;



## operador
La mayoría de los [operadores integrados][OPERADORES] (incluidos los operadores de conversión) se pueden sobrecargar utilizando la palabra clave `operador` junto con los modificadores `público` y `estático`.

Los operadores vienen en tres formas: operadores unarios, operadores binarios y operadores de conversión.

Los operadores unarios y binarios requieren al menos un parámetro del mismo tipo que el tipo contenedor, y algunos requieren un operador de coincidencia complementario.

Los operadores de conversión deben convertir hacia o desde el tipo adjunto.

    public struct Vector32
    {
        
        public Vector32(int x, int y)
        {
            X = x;
            Y = y;
        }
        
        public int X { get; }
        public int Y { get; }

        public static bool operator ==(Vector32 left, Vector32 right)
            => left.X == right.X && left.Y == right.Y;

        public static bool operator !=(Vector32 left, Vector32 right)
            => !(left == right);

        public static Vector32 operator +(Vector32 left, Vector32 right)
            => new Vector32(left.X + right.X, left.Y + right.Y);

        public static Vector32 operator +(Vector32 left, int right)
            => new Vector32(left.X + right, left.Y + right);

        public static Vector32 operator +(int left, Vector32 right)
            => right + left;

        public static Vector32 operator -(Vector32 left, Vector32 right)
            => new Vector32(left.X - right.X, left.Y - right.Y);

        public static Vector32 operator -(Vector32 left, int right)
            => new Vector32(left.X - right, left.Y - right);

        public static Vector32 operator -(int left, Vector32 right)
            => right - left;

        public static implicit operator Vector64(Vector32 vector)
            => new Vector64(vector.X, vector.Y);

        public override string ToString() => $"{{{X}, {Y}}}";

    }

    public struct Vector64
    {

        public Vector64(long x, long y)
        {
            X = x;
            Y = y;
        }

        public long X { get; }
        public long Y { get; }

        public override string ToString() => $"{{{X}, {Y}}}";

    }

**Ejemplo**

    var vector1 = new Vector32(15, 39);
    var vector2 = new Vector32(87, 64);
            
    Console.WriteLine(vector1 == vector2); // false
    Console.WriteLine(vector1 != vector2); // true
    Console.WriteLine(vector1 + vector2);  // {102, 103}
    Console.WriteLine(vector1 - vector2);  // {-72, -25}

[OPERADORES]: https://msdn.microsoft.com/en-us/library/6a71f45d.aspx

## Seguir
Pase inmediatamente el control a la siguiente iteración de la construcción del bucle envolvente (for, foreach, do, while):

    for (var i = 0; i < 10; i++)
    {
        if (i < 5)
        {
            continue;
        }
        Console.WriteLine(i);
    }

Producción:

> 5
> 6
> 7
> 8
> 9

[<kbd>Demostración en vivo en .NET Fiddle</kbd>](https://dotnetfiddle.net/H2NB0V)

    var stuff = new [] {"a", "b", null, "c", "d"};

    foreach (var s in stuff)
    {
        if (s == null)
        {
            continue;
        }           
        Console.WriteLine(s);
    }

Producción:

> un
> segundo
>c
> re

[Demostración en vivo en .NET Fiddle](https://dotnetfiddle.net/l1JPiI)

## tiempo
El operador `while` itera sobre un bloque de código hasta que la consulta condicional es igual a falso o el código se interrumpe con [`goto`](https://www.wikiod.com/es/docs/c%23/26/keywords/193/ ir a), [`return`](https://www.wikiod.com/es/docs/c%23/26/keywords/4600/return), [`break`](https://www.wikiod.com/es/docs/c% 23/26/keywords/2858/break) o instrucción `throw`.

Sintaxis de la palabra clave `while`:

> while( *condición* )
> { *bloque de código;* }

Ejemplo:

    int i = 0;
    while (i++ < 5)
    {
        Console.WriteLine("While is on loop number {0}.", i);
    }

Producción:

>"Mientras está en el bucle número 1". \
"Mientras está en el bucle número 2".
"Mientras está en el bucle número 3".
"Mientras está en el bucle número 4".
"Mientras está en el bucle número 5".

[<kbd>Demostración en vivo en .NET Fiddle</kbd>](https://dotnetfiddle.net/KRQjV0)

Un bucle while está **controlado por entrada**, ya que la condición se verifica **antes** de la ejecución del bloque de código adjunto. Esto significa que el ciclo while no ejecutaría sus declaraciones si la condición es falsa.

    bool a = false;
    
    while (a == true)
    {
        Console.WriteLine("This will never be printed.");
    }

Dar una condición 'while' sin aprovisionarla para que se vuelva falsa en algún momento dará como resultado un bucle infinito o sin fin. En la medida de lo posible, esto debe evitarse, sin embargo, puede haber algunas circunstancias excepcionales en las que lo necesite.

Puede crear un bucle de este tipo de la siguiente manera:

    while (true)
    {
    //...
    }

Tenga en cuenta que el compilador de C# transformará bucles como

    while (true)
    {
    // ...
    }

o

    for(;;)
    {
    // ...
    }

dentro

    {
    :label
    // ...
    goto label;
    }

Tenga en cuenta que un ciclo while puede tener cualquier condición, sin importar cuán compleja sea, siempre que evalúe (o devuelva) un valor booleano (bool). También puede contener una función que devuelve un valor booleano (ya que dicha función se evalúa al mismo tipo que una expresión como `a==x'). Por ejemplo,

    while (AgriculturalService.MoreCornToPick(myFarm.GetAddress()))
    {
        myFarm.PickCorn();
    }

## devolver
> MSDN: La declaración de retorno finaliza la ejecución del método en el que
> aparece y devuelve el control al método de llamada. También puede
> devuelve un valor opcional. Si el método es de tipo void, el retorno
> declaración puede ser omitida.

    public int Sum(int valueA, int valueB)
    {
        return valueA + valueB;
    }

    
    public void Terminate(bool terminateEarly)
    {
        if (terminateEarly) return; // method returns to caller if true was passed in
        else Console.WriteLine("Not early"); // prints only if terminateEarly was false
    }

## nulo
Una variable de un tipo de referencia puede contener una referencia válida a una instancia o una referencia nula. La referencia nula es el valor predeterminado de las variables de tipo de referencia, así como los tipos de valor que aceptan valores NULL.

`null` es la palabra clave que representa una referencia nula.

Como expresión, se puede utilizar para asignar la referencia nula a variables de los tipos antes mencionados:

    object a = null;
    string b = null;
    int? c = null;
    List<int> d  = null;

A los tipos de valor que no aceptan valores NULL no se les puede asignar una referencia nula. Todas las siguientes asignaciones no son válidas:

    int a = null; 
    float b = null;
    decimal c = null;

La referencia nula *no* debe confundirse con instancias válidas de varios tipos, como:

- una lista vacía (`nueva Lista<int>()`)
- una cadena vacía (`""`)
- el número cero (`0`, `0f`, `0m`)
- el caracter nulo ( `'\0'` )

A veces, tiene sentido comprobar si algo es nulo o un objeto vacío/predeterminado. El método System.String.IsNullOrEmpty(String) se puede usar para verificar esto, o puede implementar su propio método equivalente.

    private void GreetUser(string userName)
    {
        if (String.IsNullOrEmpty(userName))
        {
            //The method that called us either sent in an empty string, or they sent us a null reference. Either way, we need to report the problem.
            throw new InvalidOperationException("userName may not be null or empty.");
        }
        else
        {
            //userName is acceptable.
            Console.WriteLine("Hello, " + userName + "!");
        }
    }

## cuerda
`string` es un alias del tipo de datos .NET `System.String`, que permite almacenar texto (secuencias de caracteres).

Notación:

    string a = "Hello";
    var b = "world";
    var f = new string(new []{ 'h', 'i', '!' }); // hi!

Cada carácter de la cadena está codificado en UTF-16, lo que significa que cada carácter requerirá un mínimo de 2 bytes de espacio de almacenamiento.

## unidad
Un **entero sin signo**, o **uint**, es un tipo de datos numérico que solo puede contener números enteros positivos. Como sugiere su nombre, representa un entero de 32 bits sin signo. La palabra clave **uint** en sí misma es un alias para el tipo de sistema de tipo común `System.UInt32`. Este tipo de datos está presente en `mscorlib.dll`, al que todos los proyectos de C# hacen referencia implícitamente cuando los crea. Ocupa cuatro bytes de espacio de memoria.

Los enteros sin signo pueden contener cualquier valor de 0 a 4,294,967,295.


*Ejemplos de cómo y ahora no declarar enteros sin signo*

    uint i = 425697; // Valid expression, explicitly stated to compiler
    var i1 = 789247U; // Valid expression, suffix allows compiler to determine datatype
    uint x = 3.0; // Error, there is no implicit conversion

----------

**Tenga en cuenta:** Según [Microsoft][1], se recomienda utilizar el tipo de datos **[int][2]** siempre que sea posible, ya que el tipo de datos **uint** no cumple con CLS.


[1]: https://msdn.microsoft.com/en-us/library/x0sksh43.aspx
[2]: https://www.wikiod.com/es/docs/c%23/26/keywords#t=201608192209189084166

## usando
Hay dos tipos de uso de la palabra clave `using`, `using sentencia` y `using directiva`:

1. **usando declaración**:

    The `using` keyword ensures that objects that implement the `IDisposable` interface are properly disposed after usage. There is a separate topic for the [using statement][1]
    
2. **directiva de uso**

La directiva `using` tiene tres usos, consulte la [página msdn para la directiva using][2]. Hay un tema separado para la [directiva using][3].


[1]: https://www.wikiod.com/es/docs/c%23/38/using-statement#t=201607311905386691069
[2]: https://msdn.microsoft.com/en-us/library/sf0df423.aspx
[3]: https://www.wikiod.com/es/docs/c%23/52/using-directive#t=201607311908368095223

## estático
El modificador `static` se usa para declarar un miembro estático, que no necesita ser instanciado para poder acceder, sino que se accede simplemente a través de su nombre, es decir, `DateTime.Now`.

`static` se puede usar con clases, campos, métodos, propiedades, operadores, eventos y constructores.

Mientras que una instancia de una clase contiene una copia separada de todos los campos de instancia de la clase, solo hay una copia de cada campo estático.

    class A
    {
        static public int count = 0;

        public A()
        {
            count++;
        }
    }

    class Program
    {
        static void Main(string[] args)
        {
            A a = new A();
            A b = new A();
            A c = new A();

            Console.WriteLine(A.count); // 3 
        }
    }

`count` es igual al número total de instancias de la clase `A`.

El modificador estático también se puede usar para declarar un constructor estático para una clase, para inicializar datos estáticos o ejecutar código que solo necesita llamarse una vez. Los constructores estáticos se llaman antes de que se haga referencia a la clase por primera vez.

    class A
    {
        static public DateTime InitializationTime;

        // Static constructor
        static A()
        {
            InitializationTime = DateTime.Now;
            // Guaranteed to only run once
            Console.WriteLine(InitializationTime.ToString());
        }
    }

Una `clase estática` se marca con la palabra clave `static` y se puede usar como un contenedor beneficioso para un conjunto de métodos que funcionan con parámetros, pero que no necesariamente requieren estar vinculados a una instancia. Debido a la naturaleza `estática` de la clase, no se puede instanciar, pero puede contener un `constructor estático`. Algunas características de una `clase estática` incluyen:

- No se puede heredar
- No se puede heredar de nada que no sea `Objeto`
- Puede contener un constructor estático pero no un constructor de instancias
- Solo puede contener miembros estáticos
- Está sellado

El compilador también es amigable e informará al desarrollador si existe algún miembro de la instancia dentro de la clase. Un ejemplo sería una clase estática que convierte entre métricas de EE. UU. y Canadá:

    static class ConversionHelper {
        private static double oneGallonPerLitreRate = 0.264172;

        public static double litreToGallonConversion(int litres) {
            return litres * oneGallonPerLitreRate;
        }
    }

Cuando las clases se declaran estáticas:

    public static class Functions
    {
      public static int Double(int value)
      {
        return value + value;
      }
    }

todas las funciones, propiedades o miembros dentro de la clase también deben declararse estáticos. No se puede crear ninguna instancia de la clase.
En esencia, una clase estática le permite crear paquetes de funciones que se agrupan de forma lógica.

Dado que C#6 `static` también se puede usar junto con `using` para importar miembros y métodos estáticos. Se pueden usar entonces sin nombre de clase.

Manera antigua, sin `usar estática`:
  
    using System;

    public class ConsoleApplication
    {
        public static void Main()
        {
             Console.WriteLine("Hello World!"); //Writeline is method belonging to static class Console
        }

    }
Ejemplo con `usando estática`

    using static System.Console;

    public class ConsoleApplication
    {
        public static void Main()
        {
             WriteLine("Hello World!"); //Writeline is method belonging to static class Console
        }

    }

**Inconvenientes**
---------

Si bien las clases estáticas pueden ser increíblemente útiles, vienen con sus propias advertencias:

• Una vez que se ha llamado a la clase estática, la clase se carga en la memoria y no se puede ejecutar a través del recolector de elementos no utilizados hasta que se descargue el AppDomain que alberga la clase estática.

• Una clase estática no puede implementar una interfaz.

## En t
`int` es un alias de `System.Int32`, que es un tipo de datos para enteros de 32 bits con signo. Este tipo de datos se puede encontrar en `mscorlib.dll`, al que todos los proyectos de C# hacen referencia implícitamente cuando los crea.

Rango: -2,147,483,648 a 2,147,483,647

    int int1 = -10007;
    var int2 = 2132012521;     

## cabeza
Palabra clave utilizada para enteros de 64 bits sin signo. Representa el tipo de datos `System.UInt64` que se encuentra en `mscorlib.dll`, al que todos los proyectos de C# hacen referencia implícitamente cuando los crea.

Rango: 0 a 18.446.744.073.709.551.615

    ulong veryLargeInt = 18446744073609451315;
    var anotherVeryLargeInt = 15446744063609451315UL;

## cerrar
`lock` proporciona seguridad de subprocesos para un bloque de código, de modo que solo un subproceso puede acceder a él dentro del mismo proceso. Ejemplo:

    private static object _lockObj = new object();
    static void Main(string[] args)
    {
        Task.Run(() => TaskWork());
        Task.Run(() => TaskWork());
        Task.Run(() => TaskWork());
    
        Console.ReadKey();
    }
    
    private static void TaskWork()
    {
        lock(_lockObj)
        {
            Console.WriteLine("Entered");
    
            Task.Delay(3000);
            Console.WriteLine("Done Delaying");
    
            // Access shared resources safely
    
            Console.WriteLine("Leaving");
        }   
    }
    
    Output:

    Entered
    Done Delaying
    Leaving
    Entered
    Done Delaying
    Leaving
    Entered
    Done Delaying
    Leaving

**Casos de uso:**

Siempre que tenga un bloque de código que podría producir efectos secundarios si lo ejecutan varios subprocesos al mismo tiempo. La palabra clave lock junto con un **objeto de sincronización compartido** (`_objLock` en el ejemplo) se puede usar para evitar eso.

Tenga en cuenta que `_objLock` no puede ser `nulo` y varios subprocesos que ejecutan el código deben usar la misma instancia de objeto (ya sea convirtiéndolo en un campo `estático` o usando la misma instancia de clase para ambos subprocesos)

Desde el lado del compilador, la palabra clave lock es un azúcar sintáctico que se reemplaza por `Monitor.Enter(_lockObj);` y `Monitor.Exit(_lockObj);`. Entonces, si reemplaza el bloqueo rodeando el bloque de código con estos dos métodos, obtendrá los mismos resultados. Puede ver el código real en [Syntactic sugar in C# - lock example][1]


[1]: https://www.wikiod.com/es/docs/c%23/2994/syntactic-sugar-in-c-sharp/10166/lock#t=20160723121800624366

## interno
La palabra clave [`internal`][1] es un modificador de acceso para tipos y miembros de tipos. Los tipos o miembros internos son **accesibles solo dentro de los archivos en el mismo ensamblaje**

*uso:*

    public class BaseClass 
    {
        // Only accessible within the same assembly
        internal static int x = 0;
    }


La diferencia entre los diferentes modificadores de acceso se aclara [aquí][2]

***Modificadores de acceso***

> **público**

> > El tipo o miembro puede ser accedido por cualquier otro código en la misma asamblea u otra asamblea que lo referencia.

> **privado**

> > El tipo o miembro sólo puede ser accedido por código en la misma clase o estructura.

> **protegido**

> > El tipo o miembro sólo puede ser accedido por código en la misma clase o estructura, o en una clase derivada.

> **interno**

> > El tipo o miembro puede ser accedido por cualquier código en la misma asamblea, pero no de otra asamblea.

> **interno protegido**

> > El tipo o miembro puede ser accedido por cualquier código en la misma asamblea, o por cualquier clase derivada en otra asamblea.

Cuando se establece **sin modificador de acceso**, se utiliza un modificador de acceso predeterminado. Por lo tanto, siempre hay algún tipo de modificador de acceso, incluso si no está configurado.


[1]: https://msdn.microsoft.com/en-us/library/7c5ka91b.aspx
[2]: http://stackoverflow.com/a/614844/266562

## dónde
`where` puede tener dos propósitos en C#: restringir el tipo en un argumento genérico y filtrar consultas LINQ.


En una clase genérica, consideremos

    public class Cup<T>
    {
        // ...
    }

T se llama un parámetro de tipo. La definición de clase puede imponer restricciones sobre los tipos reales que se pueden suministrar para T.

Se pueden aplicar los siguientes tipos de restricciones:

* tipo de valor
* tipo de referencia
* Constructor predeterminado
* herencia e implementación

**tipo de valor**

En este caso, solo se pueden proporcionar `struct`s (esto incluye tipos de datos 'primitivos' como `int`, `boolean`, etc.)

    public class Cup<T> where T : struct
    {
        // ...
    }

**tipo de referencia**

En este caso, solo se pueden proporcionar tipos de clase.

    public class Cup<T> where T : class
    {
        // ...
    }

**valor híbrido/tipo de referencia**

Ocasionalmente, se desea restringir los argumentos de tipo a aquellos disponibles en una base de datos, y estos generalmente se asignarán a tipos de valor y cadenas. Como se deben cumplir todas las restricciones de tipo, no es posible especificar `where T : struct or string` (esta no es una sintaxis válida). Una solución consiste en restringir los argumentos de tipo a [`IConvertible`][1] que tiene tipos integrados de "... Boolean, SByte, Byte, Int16, UInt16, Int32, UInt32, Int64, UInt64, Single, Double, Decimal, DateTime, Char y String". Es posible que otros objetos implementen IConvertible, aunque esto es raro en la práctica.

    public class Cup<T> where T : IConvertible
    {
        // ...
    }

**Constructor predeterminado**

Solo se permitirán los tipos que contengan un constructor predeterminado. Esto incluye tipos de valores y clases que contienen un constructor predeterminado (sin parámetros).


    public class Cup<T> where T : new
    {
        // ...
    }

**herencia e implementación**

Solo se pueden suministrar los tipos que heredan de una determinada clase base o implementan una determinada interfaz.


    public class Cup<T> where T : Beverage
    {
        // ...
    }


    public class Cup<T> where T : IBeer
    {
        // ...
    }


La restricción puede incluso hacer referencia a otro parámetro de tipo:

    public class Cup<T, U> where U : T
    {
        // ...
    }

Se pueden especificar varias restricciones para un argumento de tipo:

    public class Cup<T> where T : class, new()
    {
        // ...
    }

Los ejemplos anteriores muestran restricciones genéricas en una definición de clase, pero las restricciones se pueden usar en cualquier lugar donde se proporcione un argumento de tipo: clases, estructuras, interfaces, métodos, etc.
---

`where` también puede ser una cláusula LINQ. En este caso es análogo a `WHERE` en SQL:

    int[] nums = { 5, 2, 1, 3, 9, 8, 6, 7, 2, 0 };

    var query =
        from num in nums 
        where num < 5
        select num;

        foreach (var n in query)
        {
            Console.Write(n + " ");
        }
        // prints 2 1 3 2 0


[1]: https://msdn.microsoft.com/en-us/library/system.iconvertible(v=vs.110).aspx

## externo
La palabra clave `extern` se usa para declarar métodos que se implementan externamente. Esto se puede usar junto con el atributo DllImport para llamar al código no administrado mediante los servicios de interoperabilidad. que en este caso vendrá con el modificador `static`

Por ejemplo:

    using System.Runtime.InteropServices;
    public class MyClass
    {
        [DllImport("User32.dll")]
        private static extern int SetForegroundWindow(IntPtr point);
    
        public void ActivateProcessWindow(Process p)
        {
            SetForegroundWindow(p.MainWindowHandle);
        }
    }

Esto utiliza el método SetForegroundWindow importado de la biblioteca User32.dll

Esto también se puede usar para definir un alias de ensamblaje externo. lo que nos permite hacer referencia a diferentes versiones de los mismos componentes de un solo ensamblaje.

Para hacer referencia a dos ensamblajes con los mismos nombres de tipo totalmente calificados, se debe especificar un alias en un símbolo del sistema, de la siguiente manera:

    /r:GridV1=grid.dll
    /r:GridV2=grid20.dll

Esto crea los alias externos GridV1 y GridV2. Para usar estos alias desde dentro de un programa, haga referencia a ellos usando la palabra clave extern. Por ejemplo:

    extern alias GridV1;
    extern alias GridV2;


## cuando
`when` es una palabra clave añadida en **C# 6**, y se utiliza para el filtrado de excepciones.

Antes de la introducción de la palabra clave `when`, podría haber tenido una cláusula catch para cada tipo de excepción; con la adición de la palabra clave, ahora es posible un control más detallado.

Una expresión `when` se adjunta a una rama `catch`, y solo si la condición `when` es `true`, se ejecutará la cláusula `catch`. Es posible tener varias cláusulas `catch` con los mismos tipos de clase de excepción y diferentes condiciones `when`.



    private void CatchException(Action action)
    {
        try
        {
            action.Invoke();
        }
        
        // exception filter
        catch (Exception ex) when (ex.Message.Contains("when"))
        {
            Console.WriteLine("Caught an exception with when");
        }
    
        catch (Exception ex)
        {
            Console.WriteLine("Caught an exception without when");
        }
    }

    private void Method1() { throw new Exception("message for exception with when"); }
    private void Method2() { throw new Exception("message for general exception"); }
    
    
    CatchException(Method1);
    CatchException(Method2);

## si, si... más, si... más si
----------


La sentencia `if` se utiliza para controlar el flujo del programa. Una sentencia `if` identifica qué sentencia ejecutar en función del valor de una expresión `booleana`.

Para una sola instrucción, las `llaves`{} son opcionales pero recomendadas.

    int a = 4;
    if(a % 2 == 0) 
    {
         Console.WriteLine("a contains an even number");
    }
    // output: "a contains an even number"


----------


El `if` también puede tener una cláusula `else`, que se ejecutará en caso de que la condición se evalúe como falsa:

    int a = 5;
    if(a % 2 == 0) 
    {
         Console.WriteLine("a contains an even number");
    }
    else
    {
         Console.WriteLine("a contains an odd number");
    }
    // output: "a contains an odd number"


----------


La construcción `if`...`else if` le permite especificar múltiples condiciones:

    int a = 9;
    if(a % 2 == 0) 
    {
         Console.WriteLine("a contains an even number");
    }
    else if(a % 3 == 0) 
    {
         Console.WriteLine("a contains an odd number that is a multiple of 3"); 
    }
    else
    {
         Console.WriteLine("a contains an odd number");
    }
    // output: "a contains an odd number that is a multiple of 3"

*Es importante tener en cuenta* que si se cumple una condición en el ejemplo anterior, el control omite otras pruebas y salta al final de esa construcción if else en particular. Por lo tanto, el *orden* de las pruebas es importante si está utilizando if .. más si construye
----------

Las expresiones booleanas de C# usan [evaluación de cortocircuito][1]. Esto es importante en los casos en que la evaluación de las condiciones puede tener efectos secundarios:

    if (someBooleanMethodWithSideEffects() && someOtherBooleanMethodWithSideEffects()) {
      //...
    }
No hay garantía de que `someOtherBooleanMethodWithSideEffects` realmente se ejecute.

También es importante en los casos en que las condiciones anteriores garantizan que es "seguro" evaluar las posteriores. Por ejemplo:

    if (someCollection != null && someCollection.Count > 0) {
       // ..
    }
El orden es muy importante en este caso porque, si invertimos el orden:

    if (someCollection.Count > 0 && someCollection != null) {
arrojará una `NullReferenceException` si `someCollection` es `null`.

[1]: https://en.wikipedia.org/wiki/Short-circuit_evaluacion

## estructura
Un tipo `struct` es un tipo de valor que normalmente se usa para encapsular pequeños grupos de variables relacionadas, como las coordenadas de un rectángulo o las características de un artículo en un inventario.

> [Clases][1] son ​​tipos de referencia, las estructuras son tipos de valor.

    using static System.Console;
    
    namespace ConsoleApplication1
    {
        struct Point
        {
            public int X;
            public int Y;
    
            public override string ToString()
            {
                return $"X = {X}, Y = {Y}";
            }
    
            public void Display(string name)
            {
                WriteLine(name + ": " + ToString());
            }
        }
    
        class Program
        {
            static void Main()
            {
                var point1 = new Point {X = 10, Y = 20};
                // it's not a reference but value type
                var point2 = point1;
                point2.X = 777;
                point2.Y = 888;
                point1.Display(nameof(point1)); // point1: X = 10, Y = 20
                point2.Display(nameof(point2)); // point2: X = 777, Y = 888
    
                ReadKey();
            }
        }
    }

    
----------
Las estructuras también pueden contener constructores, constantes, campos, métodos, propiedades, indexadores, operadores, eventos y tipos anidados, aunque si se requieren varios de estos miembros, debería considerar convertir su tipo en una clase.


----------


**Algunas [sugerencias][2] de MS sobre cuándo usar struct y cuándo usar class:**

*CONSIDERAR*

definir una estructura en lugar de una clase si las instancias del tipo son pequeñas y generalmente de corta duración o están comúnmente incrustadas en otros objetos.

*EVITAR*

definir una estructura a menos que el tipo tenga todas las siguientes características:
 

- Representa lógicamente un único valor, similar a los tipos primitivos
(int, doble, etc.)
- Tiene un tamaño de instancia inferior a 16 bytes.
- Es inmutable.
- No tendrá que ser encajonado con frecuencia.


[1]: http://stackoverflow.com/a/3924092/266562
[2]: https://msdn.microsoft.com/en-us/library/ms229017.aspx

## cambiar
La sentencia `switch` es una sentencia de control que selecciona una sección de switch para ejecutar de una lista de candidatos. Una declaración de cambio incluye una o más secciones de cambio. Cada sección de cambio contiene una o más etiquetas de "caso" seguidas de una o más declaraciones. Si ninguna etiqueta de caso contiene un valor coincidente, el control se transfiere a la sección "predeterminada", si la hay. La caída de casos no se admite en C#, estrictamente hablando. Sin embargo, si 1 o más etiquetas `case` están vacías, la ejecución seguirá el código del siguiente bloque `case` que contiene código. Esto permite la agrupación de múltiples etiquetas `case` con la misma implementación. En el siguiente ejemplo, si `mes` es igual a 12, el código en `caso 2` se ejecutará ya que las etiquetas `caso` `12` `1` y `2` están agrupadas. Si un bloque `case` no está vacío, debe haber un `break` antes de la siguiente etiqueta `case`, de lo contrario, el compilador marcará un error.

    int month = DateTime.Now.Month; // this is expected to be 1-12 for Jan-Dec

    switch (month)
    {
        case 12: 
        case 1: 
        case 2:
            Console.WriteLine("Winter");
            break;
        case 3: 
        case 4: 
        case 5:
            Console.WriteLine("Spring");
            break;
        case 6: 
        case 7: 
        case 8:
            Console.WriteLine("Summer");
            break;
        case 9:     
        case 10: 
        case 11:
            Console.WriteLine("Autumn");
            break;
        default:
            Console.WriteLine("Incorrect month index");
            break;
    }

Un `caso` solo se puede etiquetar con un valor conocido en *tiempo de compilación* (por ejemplo, `1`, `"str"`, `Enum.A`), por lo que una `variable` no es una etiqueta válida de `caso` , pero un valor `const` o `Enum` lo es (así como cualquier valor literal).

## inseguro
La palabra clave `unsafe` se puede usar en declaraciones de tipo o método o para declarar un bloque en línea.

El propósito de esta palabra clave es habilitar el uso del *subconjunto no seguro* de C# para el bloque en cuestión. El subconjunto inseguro incluye funciones como punteros, asignación de pilas, matrices tipo C, etc.

El código inseguro no es verificable y por eso se desaconseja su uso. La compilación de código inseguro requiere pasar un interruptor al compilador de C#. Además, CLR requiere que el ensamblado en ejecución tenga plena confianza.

A pesar de estas limitaciones, el código no seguro tiene usos válidos para hacer que algunas operaciones sean más eficaces (por ejemplo, la indexación de matrices) o más sencillas (por ejemplo, la interoperabilidad con algunas bibliotecas no administradas).

Como un ejemplo muy simple

    // compile with /unsafe
    class UnsafeTest
    {
       unsafe static void SquarePtrParam(int* p)
       {
          *p *= *p; // the '*' dereferences the pointer.
          //Since we passed in "the address of i", this becomes "i *= i"
       }
    
       unsafe static void Main()
       {
          int i = 5;
          // Unsafe method: uses address-of operator (&):
          SquarePtrParam(&i); // "&i" means "the address of i". The behavior is similar to "ref i"
          Console.WriteLine(i); // Output: 25
       }
    }

Mientras trabajamos con punteros, podemos cambiar los valores de las ubicaciones de memoria directamente, en lugar de tener que abordarlos por su nombre. Tenga en cuenta que esto a menudo requiere el uso de la palabra clave [fixed][1] para evitar una posible corrupción de la memoria a medida que el recolector de basura mueve las cosas (de lo contrario, puede obtener [error CS0212][2]). Dado que no se puede escribir en una variable que ha sido "arreglada", a menudo también tenemos que tener un segundo puntero que comience apuntando a la misma ubicación que el primero.

    void Main()
    {
        int[] intArray = new int[] { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10};

        UnsafeSquareArray(intArray);
        foreach(int i in intArray)
            Console.WriteLine(i);
    }
    
    unsafe static void UnsafeSquareArray(int[] pArr)
    {
        int len = pArr.Length;

        //in C or C++, we could say
        // int* a = &(pArr[0])
        // however, C# requires you to "fix" the variable first 
        fixed(int* fixedPointer = &(pArr[0]))
        {
            //Declare a new int pointer because "fixedPointer" cannot be written to.
            // "p" points to the same address space, but we can modify it
            int* p = fixedPointer;

            for (int i = 0; i < len; i++)
            {
                *p *= *p; //square the value, just like we did in SquarePtrParam, above
                p++;      //move the pointer to the next memory space.
                          // NOTE that the pointer will move 4 bytes since "p" is an
                          // int pointer and an int takes 4 bytes

                //the above 2 lines could be written as one, like this:
                // "*p *= *p++;"
            }
        }
    }

Producción:

    1
    4
    9
    16
    25
    36
    49
    64
    81
    100


`unsafe` también permite el uso de [stackalloc][3] que asignará memoria en la pila como _alloca en la biblioteca de tiempo de ejecución de C. Podemos modificar el ejemplo anterior para usar `stackalloc` de la siguiente manera:


    unsafe void Main()
    {
        const int len=10;
        int* seedArray = stackalloc int[len];
        
        //We can no longer use the initializer "{ 1, 2, 3, 4, 5, 6, 7, 8, 9, 10}" as before.
        // We have at least 2 options to populate the array. The end result of either
        // option will be the same (doing both will also be the same here).

        //FIRST OPTION:
        int* p = seedArray; // we don't want to lose where the array starts, so we
                            // create a shadow copy of the pointer
        for(int i=1; i<=len; i++)
            *p++ = i;
        //end of first option

        //SECOND OPTION:
        for(int i=0; i<len; i++)
            seedArray[i] = i+1;
        //end of second option

        UnsafeSquareArray(seedArray, len);
        for(int i=0; i< len; i++)
            Console.WriteLine(seedArray[i]);
    }
    
    //Now that we are dealing directly in pointers, we don't need to mess around with
    // "fixed", which dramatically simplifies the code
    unsafe static void UnsafeSquareArray(int* p, int len)
    {
        for (int i = 0; i < len; i++)
            *p *= *p++;
    }

(La salida es la misma que la anterior)


[1]: https://www.wikiod.com/es/docs/c%23/26/keywords/59/fixed#t=20160802171014149858
[2]: https://msdn.microsoft.com/en-us/library/29ak9b70(v=vs.140).aspx
[3]: https://www.wikiod.com/es/docs/c%23/26/keywords/57/stackalloc#t=20160802171014149858

## verdadero Falso
Las palabras clave `verdadero` y `falso` tienen dos usos:

1. Como valores booleanos literales


    var myTrueBool = true;
    var myFalseBool = false;

2. Como operadores que se pueden sobrecargar


    public static bool operator true(MyClass x)
    {
        return x.value >= 0;
    }

    public static bool operator false(MyClass x)
    {
        return x.value < 0;
    }

Sobrecargar el operador false era útil antes de C# 2.0, antes de la introducción de los tipos `Nullable`.
Un tipo que sobrecarga el operador `verdadero`, también debe sobrecargar el operador `falso`.

## estaba
Una variable local implícitamente tipada que está fuertemente tipada como si el usuario hubiera declarado el tipo. A diferencia de otras declaraciones de variables, el compilador determina el tipo de variable que representa en función del valor que se le asigna.

    var i = 10; // implicitly typed, the compiler must determine what type of variable this is
    int i = 10; // explicitly typed, the type of variable is explicitly stated to the compiler

    // Note that these both represent the same type of variable (int) with the same value (10).

A diferencia de otros tipos de variables, las definiciones de variables con esta palabra clave deben inicializarse cuando se declaran. Esto se debe a que la palabra clave **var** representa una variable tipificada implícitamente.

    var i;
    i = 10;

    // This code will not run as it is not initialized upon declaration.

La palabra clave **var** también se puede usar para crear nuevos tipos de datos sobre la marcha. Estos nuevos tipos de datos se conocen como *tipos anónimos*. Son muy útiles, ya que permiten al usuario definir un conjunto de propiedades sin tener que declarar explícitamente ningún tipo de objeto primero.

*Tipo anónimo simple*

    var a = new { number = 1, text = "hi" };

*Consulta LINQ que devuelve un tipo anónimo*

    public class Dog
    {
        public string Name { get; set; }
        public int Age { get; set; }
    }

    public class DogWithBreed
    {
        public Dog Dog { get; set; }
        public string BreedName  { get; set; }
    }

    public void GetDogsWithBreedNames()
    {
        var db = new DogDataContext(ConnectString);
        var result = from d in db.Dogs
                 join b in db.Breeds on d.BreedId equals b.BreedId
                 select new 
                        {
                            DogName = d.Name,
                            BreedName = b.BreedName
                        };

        DoStuff(result);
    }

Puede usar la palabra clave var en la declaración foreach

    public bool hasItemInList(List<String> list, string stringToSearch)
    {
        foreach(var item in list)
        {
            if( ( (string)item ).equals(stringToSearch) )
                return true;
        }

        return false;
    }

## enumeración
La palabra clave `enum` le dice al compilador que esta clase hereda de la clase abstracta `Enum`, sin que el programador tenga que heredarla explícitamente. `Enum` es un descendiente de `ValueType`, que está diseñado para usarse con un conjunto distinto de constantes con nombre.

    public enum DaysOfWeek
    {
        Monday,
        Tuesday,
    }

Opcionalmente, puede especificar un valor específico para cada uno (o algunos de ellos):

    public enum NotableYear
    {
       EndOfWwI = 1918;
       EnfOfWwII = 1945,
    }

En este ejemplo, omití un valor para 0, esto suele ser una mala práctica. Un `enum` siempre tendrá un valor predeterminado producido por la conversión explícita `(YourEnumType) 0`, donde `YourEnumType` es su tipo de `enumeración` declarado. Sin un valor de 0 definido, un `enum` no tendrá un valor definido al inicio.

El tipo subyacente predeterminado de `enum` es `int`, puede cambiar el tipo subyacente a cualquier tipo integral, incluidos `byte`, `sbyte`, `short`, `ushort`, `int`, `uint`, `long ` y `ulong`. A continuación se muestra una enumeración con el tipo subyacente `byte`:

    enum Days : byte
    {
        Sunday = 0,
        Monday,
        Tuesday,
        Wednesday,
        Thursday,
        Friday,
        Saturday
    };

También tenga en cuenta que puede convertir a/desde el tipo subyacente simplemente con un molde:

    int value = (int)NotableYear.EndOfWwI;

Por estas razones, es mejor que siempre verifique si un `enum` es válido cuando exponga las funciones de la biblioteca:

    void PrintNotes(NotableYear year)
    {
        if (!Enum.IsDefined(typeof(NotableYear), year))
            throw InvalidEnumArgumentException("year", (int)year, typeof(NotableYear));
    
        // ...
    }



## en
La palabra clave `in` tiene tres usos:

a) Como parte de la sintaxis en una declaración `foreach` o como parte de la sintaxis en una consulta LINQ

    foreach (var member in sequence)
    {
        // ...
    }

b) En el contexto de interfaces genéricas y tipos de delegados genéricos significa _contravarianza_ para el parámetro de tipo en cuestión:

    public interface IComparer<in T>
    {
        // ...
    }

c) En el contexto de la consulta LINQ se refiere a la colección que se está consultando

    var query = from x in source select new { x.Name, x.ID, };


## tamaño de
Se utiliza para obtener el tamaño en bytes de un tipo no administrado

    int byteSize = sizeof(byte) // 1
    int sbyteSize = sizeof(sbyte) // 1
    int shortSize = sizeof(short) // 2
    int ushortSize = sizeof(ushort) // 2
    int intSize = sizeof(int) // 4
    int uintSize = sizeof(uint) // 4
    int longSize = sizeof(long) // 8
    int ulongSize = sizeof(ulong) // 8
    int charSize = sizeof(char) // 2(Unicode)
    int floatSize = sizeof(float) // 4
    int doubleSize = sizeof(double) // 8
    int decimalSize = sizeof(decimal) // 16
    int boolSize = sizeof(bool) // 1

## largo
La palabra clave **larga** se utiliza para representar enteros de 64 bits con signo. Es un alias para el tipo de datos `System.Int64` presente en `mscorlib.dll`, al que todos los proyectos de C# hacen referencia implícitamente cuando los crea.

*Cualquier variable **larga** se puede declarar tanto explícita como implícitamente:*

    long long1 = 9223372036854775806;  // explicit declaration, long keyword used
    var long2 = -9223372036854775806L; // implicit declaration, 'L' suffix used

Una variable **larga** puede contener cualquier valor desde –9,223,372,036,854,775,808 a 9,223,372,036,854,775,807, y puede ser útil en situaciones en las que una variable debe contener un valor que excede los límites de otras variables (como [**int**][ 1] variable) puede contener.


[1]: https://www.wikiod.com/es/docs/c%23/26/keywords#t=201608201800043158849

## bool
Palabra clave para almacenar los valores booleanos `verdadero` y `falso`. bool es un alias de System.Boolean.

El valor predeterminado de un bool es falso.

    bool b; // default value is false
    b = true; // true
    b = ((5 + 2) == 6); // false

Para que un bool permita valores nulos, debe inicializarse como un bool?.

¿El valor predeterminado de un bool? es nulo.

    bool? a // default value is null

## sin marcar
La palabra clave `unchecked` evita que el compilador compruebe si hay desbordamientos o subdesbordamientos.

Por ejemplo:

    const int ConstantMax = int.MaxValue;
    unchecked
    {
        int1 = 2147483647 + 10;
    }
    int1 = unchecked(ConstantMax + 10);

Sin la palabra clave `unchecked`, ninguna de las dos operaciones de suma se compilará.

## ¿Cuándo es útil?

Esto es útil ya que puede ayudar a acelerar los cálculos que definitivamente no se desbordarán, ya que verificar el desbordamiento lleva tiempo, o cuando se desea un comportamiento de desbordamiento/subdesbordamiento (por ejemplo, al generar un código hash).

## hacer
El operador do itera sobre un bloque de código hasta que una consulta condicional es igual a falso. El bucle do-while también se puede interrumpir con [`goto`](https://www.wikiod.com/es/docs/c%23/26/keywords/193/goto), [`return`](http:// stackoverflow.com/documentation/c%23/26/keywords/4600/return), [`break`](https://www.wikiod.com/es/docs/c%23/26/keywords/2858/break) o `throw ` declaración.

La sintaxis de la palabra clave `do` es:

> hacer
> { *bloque de código;* }
> while( *condición* );


Ejemplo:

    int i = 0;

    do
    {
        Console.WriteLine("Do is on loop number {0}.", i);
    } while (i++ < 5);


Producción:

>"Do está en el bucle número 1". \
"Do está en el bucle número 2".\
"Do está en el bucle número 3".\
"Do está en el ciclo número 4".\
"Do está en el bucle número 5".


A diferencia del bucle [`while`](https://www.wikiod.com/es/docs/c%23/26/keywords/4396/while), el bucle do-while es **Controlado por salida**. Esto significa que el bucle do-while ejecutaría sus declaraciones al menos una vez, incluso si la condición falla la primera vez.


    bool a = false;

    do
    {
        Console.WriteLine("This will be printed once, even if a is false.");
    } while (a == true);

## interfaz
Una [`interfaz`][1] contiene las [firmas][2] de métodos, propiedades y eventos. Las clases derivadas definen a los miembros ya que la interfaz contiene solo la declaración de los miembros.

Una interfaz se declara usando la palabra clave `interfaz`.

    interface IProduct
    {
        decimal Price { get; }
    }
    
    class Product : IProduct
    {
        const decimal vat = 0.2M;
        
        public Product(decimal price)
        {
            _price = price;
        }
        
        private decimal _price;
        public decimal Price { get { return _price * (1 + vat); } }
    }


[1]: http://stackoverflow.com/questions/tagged/interface+c%23
[2]: http://stackoverflow.com/questions/tagged/signature+c%23

## implícito
La palabra clave `implícita` se utiliza para sobrecargar un operador de conversión. Por ejemplo, puede declarar una clase 'Fracción' que debería convertirse automáticamente en 'doble' cuando sea necesario, y que puede convertirse automáticamente de 'int':

    class Fraction(int numerator, int denominator)
    {
        public int Numerator { get; } = numerator;
        public int Denominator { get; } = denominator;
        // ...
        public static implicit operator double(Fraction f)
        {
            return f.Numerator / (double) f.Denominator;
        }
        public static implicit operator Fraction(int i)
        {
            return new Fraction(i, 1);
        }
    }

## corto
Un tipo numérico utilizado para almacenar enteros positivos de 16 bits. `ushort` es un alias de `System.UInt16` y ocupa 2 bytes de memoria.

El rango válido es de `0` a `65535`.

```
ushort a = 50; // 50
ushort b = 65536; // Error, cannot be converted
ushort c = unchecked((ushort)65536); // Overflows (wraps around to 0)
```

## delegado
Los delegados son tipos que representan una referencia a un método. Se utilizan para pasar métodos como argumentos a otros métodos.

Los delegados pueden contener métodos estáticos, métodos de instancia, métodos anónimos o expresiones lambda.
   
```
class DelegateExample
{
    public void Run()
    {
        //using class method
        InvokeDelegate( WriteToConsole ); 
        
        //using anonymous method
        DelegateInvoker di = delegate ( string input ) 
        { 
            Console.WriteLine( string.Format( "di: {0} ", input ) );
            return true; 
        };
        InvokeDelegate( di ); 
        
        //using lambda expression
        InvokeDelegate( input => false ); 
    }

    public delegate bool DelegateInvoker( string input );

    public void InvokeDelegate(DelegateInvoker func)
    {
        var ret = func( "hello world" );
        Console.WriteLine( string.Format( " > delegate returned {0}", ret ) );
    }

    public bool WriteToConsole( string input )
    {
        Console.WriteLine( string.Format( "WriteToConsole: '{0}'", input ) );
        return true;
    }
}
```

Al asignar un método a un delegado, es importante tener en cuenta que el método debe tener el mismo tipo de valor devuelto y los mismos parámetros. Esto difiere de la sobrecarga de métodos 'normales', donde solo los parámetros definen la firma del método.

Los eventos se construyen sobre los delegados.

## parcial
La palabra clave `parcial` se puede utilizar durante la definición de tipo de clase, estructura o interfaz para permitir que la definición de tipo se divida en varios archivos. Esto es útil para incorporar nuevas funciones en el código generado automáticamente.

**Archivo1.cs**

    namespace A
    {
        public partial class Test
        {
            public string Var1 {get;set;}
        }
    }

**Archivo2.cs**

    namespace A
    {
        public partial class Test
        {
            public string Var2 {get;set;}
        }
    }

**Nota:** Una clase se puede dividir en cualquier número de archivos. Sin embargo, todas las declaraciones deben estar bajo el mismo espacio de nombres y el mismo ensamblado.

Los métodos también se pueden declarar parciales usando la palabra clave `parcial`. En este caso, un archivo contendrá solo la definición del método y otro archivo contendrá la implementación.

> Un método parcial tiene su firma definida en una parte de un tipo parcial y su implementación definida en otra parte del tipo. Los métodos parciales permiten a los diseñadores de clases proporcionar enlaces de métodos, similares a los controladores de eventos, que los desarrolladores pueden decidir implementar o no. Si el desarrollador no proporciona una implementación, el compilador elimina la firma en el momento de la compilación. Las siguientes condiciones se aplican a los métodos parciales:
> * Las firmas en ambas partes del tipo parcial deben coincidir.
> * El método debe devolver void.
> * No se permiten modificadores de acceso. Los métodos parciales son implícitamente privados.
>
> --MSDN

**Archivo1.cs**

    namespace A
    {
        public partial class Test
        {
            public string Var1 {get;set;}
            public partial Method1(string str);
        }
    }

**Archivo2.cs**

    namespace A
    {
        public partial class Test
        {
            public string Var2 {get;set;}
            public partial Method1(string str)
            {
                Console.WriteLine(str);
            }
        }
    }


**Nota:** El tipo que contiene el método parcial también debe declararse parcial.

 




## sbyte
Un tipo numérico utilizado para almacenar enteros *con signo* de 8 bits. `sbyte` es un alias de `System.SByte` y ocupa 1 byte de memoria. Para el equivalente sin signo, use `byte`.

El rango válido es de `-127` a `127` (el sobrante se usa para almacenar el signo).

```
sbyte a = 127; // 127
sbyte b = -127; // -127
sbyte c = 200; // Error, cannot be converted
sbyte d = unchecked((sbyte)129); // -127 (overflows)
```

## evento
Un `evento` permite al desarrollador implementar un patrón de notificación.

**Ejemplo sencillo**

    public class Server
    {
        // defines the event
        public event EventHandler DataChangeEvent;

        void RaiseEvent()
        {
            var ev = DataChangeEvent;
            if(ev != null)
            {
                ev(this, EventArgs.Empty);
            }
        }
    }

    public class Client
    {
        public void Client(Server server)
        {
            // client subscribes to the server's DataChangeEvent
            server.DataChangeEvent += server_DataChanged;
        }

        private void server_DataChanged(object sender, EventArgs args)
        {
            // notified when the server raises the DataChangeEvent
        }
    }

[Referencia de MSDN][1]


[1]: https://msdn.microsoft.com/en-CA/library/awbftdfh.aspx

