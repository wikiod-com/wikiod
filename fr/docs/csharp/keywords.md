---
title: "Mots clés"
slug: "mots-cles"
draft: false
images: []
weight: 8286
type: docs
toc: true
---

[Keywords](https://msdn.microsoft.com/en-us/library/x53a06bb(v=vs.71).aspx) sont des identificateurs prédéfinis et réservés ayant une signification particulière pour le compilateur. Ils ne peuvent pas être utilisés comme identifiants dans votre programme sans le préfixe `@`. Par exemple, `@if` est un identifiant légal mais pas le mot clé `if`.

C# a une collection prédéfinie de "mots clés" (ou mots réservés) qui ont chacun une fonction spéciale. Ces mots ne peuvent pas être utilisés comme identifiants (noms de variables, méthodes, classes, etc.) à moins d'être préfixés par `@`.

* [`abstract`](https://www.wikiod.com/fr/docs/c%23/26/keywords/2872/abstract)
* [`as`](https://www.wikiod.com/fr/docs/c%23/26/keywords/138/as)
* [`base`](https://www.wikiod.com/fr/docs/c%23/26/keywords/1840/base)
* [`bool`](https://www.wikiod.com/fr/docs/c%23/26/keywords/8712/bool)
* [`break`](https://www.wikiod.com/fr/docs/c%23/26/keywords/2858/break)
* 'octet'
* "cas"
* [`catch`](https://www.wikiod.com/fr/docs/c%23/26/keywords/148/try-catch-finally-throw)
* [`char`](https://www.wikiod.com/fr/docs/c%23/26/keywords/6009/char)
* [`vérifié`](https://www.wikiod.com/fr/docs/c%23/26/keywords/192/checked-unchecked)
* 'classe'
* [`const`](https://www.wikiod.com/fr/docs/c%23/26/keywords/141/const)
* [`continue`](https://www.wikiod.com/fr/docs/c%23/26/keywords/154/continue)
* [`décimal`](https://www.wikiod.com/fr/docs/c%23/26/keywords/2873/float-double-decimal)
* [`default`](https://www.wikiod.com/fr/docs/c%23/26/keywords/109/default)
* [`delegate`](https://www.wikiod.com/fr/docs/c%23/26/keywords/18720/delegate)
* [`do`](https://www.wikiod.com/fr/docs/c%23/26/keywords/12229/do)
* [`double`](https://www.wikiod.com/fr/docs/c%23/26/keywords/2873/float-double-decimal)
* [`else`](https://www.wikiod.com/fr/docs/c%23/26/keywords/11359/if-if-else-if-else-if)
* [`enum`](https://www.wikiod.com/fr/docs/c%23/26/keywords/245/enum)
* [`événement`](https://www.wikiod.com/fr/docs/c%23/26/keywords/18722/event)
* "explicite"
* [`extern`](https://www.wikiod.com/fr/docs/c%23/26/keywords/8191/extern)
* [`false`](https://www.wikiod.com/fr/docs/c%23/26/keywords/17113/true-false)
* [`finally`](https://www.wikiod.com/fr/docs/c%23/26/keywords/148/try-catch-finally-throw)
* [`fixe`](https://www.wikiod.com/fr/docs/c%23/26/keywords/59/fixe)
* [`float`](https://www.wikiod.com/fr/docs/c%23/26/keywords/2873/float-double-decimal)
* [`pour`](https://www.wikiod.com/fr/docs/c%23/26/keywords/3722/for)
* [`foreach`](https://www.wikiod.com/fr/docs/c%23/26/keywords/1928/foreach)
* [`aller à`](https://www.wikiod.com/fr/docs/c%23/26/keywords/193/aller)
* [`if`](https://www.wikiod.com/fr/docs/c%23/26/keywords/11359/if-if-else-if-else-if)
* [`implicite`](https://www.wikiod.com/fr/docs/c%23/26/keywords/16557/implicite)
* [`in`](https://www.wikiod.com/fr/docs/c%23/26/keywords/4992/in)
* [`int`](https://www.wikiod.com/fr/docs/c%23/26/keywords/5328/int)
* [`interface`](https://www.wikiod.com/fr/docs/c%23/26/keywords/14354/interface)
* [`interne`][1]
* [`is`](https://www.wikiod.com/fr/docs/c%23/26/keywords/139/is)
* [`lock`](https://www.wikiod.com/fr/docs/c%23/26/keywords/6452/lock#t=201607261640175640513)
* [`long`](https://www.wikiod.com/fr/docs/c%23/26/keywords/5329/long)
* [`espace de noms`](https://www.wikiod.com/fr/docs/c%23/26/keywords/142/espace de noms)
* [`nouveau`](https://www.wikiod.com/fr/docs/c%23/26/keywords/5805/virtual-override-new)
* [`null`](https://www.wikiod.com/fr/docs/c%23/26/keywords/6750/null)
* 'objet'
* [`operator`](https://www.wikiod.com/fr/docs/c%23/26/keywords/12604/operator)
* [`out`](https://www.wikiod.com/fr/docs/c%23/26/keywords/184/ref-out)
* [`override`](https://www.wikiod.com/fr/docs/c%23/26/keywords/5805/virtual-override-new)
* [`params`](https://www.wikiod.com/fr/docs/c%23/26/keywords/2513/params)
* 'privé'
* "protégé"
* "publique"
* [`readonly`](https://www.wikiod.com/fr/docs/c%23/26/keywords/110/readonly)
* [`ref`](https://www.wikiod.com/fr/docs/c%23/26/keywords/184/ref-out)
* [`return`](https://www.wikiod.com/fr/docs/c%23/26/keywords/4600/return)
* [`sbyte`](https://www.wikiod.com/fr/docs/c%23/26/keywords/18290/sbyte)
* [`scellé`](https://www.wikiod.com/fr/docs/c%23/26/keywords/5245/sealed)
* "court"
* [`sizeof`](https://www.wikiod.com/fr/docs/c%23/26/keywords/5246/sizeof)
* [`stackalloc`](https://www.wikiod.com/fr/docs/c%23/26/keywords/57/stackalloc)
* [`statique`](https://www.wikiod.com/fr/docs/c%23/26/keywords/5248/statique)
* [`string`](https://www.wikiod.com/fr/docs/c%23/26/keywords/17143/string)
* [`struct`][2]
* [`switch`](https://www.wikiod.com/fr/docs/c%23/26/keywords/14353/switch)
* [`this`](https://www.wikiod.com/fr/docs/c%23/26/keywords/2914/this)
* [`throw`](https://www.wikiod.com/fr/docs/c%23/26/keywords/148/try-catch-finally-throw)
* [`true`](https://www.wikiod.com/fr/docs/c%23/26/keywords/17113/true-false)
* [`try`](https://www.wikiod.com/fr/docs/c%23/26/keywords/148/try-catch-finally-throw)
* [`typeof`](https://www.wikiod.com/fr/docs/c%23/26/keywords/140/typeof)
* [`uint`](https://www.wikiod.com/fr/docs/c%23/26/keywords/2874/uint)
* [`ulong`](https://www.wikiod.com/fr/docs/c%23/26/keywords/5330/ulong)
* [`unchecked`](https://www.wikiod.com/fr/docs/c%23/26/keywords/192/checked-unchecked)
* [`unsafe`](https://www.wikiod.com/fr/docs/c%23/26/keywords/15630/unsafe)
* [`ushort`](https://www.wikiod.com/fr/docs/c%23/26/keywords/18289/ushort)
* [`using` (directive)](https://www.wikiod.com/fr/docs/c%23/52/using-directive#t=201605012059492751326)
* [`using` (instruction)](https://www.wikiod.com/fr/docs/c%23/38/using-statement#t=20160501205709291959)
* [`virtuel`](https://www.wikiod.com/fr/docs/c%23/26/keywords/5805/virtual-override-new)
* [`void`](https://www.wikiod.com/fr/docs/c%23/26/keywords/2980/void)
* [`volatile`](https://www.wikiod.com/fr/docs/c%23/26/keywords/58/volatile)
* [`quand`](https://www.wikiod.com/fr/docs/c%23/26/keywords/9258/when)
* [`while`](https://www.wikiod.com/fr/docs/c%23/26/keywords/4396/while)

En dehors de ceux-ci, C # utilise également certains mots-clés pour fournir une signification spécifique au code. Ils sont appelés mots-clés contextuels. Les mots-clés contextuels peuvent être utilisés comme identifiants et n'ont pas besoin d'être préfixés par `@` lorsqu'ils sont utilisés comme identifiants.

* 'ajouter'
* "alias"
* "ascendant"
* [`async`](https://www.wikiod.com/fr/docs/c%23/26/keywords/5993/async-await)
* [`wait`](https://www.wikiod.com/fr/docs/c%23/26/keywords/5993/async-wait)
* "descendant"
* 'dynamique'
* "de"
* "obtenir"
* "mondial"
* 'groupe'
* "dans"
* "rejoindre"
* 'laisser'
* [`nameof`](https://www.wikiod.com/fr/docs/c%23/24/c-sharp-6-0-features/43/operator-nameof)
* `commander par`
* [`partial`](https://www.wikiod.com/fr/docs/c%23/26/keywords/19199/partial#t=201608110434471554387)
* "supprimer"
* 'sélectionner'
* "définir"
* 'valeur'
* [`var`](https://www.wikiod.com/fr/docs/c%23/26/keywords/4503/var)
* [`where`](https://www.wikiod.com/fr/docs/c%23/26/keywords/8137/where-type-constraints)
* [`rendement`](https://www.wikiod.com/fr/docs/c%23/61/yield-keyword-in-c#t=201605012045372009603)


[1] : https://www.wikiod.com/fr/docs/c%23/26/keywords/8102/internal#t=201607221603473329189
[2] : https://www.wikiod.com/fr/docs/c%23/26/keywords/13023/struct#t=201607251950535084892

## comme
Le mot clé `as` est un opérateur similaire à un *cast*. Si un transtypage n'est pas possible, l'utilisation de `as` produit `null` plutôt que d'entraîner une `InvalidCastException`.

`expression comme type` est équivalent à `expression est type ? (type)expression : (type)null` avec la mise en garde que `as` n'est valide que sur les conversions de référence, les conversions nullables et les conversions boxing. Les conversions définies par l'utilisateur ne sont *pas* prises en charge ; un casting régulier doit être utilisé à la place.

Pour l'expansion ci-dessus, le compilateur génère du code tel que `expression` ne sera évalué qu'une seule fois et n'utilisera qu'une seule vérification de type dynamique (contrairement aux deux dans l'exemple ci-dessus).

`as` peut être utile lorsqu'on s'attend à ce qu'un argument facilite plusieurs types. Plus précisément, il accorde à l'utilisateur plusieurs options - plutôt que de vérifier chaque possibilité avec "est" avant de diffuser, ou simplement de diffuser et d'attraper des exceptions. Il est préférable d'utiliser 'as' lors du lancement/de la vérification d'un objet, ce qui entraînera une seule pénalité de déballage. Utiliser `is` pour vérifier, puis lancer entraînera deux pénalités de déballage.

Si un argument est censé être une instance d'un type spécifique, un cast normal est préféré car son objectif est plus clair pour le lecteur.

Comme un appel à `as` peut produire `null`, vérifiez toujours le résultat pour éviter une `NullReferenceException`.

**Exemple d'utilisation**

    object something = "Hello";
    Console.WriteLine(something as string);        //Hello
    Console.Writeline(something as Nullable<int>); //null
    Console.WriteLine(something as int?);          //null
    
    //This does NOT compile:
    //destination type must be a reference type (or a nullable value type)
    Console.WriteLine(something as int);

[Démo en direct sur .NET Fiddle] (https://dotnetfiddle.net/b26q6N)

Exemple équivalent sans utiliser `as` :

    Console.WriteLine(something is string ? (string)something : (string)null);

Ceci est utile lors du remplacement de la fonction `Equals` dans les classes personnalisées.

    class MyCustomClass
    {

        public override bool Equals(object obj)
        {
            MyCustomClass customObject = obj as MyCustomClass;

            // if it is null it may be really null
            // or it may be of a different type
            if (Object.ReferenceEquals(null, customObject))
            {
                // If it is null then it is not equal to this instance.
                return false;
            }

            // Other equality controls specific to class
        }

    }

## aller à
`goto` peut être utilisé pour sauter à une ligne spécifique à l'intérieur du code, spécifiée par une étiquette.

# `goto` comme un :

## Étiquette:

    void InfiniteHello()
    {
        sayHello:
        Console.WriteLine("Hello!");
        goto sayHello;
    }

[Démo en direct sur .NET Fiddle] (https://dotnetfiddle.net/Tpm3LV)

## Déclaration de cas :

    enum Permissions { Read, Write };

    switch (GetRequestedPermission())
    {
        case Permissions.Read:
            GrantReadAccess();
            break;

        case Permissions.Write:
            GrantWriteAccess();
            goto case Permissions.Read; //People with write access also get read
    }

[Démo en direct sur .NET Fiddle](https://dotnetfiddle.net/2IV2wC)

Ceci est particulièrement utile pour exécuter plusieurs comportements dans une instruction switch, car C # ne prend pas en charge [fall-through case blocks] (http://stackoverflow.com/a/174223/365102).

## Nouvelle tentative d'exception

    var exCount = 0;
    retry:
    try
    {
        //Do work
    }
    catch (IOException)
    {
        exCount++;
        if (exCount < 3)
        {
            Thread.Sleep(100);
            goto retry;
        }
        throw;
    }

[Démo en direct sur .NET Fiddle] (https://dotnetfiddle.net/kc6oiT)

Comme dans de nombreuses langues, l'utilisation du mot-clé goto est déconseillée, sauf dans les cas ci-dessous.

[Utilisations valides de `goto`][wiki] qui s'appliquent à C# :

* Cas de basculement dans l'instruction switch.
* Pause à plusieurs niveaux. LINQ peut souvent être utilisé à la place, mais ses performances sont généralement moins bonnes.
* Désallocation des ressources lorsque vous travaillez avec des objets de bas niveau déballés. En C#, les objets de bas niveau doivent généralement être encapsulés dans des classes distinctes.
* Machines à états finis, par exemple, analyseurs ; utilisé en interne par les machines d'état async/wait générées par le compilateur.

[donc] : http://stackoverflow.com/questions/tagged/goto+c%23
[wiki] : https://en.wikipedia.org/wiki/Goto#Common_usage_patterns_of_Goto

## volatile
L'ajout du mot clé `volatile` à un champ indique au compilateur que la valeur du champ peut être modifiée par plusieurs threads distincts. L'objectif principal du mot clé `volatile` est d'empêcher les optimisations du compilateur qui supposent uniquement un accès à un seul thread. L'utilisation de `volatile` garantit que la valeur du champ est la valeur la plus récente disponible et que la valeur n'est pas soumise à la mise en cache des valeurs non volatiles.

Il est recommandé de marquer _chaque variable_ pouvant être utilisée par plusieurs threads comme "volatile" pour éviter tout comportement inattendu dû à des optimisations en arrière-plan. Considérez le bloc de code suivant :

    public class Example
    {
        public int x;

        public void DoStuff()
        {
            x = 5;

            // the compiler will optimize this to y = 15
            var y = x + 10;

            /* the value of x will always be the current value, but y will always be "15" */
            Debug.WriteLine("x = " + x + ", y = " + y);
        }    
    }

Dans le bloc de code ci-dessus, le compilateur lit les instructions `x = 5` et `y = x + 10` et détermine que la valeur de `y` finira toujours par 15. Ainsi, il optimisera la dernière instruction comme `y = 15`. Cependant, la variable `x` est en fait un champ `public` et la valeur de `x` peut être modifiée lors de l'exécution via un thread différent agissant sur ce champ séparément. Considérons maintenant ce bloc de code modifié. Notez que le champ `x` est maintenant déclaré comme `volatile`.

    public class Example
    {
        public volatile int x;

        public void DoStuff()
        {
            x = 5;

            // the compiler no longer optimizes this statement
            var y = x + 10;

            /* the value of x and y will always be the correct values */
            Debug.WriteLine("x = " + x + ", y = " + y);
        }    
    }

Maintenant, le compilateur recherche les utilisations *read* du champ `x` et s'assure que la valeur actuelle du champ est toujours récupérée. Cela garantit que même si plusieurs threads lisent et écrivent dans ce champ, la valeur actuelle de `x` est toujours récupérée.

`volatile` ne peut être utilisé que sur des champs à l'intérieur de `class`es ou `struct`s. Ce qui suit [n'est *pas* valide][2] :

<pre>public void MaMéthode()
{
    <strike>volatile</strike> int x;
}</pré>

"volatile" ne peut être appliqué qu'aux champs des types suivants :
- types de référence ou paramètres de type générique connus pour être des types de référence
- types primitifs tels que `sbyte`, `byte`, `short`, `ushort`, `int`, `uint`, `char`, `float` et `bool`
- types d'énumération basés sur `byte`, `sbyte`, `short`, `ushort`, `int` ou `uint`
- `IntPtr` et `UIntPtr`

----------
**Remarques:**

- Le modificateur [`volatile`][1] est généralement utilisé pour un champ auquel plusieurs threads accèdent sans utiliser l'instruction de verrouillage pour sérialiser l'accès.
- Le mot-clé `volatile` peut être appliqué aux champs de types de référence
- Le mot clé `volatile` ne rendra pas atomique le fonctionnement sur des primitives 64 bits sur une plate-forme 32 bits. Les opérations verrouillées telles que [`Interlocked.Read`][3] et [`Interlocked.Exchange`][4] doivent toujours être utilisées pour un accès multithread sécurisé sur ces plates-formes.


[1] : http://stackoverflow.com/questions/72275/when-should-the-volatile-keyword-be-used-in-c
[2] : https://msdn.microsoft.com/en-us/library/x13ttww7.aspx
[3] : https://msdn.microsoft.com/en-us/library/system.threading.interlocked.read(v=vs.110).aspx
[4] : https://msdn.microsoft.com/en-us/library/dk0121zy(v=vs.110).aspx

## coché, décoché
Les mots-clés `checked` et `unchecked` définissent comment les opérations gèrent le débordement mathématique. "Débordement" dans le contexte des mots-clés `checked` et `unchecked` se produit lorsqu'une opération arithmétique sur un nombre entier aboutit à une valeur dont l'amplitude est supérieure à ce que le type de données cible peut représenter.

Lorsqu'un débordement se produit dans un bloc `checked` (ou lorsque le compilateur est configuré pour utiliser globalement l'arithmétique vérifiée), une exception est levée pour avertir d'un comportement indésirable. Pendant ce temps, dans un bloc `unchecked`, le débordement est silencieux : aucune exception n'est levée et la valeur s'enroulera simplement jusqu'à la limite opposée. Cela peut conduire à des bogues subtils et difficiles à trouver.

Étant donné que la plupart des opérations arithmétiques sont effectuées sur des valeurs qui ne sont pas suffisamment grandes ou petites pour déborder, la plupart du temps, il n'est pas nécessaire de définir explicitement un bloc comme "vérifié". Des précautions doivent être prises lors de l'arithmétique sur une entrée illimitée qui peut provoquer un débordement, par exemple lors de l'arithmétique dans des fonctions récursives ou lors de la saisie d'une entrée utilisateur.

_Ni "coché" ni "non coché" n'affectent les opérations arithmétiques en virgule flottante._

Lorsqu'un bloc ou une expression est déclaré comme "unchecked", toutes les opérations arithmétiques à l'intérieur sont autorisées à déborder sans provoquer d'erreur. Un exemple où ce comportement est *souhaité* serait le calcul d'une somme de contrôle, où la valeur est autorisée à "boucler" pendant le calcul :

    byte Checksum(byte[] data) {
        byte result = 0;
        for (int i = 0; i < data.Length; i++) {
            result = unchecked(result + data[i]); // unchecked expression
        }
        return result;
    }

L'une des utilisations les plus courantes de `unchecked` consiste à implémenter un remplacement personnalisé pour `object.GetHashCode()`, un type de somme de contrôle. Vous pouvez voir l'utilisation du mot clé dans les réponses à cette question : http://stackoverflow.com/questions/263400/what-is-the-best-algorithm-for-an-overridden-system-object-gethashcode.

Lorsqu'un bloc ou une expression est déclaré comme `checked`, toute opération arithmétique qui provoque un débordement entraîne la levée d'une `OverflowException`.

    int SafeSum(int x, int y) {
        checked { // checked block
            return x + y; 
        }
    }

Coché et non coché peuvent être sous forme de bloc et d'expression.

Les blocs cochés et non cochés n'affectent pas les méthodes appelées, seulement les opérateurs appelés directement dans la méthode courante. Par exemple, `Enum.ToObject()`, `Convert.ToInt32()` et les opérateurs définis par l'utilisateur ne sont pas affectés par les contextes cochés/non cochés personnalisés.

***Remarque** : Le comportement par défaut de débordement par défaut (coché ou non coché) peut être modifié dans les **Propriétés du projet** ou via le commutateur de ligne de commande **/checked[+|-]**. Il est courant d'utiliser par défaut les opérations cochées pour les versions de débogage et décochées pour les versions de version. Les mots clés `checked` et `unchecked` seraient alors utilisés uniquement lorsqu'une approche _default_ ne s'applique pas et que vous avez besoin d'un comportement explicite pour garantir l'exactitude.*

## virtuel, remplacement, nouveau
virtuel et remplacement
====================

Le mot-clé `virtual` permet à une méthode, une propriété, un indexeur ou un événement d'être remplacé par des classes dérivées et de présenter un comportement polymorphe. (Les membres ne sont pas virtuels par défaut en C#)

    public class BaseClass
    {
        public virtual void Foo()
        {
            Console.WriteLine("Foo from BaseClass");
        }
    }

Afin de remplacer un membre, le mot-clé `override` est utilisé dans les classes dérivées. (Notez que la signature des membres doit être identique)

    public class DerivedClass: BaseClass
    {
        public override void Foo()
        {
            Console.WriteLine("Foo from DerivedClass");
        }
    }

Le comportement polymorphe des membres virtuels signifie que lorsqu'il est appelé, le membre réel en cours d'exécution est déterminé au moment de l'exécution plutôt qu'au moment de la compilation. Le membre prioritaire dans la classe la plus dérivée dont l'objet particulier est une instance sera celui exécuté.

En bref, l'objet peut être déclaré de type `BaseClass` au moment de la compilation, mais si à l'exécution, il s'agit d'une instance de `DerivedClass`, le membre remplacé sera exécuté :

    BaseClass obj1 = new BaseClass();
    obj1.Foo(); //Outputs "Foo from BaseClass"

    obj1 = new DerivedClass();
    obj1.Foo(); //Outputs "Foo from DerivedClass"    

La redéfinition d'une méthode est facultative :

    public class SecondDerivedClass: DerivedClass {}
    
    var obj1 = new SecondDerivedClass();
    obj1.Foo(); //Outputs "Foo from DerivedClass"    

Nouveau
====================    
Étant donné que seuls les membres définis comme "virtuels" sont remplaçables et polymorphes, une classe dérivée redéfinissant un membre non virtuel peut conduire à des résultats inattendus.

    public class BaseClass
    {
        public void Foo()
        {
            Console.WriteLine("Foo from BaseClass");
        }
    }

    public class DerivedClass: BaseClass
    {
        public void Foo()
        {
            Console.WriteLine("Foo from DerivedClass");
        }
    }

    BaseClass obj1 = new BaseClass();
    obj1.Foo(); //Outputs "Foo from BaseClass"

    obj1 = new DerivedClass();
    obj1.Foo(); //Outputs "Foo from BaseClass" too!    

Lorsque cela se produit, le membre exécuté est toujours déterminé au moment de la compilation en fonction du type de l'objet.

- Si l'objet est déclaré de type `BaseClass` (même si à l'exécution est d'une classe dérivée) alors la méthode de `BaseClass` est exécutée
- Si l'objet est déclaré de type `DerivedClass` alors la méthode de `DerivedClass` est exécutée.

Il s'agit généralement d'un accident (lorsqu'un membre est ajouté au type de base après qu'un membre identique a été ajouté au type dérivé) et un avertissement du compilateur **CS0108** est généré dans ces scénarios.

Si c'était intentionnel, le mot clé `new` est utilisé pour supprimer l'avertissement du compilateur (et informer les autres développeurs de vos intentions !). le comportement reste le même, le mot clé `new` supprime simplement l'avertissement du compilateur.

    public class BaseClass
    {
        public void Foo()
        {
            Console.WriteLine("Foo from BaseClass");
        }
    }

    public class DerivedClass: BaseClass
    {
        public new void Foo()
        {
            Console.WriteLine("Foo from DerivedClass");
        }
    }

    BaseClass obj1 = new BaseClass();
    obj1.Foo(); //Outputs "Foo from BaseClass"

    obj1 = new DerivedClass();
    obj1.Foo(); //Outputs "Foo from BaseClass" too! 

L'utilisation du remplacement n'est _pas_ facultative
=======================================
Contrairement à C++, l'utilisation du mot clé `override` n'est *pas* facultative :

    public class A
    {
        public virtual void Foo()
        {
        }
    }

    public class B : A
    {
        public void Foo() // Generates CS0108
        {
        }
    }

L'exemple ci-dessus provoque également l'avertissement **CS0108**, car `B.Foo()` ne remplace pas automatiquement `A.Foo()`. Ajoutez `override` lorsque l'intention est de remplacer la classe de base et de provoquer un comportement polymorphe, ajoutez `new` lorsque vous souhaitez un comportement non polymorphe et résolvez l'appel à l'aide du type statique. Ce dernier doit être utilisé avec prudence, car il peut entraîner une grave confusion.

Le code suivant génère même une erreur :

    public class A
    {
        public void Foo()
        {
        }
    }

    public class B : A
    {
        public override void Foo() // Error: Nothing to override
        {
        }
    }

Les classes dérivées peuvent introduire du polymorphisme
=========================================
Le code suivant est parfaitement valide (bien que rare) :

        public class A
        {
            public void Foo()
            {
                Console.WriteLine("A");
            }
        }

        public class B : A
        {
            public new virtual void Foo() 
            {
                Console.WriteLine("B");
            }
        }

Désormais, tous les objets avec une référence statique de B (et ses dérivés) utilisent le polymorphisme pour résoudre `Foo()`, tandis que les références de A utilisent `A.Foo()`.

    A a = new A();
    a.Foo(); // Prints "A";
    a = new B();
    a.Foo(); // Prints "A";
    B b = new B();
    b.Foo(); // Prints "B";

Les méthodes virtuelles ne peuvent pas être privées
=================================
Le compilateur C# est strict pour empêcher les constructions insensées. Les méthodes marquées comme "virtuelles" ne peuvent pas être privées. Étant donné qu'une méthode privée ne peut pas être vue à partir d'un type dérivé, elle ne peut pas non plus être écrasée. Cela ne parvient pas à compiler:

    public class A
    {
        private virtual void Foo() // Error: virtual methods cannot be private
        {
        }
    }

## stackalloc
Le mot clé `stackalloc` crée une région de mémoire sur la pile et renvoie un pointeur vers le début de cette mémoire. La mémoire allouée à la pile est automatiquement supprimée lorsque la portée dans laquelle elle a été créée est quittée.

    //Allocate 1024 bytes. This returns a pointer to the first byte.
    byte* ptr = stackalloc byte[1024];

    //Assign some values...
    ptr[0] = 109;
    ptr[1] = 13;
    ptr[2] = 232;
    ...

<sup>*Utilisé dans un contexte dangereux.*</sup>

Comme avec tous les pointeurs en C #, il n'y a pas de vérification des limites sur les lectures et les affectations. La lecture au-delà des limites de la mémoire allouée aura des résultats imprévisibles - elle peut accéder à un emplacement arbitraire dans la mémoire ou provoquer une exception de violation d'accès.

    //Allocate 1 byte
    byte* ptr = stackalloc byte[1];

    //Unpredictable results...
    ptr[10] = 1;
    ptr[-1] = 2;

La mémoire allouée à la pile est automatiquement supprimée lorsque la portée dans laquelle elle a été créée est quittée. Cela signifie que vous ne devez jamais retourner la mémoire créée avec stackalloc ou la stocker au-delà de la durée de vie de la portée.

    unsafe IntPtr Leak() {
        //Allocate some memory on the stack
        var ptr = stackalloc byte[1024];

        //Return a pointer to that memory (this exits the scope of "Leak")
        return new IntPtr(ptr);
    }

    unsafe void Bad() {
         //ptr is now an invalid pointer, using it in any way will have
         //unpredictable results. This is exactly the same as accessing beyond
         //the bounds of the pointer.
         var ptr = Leak();
    }

`stackalloc` ne peut être utilisé que lors de la déclaration de variables *et* d'initialisation. Ce qui suit n'est *pas* valide :

    byte* ptr;
    ...
    ptr = stackalloc byte[1024];

----------
**Remarques:**

`stackalloc` ne doit être utilisé que pour les optimisations de performances (que ce soit pour le calcul ou l'interopérabilité). Cela est dû au fait que :

- Le ramasse-miettes n'est pas nécessaire car la mémoire est allouée sur la pile plutôt que sur le tas - la mémoire est libérée dès que la variable sort de la portée
- Il est plus rapide d'allouer de la mémoire sur la pile plutôt que sur le tas
- Augmentez les chances d'accès au cache sur le CPU en raison de la localité des données

## Pause
Dans une boucle (for, foreach, do, while), l'instruction `break` interrompt l'exécution de la boucle la plus profonde et revient au code suivant. Il peut également être utilisé avec `yield` dans lequel il spécifie qu'un itérateur est arrivé à son terme.

    for (var i = 0; i < 10; i++)
    {
        if (i == 5)
        {
            break;
        }
        Console.WriteLine("This will appear only 5 times, as the break will stop the loop.");
    }

[Démo en direct sur .NET Fiddle] (https://dotnetfiddle.net/QtpNyk)
    
    foreach (var stuff in stuffCollection)
    {
        if (stuff.SomeStringProp == null)
            break;
        // If stuff.SomeStringProp for any "stuff" is null, the loop is aborted.
        Console.WriteLine(stuff.SomeStringProp);
    }

L'instruction break est également utilisée dans les constructions switch-case pour sortir d'un cas ou d'un segment par défaut.

    switch(a)
    {
        case 5:
            Console.WriteLine("a was 5!");
            break;

        default:
            Console.WriteLine("a was something else!");
            break;
    }

Dans les instructions switch, le mot-clé 'break' est requis à la fin de chaque instruction case. Ceci est contraire à certaines langues qui permettent de "passer" à l'instruction case suivante de la série. Les solutions de contournement pour cela incluraient des instructions 'goto' ou l'empilement séquentiel des instructions 'case'.

Le code suivant donnera les nombres `0, 1, 2, ..., 9` et la dernière ligne ne sera pas exécutée. `yield break` signifie la fin de la fonction (pas seulement une boucle).

    public static IEnumerable<int> GetNumbers()
    {
        int i = 0;
        while (true) {
            if (i < 10) {
                yield return i++;
            } else {
                yield break;
            }
        }
        Console.WriteLine("This line will not be executed");
    }

[Démo en direct sur .NET Fiddle][1]


Notez que contrairement à certains autres langages, il n'y a aucun moyen d'étiqueter une pause particulière en C#. Cela signifie que dans le cas de boucles imbriquées, seule la boucle la plus interne sera arrêtée :

    foreach (var outerItem in outerList)
    {
        foreach (var innerItem in innerList)
        {
            if (innerItem.ShoudBreakForWhateverReason)
                // This will only break out of the inner loop, the outer will continue:
                break; 
        }
    }

Si vous souhaitez sortir de la boucle * externe * ici, vous pouvez utiliser l'une des différentes stratégies, telles que :
- Une instruction **goto** pour sortir de toute la structure en boucle.
- Une variable drapeau spécifique (`shouldBreak` dans l'exemple suivant) qui peut être vérifiée à la fin de chaque itération de la boucle externe.
- Refactoriser le code pour utiliser une instruction `return` dans le corps de la boucle la plus interne, ou éviter toute la structure de boucle imbriquée.


    bool shouldBreak = false;
    while(comeCondition)
    {
        while(otherCondition)
        {
            if (conditionToBreak)
            {
                // Either tranfer control flow to the label below...
                goto endAllLooping;

                // OR use a flag, which can be checked in the outer loop:
                shouldBreak = true;
            }
        }

        if(shouldBreakNow)
        {
            break; // Break out of outer loop if flag was set to true
        }
    }

    endAllLooping: // label from where control flow will continue



[1] : https://dotnetfiddle.net/IjSyVJ

## const
`const` est utilisé pour représenter des valeurs qui ** ne changeront jamais ** pendant toute la durée de vie du programme. Sa valeur est constante depuis **compile-time**, par opposition au mot clé [`readonly`](https://www.wikiod.com/fr/docs/c%23/26/keywords/110/readonly), dont la valeur est constante à partir de l'exécution.

Par exemple, puisque la vitesse de la lumière ne changera jamais, nous pouvons la stocker dans une constante.

    const double c = 299792458;  // Speed of light
    
    double CalculateEnergy(double mass)
    {
        return mass * c * c;
    }

C'est essentiellement la même chose que d'avoir `masse de retour * 299792458 * 299792458`, car le compilateur remplacera directement `c` par sa valeur constante.

Par conséquent, 'c' ne peut pas être modifié une fois déclaré. Ce qui suit produira une erreur de compilation :

    const double c = 299792458;  // Speed of light 
    
    c = 500;  //compile-time error
    
Une constante peut être préfixée avec les mêmes modificateurs d'accès que les méthodes :

    private const double c = 299792458;
    public const double c = 299792458;
    internal const double c = 299792458;

Les membres `const` sont `statiques` par nature. Cependant, l'utilisation explicite de `static` n'est pas autorisée.

Vous pouvez également définir des constantes locales de méthode :

    double CalculateEnergy(double mass)
    {
        const c = 299792458;
        return mass * c * c;
    }

Ceux-ci ne peuvent pas être préfixés par un mot clé `private` ou `public`, car ils sont implicitement locaux à la méthode dans laquelle ils sont définis.

----------

Tous les types ne peuvent pas être utilisés dans une déclaration `const`. Les types de valeur autorisés sont les types prédéfinis `sbyte`, `byte`, `short`, `ushort`, `int`, `uint`, `long`, `ulong`, `char`, ` float`, `double`, `decimal`, `bool` et tous les types `enum`. Essayer de déclarer des membres `const` avec d'autres types de valeurs (tels que `TimeSpan` ou `Guid`) échouera au moment de la compilation.

Pour le type de référence prédéfini spécial "chaîne", les constantes peuvent être déclarées avec n'importe quelle valeur. Pour tous les autres types de référence, les constantes peuvent être déclarées mais doivent toujours avoir la valeur "null".

----------

Comme les valeurs `const` sont connues au moment de la compilation, elles sont autorisées en tant qu'étiquettes `case` dans une instruction `switch`, en tant qu'arguments standard pour les paramètres optionnels, en tant qu'arguments pour les spécifications d'attribut, etc.

----------

Si les valeurs `const` sont utilisées dans différents assemblys, des précautions doivent être prises avec la gestion des versions. Par exemple, si l'assembly A définit un `public const int MaxRetries = 3;` et que l'assembly B utilise cette constante, alors si la valeur de `MaxRetries` est changée plus tard en `5` dans l'assembly A (qui est alors recompilé ), cette modification ne sera pas effective dans l'assembly B _à moins que_ l'assembly B ne soit également recompilé (avec une référence à la nouvelle version de A).

Pour cette raison, si une valeur peut changer dans les futures révisions du programme, et si la valeur doit être visible publiquement, ne déclarez pas cette valeur `const` à moins que vous ne sachiez que tous les assemblys dépendants seront recompilés chaque fois que quelque chose est changé . L'alternative consiste à utiliser `static readonly` au lieu de `const`, qui est résolu au moment de l'exécution.

## pour
Syntaxe : `for (initializer; condition; iterator)`

- La boucle `for` est couramment utilisée lorsque le nombre d'itérations est connu.
- Les instructions de la section `initializer` s'exécutent une seule fois, avant que vous n'entriez dans la boucle.
- La section `condition` contient une expression booléenne qui est évaluée à la fin de chaque itération de boucle pour déterminer si la boucle doit se terminer ou s'exécuter à nouveau.
- La section `iterator` définit ce qui se passe après chaque itération du corps de la boucle.

Cet exemple montre comment `for` peut être utilisé pour parcourir les caractères d'une chaîne :

    string str = "Hello";
    for (int i = 0; i < str.Length; i++)
    {
        Console.WriteLine(str[i]);                
    }
                     
Production:

>H
>e
>l
>l
>o

[<kbd>Démo en direct sur .NET Fiddle</kbd>](https://dotnetfiddle.net/Ybg356)

Toutes les expressions qui définissent une instruction `for` sont facultatives ; par exemple, l'instruction suivante est utilisée pour créer une boucle infinie :

    for( ; ; )
    {
        // Your code here
    }

La section `initializer` peut contenir plusieurs variables, tant qu'elles sont du même type. La section `condition` peut consister en n'importe quelle expression qui peut être évaluée à un `bool`. Et la section `iterator` peut effectuer plusieurs actions séparées par une virgule :

    string hello = "hello";
    for (int i = 0, j = 1, k = 9; i < 3 && k > 0; i++, hello += i) {
        Console.WriteLine(hello);
    }

Production:

> bonjour
> bonjour1
> bonjour12

[<kbd>Démo en direct sur .NET Fiddle</kbd>](https://dotnetfiddle.net/LQcqCv)

## asynchrone, attendre


Le mot-clé "await" a été ajouté dans le cadre de la version C# 5.0 qui est prise en charge à partir de Visual Studio 2012. Il exploite la bibliothèque parallèle de tâches (TPL) qui a rendu le multi-threading relativement plus facile. Les mots-clés `async` et `wait` sont utilisés par paire dans la même fonction, comme indiqué ci-dessous. Le mot-clé `wait` est utilisé pour suspendre l'exécution de la méthode asynchrone en cours jusqu'à ce que la tâche asynchrone attendue soit terminée et/ou que ses résultats soient renvoyés. Pour utiliser le mot-clé `wait`, la méthode qui l'utilise doit être marquée avec le mot-clé `async`.

L'utilisation de `async` avec `void` est fortement déconseillée. Pour plus d'informations, vous pouvez regarder [ici][1].

Exemple:

    public async Task DoSomethingAsync()
    {    
        Console.WriteLine("Starting a useless process...");
        Stopwatch stopwatch = Stopwatch.StartNew();
        int delay = await UselessProcessAsync(1000);
        stopwatch.Stop();
        Console.WriteLine("A useless process took {0} milliseconds to execute.", stopwatch.ElapsedMilliseconds);
    }
    
    public async Task<int> UselessProcessAsync(int x)
    {
        await Task.Delay(x);
        return x;
    }

Production:

> "Démarrage d'un processus inutile..."\
> \
> **... 1 seconde de retard... **
> 
> "Un processus inutile a mis 1000 millisecondes à s'exécuter."

Les paires de mots clés `async` et `await` peuvent être omises si une méthode de renvoi `Task` ou `Task<T>` ne renvoie qu'une seule opération asynchrone.

*Plutôt que ça :*

    public async Task PrintAndDelayAsync(string message, int delay)
    {
        Debug.WriteLine(message);
        await Task.Delay(x);
    }

*Il est préférable de faire ceci :*

    public Task PrintAndDelayAsync(string message, int delay)
    {
        Debug.WriteLine(message);
        return Task.Delay(x);
    }
<!-- si version [éq 5.0] -->
En C# 5.0, `await` ne peut pas être utilisé dans `catch` et `finally`.

<!-- fin de version si -->

<!-- si version [gte 6.0] -->
[Avec C# 6.0][2] 'wait' peut être utilisé dans 'catch' et 'finally'.
<!-- fin de version si -->


[1] : https://msdn.microsoft.com/en-us/magazine/jj991977.aspx
[2] : https://www.wikiod.com/fr/docs/c%23/24/c-sharp-6-0-features/50/await-in-catch-and-finally#t=201607281146527675886

## abstrait
Une classe marquée avec le mot clé `abstract` ne peut pas être instanciée.

Une classe *doit* être marquée comme abstraite si elle contient des membres abstraits ou si elle hérite de membres abstraits qu'elle n'implémente pas. Une classe *peut* être marquée comme abstraite même si aucun membre abstrait n'est impliqué.

Les classes abstraites sont généralement utilisées comme classes de base lorsqu'une partie de l'implémentation doit être spécifiée par un autre composant.

    abstract class Animal 
    {
        string Name { get; set; }
        public abstract void MakeSound();
    }
    
    public class Cat : Animal 
    {
        public override void MakeSound()
        {
            Console.WriteLine("Meov meov");
        }
    }
    
    public class Dog : Animal 
    {   
        public override void MakeSound()
        {
            Console.WriteLine("Bark bark");
        }
    }
    
    Animal cat = new Cat();       // Allowed due to Cat deriving from Animal
    cat.MakeSound();              // will print out "Meov meov"    

    Animal dog = new Dog();       // Allowed due to Dog deriving from Animal
    dog.MakeSound();              // will print out "Bark bark"

    Animal animal = new Animal(); // Not allowed due to being an abstract class

Une méthode, une propriété ou un événement marqué avec le mot-clé `abstract` indique que l'implémentation de ce membre doit être fournie dans une sous-classe. Comme mentionné ci-dessus, les membres abstraits ne peuvent apparaître que dans des classes abstraites.

    abstract class Animal 
    {
       public abstract string Name { get; set; }
    }
    
    public class Cat : Animal 
    {
        public override string Name { get; set; }
    }
    
    public class Dog : Animal 
    {
        public override string Name { get; set; }
    }

## fixé
L'instruction fixe fixe la mémoire à un emplacement. Les objets en mémoire se déplacent généralement, ce qui rend possible le ramasse-miettes. Mais lorsque nous utilisons des pointeurs non sécurisés vers des adresses mémoire, cette mémoire ne doit pas être déplacée.

- Nous utilisons l'instruction fixe pour nous assurer que le ramasse-miettes ne déplace pas les données de la chaîne.

<h3>Variables fixes</h3>

    var myStr = "Hello world!";
    
    fixed (char* ptr = myStr)
    {
        // myStr is now fixed (won't be [re]moved by the Garbage Collector).
        // We can now do something with ptr.
    }

<sup>*Utilisé dans un contexte dangereux.*</sup>


<h3>Taille de tableau fixe</h3>

    unsafe struct Example
    {
        public fixed byte SomeField[8];
        public fixed char AnotherField[64];
    }

`fixed` ne peut être utilisé que sur les champs d'un `struct` (doit également être utilisé dans un contexte non sécurisé).


## défaut
Pour les classes, les interfaces, les délégués, les tableaux, les nullables (tels que int ?) et les types de pointeur, `default(TheType)` renvoie `null` :

    class MyClass {}
    Debug.Assert(default(MyClass) == null);
    Debug.Assert(default(string) == null);

Pour les structures et les énumérations, `default(TheType)` renvoie la même chose que `new TheType()` :

    struct Coordinates
    {
        public int X { get; set; }
        public int Y { get; set; }
    }

    struct MyStruct
    {
        public string Name { get; set; }
        public Coordinates Location { get; set; }
        public Coordinates? SecondLocation { get; set; }
        public TimeSpan Duration { get; set; }
    }

    var defaultStruct = default(MyStruct);
    Debug.Assert(defaultStruct.Equals(new MyStruct()));
    Debug.Assert(defaultStruct.Location.Equals(new Coordinates()));
    Debug.Assert(defaultStruct.Location.X == 0);
    Debug.Assert(defaultStruct.Location.Y == 0);
    Debug.Assert(defaultStruct.SecondLocation == null);
    Debug.Assert(defaultStruct.Name == null);
    Debug.Assert(defaultStruct.Duration == TimeSpan.Zero);

`default(T)` peut être particulièrement utile lorsque `T` est un paramètre générique pour lequel aucune contrainte n'est présente pour décider si `T` est un type référence ou un type valeur, par exemple :

    public T GetResourceOrDefault<T>(string resourceName)
    {
       if (ResourceExists(resourceName))
       {
          return (T)GetResource(resourceName);
       }
       else
       {
          return default(T);
       }
    }

## est
Vérifie si un objet est compatible avec un type donné, c'est-à-dire si un objet est une instance du type `BaseInterface` ou un type dérivé de `BaseInterface` :

    interface BaseInterface {}
    class BaseClass : BaseInterface {}
    class DerivedClass : BaseClass {}

    var d = new DerivedClass();
    Console.WriteLine(d is DerivedClass);  // True
    Console.WriteLine(d is BaseClass);     // True
    Console.WriteLine(d is BaseInterface); // True
    Console.WriteLine(d is object);        // True
    Console.WriteLine(d is string);        // False
    
    var b = new BaseClass();
    Console.WriteLine(b is DerivedClass);  // False
    Console.WriteLine(b is BaseClass);     // True
    Console.WriteLine(b is BaseInterface); // True
    Console.WriteLine(b is object);        // True
    Console.WriteLine(b is string);        // False

Si l'intention de la distribution est d'utiliser l'objet, il est préférable d'utiliser le mot-clé [`as`](https://www.wikiod.com/fr/docs/c%23/26/keywords/138/as)'

    interface BaseInterface {}
    class BaseClass : BaseInterface {}
    class DerivedClass : BaseClass {}

    var d = new DerivedClass();
    Console.WriteLine(d is DerivedClass);  // True - valid use of 'is'
    Console.WriteLine(d is BaseClass);     // True - valid use of 'is'
    
    if(d is BaseClass){
        var castedD = (BaseClass)d;
        castedD.Method(); // valid, but not best practice
    }

    var asD = d as BaseClass;

    if(asD!=null){
        asD.Method(); //prefered method since you incur only one unboxing penalty
    }

Mais, à partir de C# 7 [`pattern matching`](https://www.wikiod.com/fr/docs/c%23/1936/c-sharp-7-0-features/13323/pattern-matching#t=201707130940065371224) la fonctionnalité s'étend l'opérateur is pour vérifier un type et déclarer une nouvelle variable en même temps. Même partie de code avec C# 7 :

<!-- si version [gte 7.0] -->

    if(d is BaseClass asD ){
        asD.Method();
    }
<!-- fin de version si -->

## scellé
Lorsqu'il est appliqué à une classe, le modificateur `sealed` empêche les autres classes d'en hériter.

    class A { }
    sealed class B : A { }
    class C : B { } //error : Cannot derive from the sealed class

Lorsqu'il est appliqué à une méthode `virtual` (ou propriété virtuelle), le modificateur `sealed` empêche cette méthode (propriété) d'être *surchargée* dans les classes dérivées.

    public class A 
    {
        public sealed override string ToString() // Virtual method inherited from class Object
        {
            return "Do not override me!";
        }
    }

    public class B: A 
    {
        public override string ToString() // Compile time error
        { 
            return "An attempt to override"; 
        }
    }

## lecture seulement
Le mot clé `readonly` est un modificateur de champ. Lorsqu'une déclaration de champ inclut un modificateur `readonly`, les affectations à ce champ ne peuvent se produire que dans le cadre de la déclaration ou dans un constructeur de la même classe.

Le mot-clé `readonly` est différent du mot-clé `const`. Un champ `const` ne peut être initialisé qu'à la déclaration du champ. Un champ `readonly` peut être initialisé soit à la déclaration, soit dans un constructeur. Par conséquent, les champs `readonly` peuvent avoir des valeurs différentes selon le constructeur utilisé.

Le mot clé `readonly` est souvent utilisé lors de l'injection de dépendances.

    class Person
    {
        readonly string _name;
        readonly string _surname = "Surname";

        Person(string name)
        {
            _name = name;
        }
        void ChangeName()
        {
            _name = "another name"; // Compile error
            _surname = "another surname"; // Compile error
        }
    }


> Note : Déclarer un champ *readonly* n'implique pas *l'immuabilité*. Si le champ est un *type de référence*, le **contenu** de l'objet peut être modifié. *Lecture seule* est généralement utilisé pour empêcher que l'objet soit **écrasé** et attribué uniquement pendant l'**instanciation** de cet objet.

> Remarque : à l'intérieur du constructeur, un champ en lecture seule peut être réaffecté

    public class Car
    {
        public double Speed {get; set;}
    }

    //In code

    private readonly Car car = new Car();

    private void SomeMethod()
    {
        car.Speed = 100;
    }

## Type de
Renvoie le `Type` d'un objet, sans qu'il soit nécessaire de l'instancier.

    Type type = typeof(string);
    Console.WriteLine(type.FullName); //System.String
    Console.WriteLine("Hello".GetType() == type); //True
    Console.WriteLine("Hello".GetType() == typeof(string)); //True

## cette
Le mot-clé `this` fait référence à l'instance actuelle de class(object). De cette façon, deux variables portant le même nom, une au niveau de la classe (un champ) et une étant un paramètre (ou une variable locale) d'une méthode, peuvent être distinguées.
    
    public MyClass {
        int a;
    
        void set_a(int a)
        {
            //this.a refers to the variable defined outside of the method,
            //while a refers to the passed parameter.
            this.a = a;
        }
    }

Les autres utilisations du mot-clé sont [chaîner les surcharges de constructeurs non statiques] [1] :

    public MyClass(int arg) : this(arg, null)
    {
    }

et en écrivant [indexers][2] :

    public string this[int idx1, string idx2]
    {
        get { /* ... */ }
        set { /* ... */ }
    }

et en déclarant [méthodes d'extension][3] :

    public static int Count<TItem>(this IEnumerable<TItem> source)
    {
        // ...
    }

S'il n'y a pas de conflit avec une variable ou un paramètre local, c'est une question de style d'utiliser `this` ou non, donc `this.MemberOfType` et `MemberOfType` seraient équivalents dans ce cas. Voir également le mot-clé [`base`][4].

Notez que si une méthode d'extension doit être appelée sur l'instance actuelle, `this` est requis. Par exemple, si vous êtes dans une méthode non statique d'une classe qui implémente `IEnumerable<>` et que vous souhaitez appeler l'extension `Count` d'avant, vous devez utiliser :

    this.Count()  // works like StaticClassForExtensionMethod.Count(this)

et "ceci" ne peut pas y être omis.


[1] : https://www.wikiod.com/fr/docs/c%23/25/constructors-destructors/56/calling-a-constructor-from-another-constructor#t=201607231911138150753
[2] : https://www.wikiod.com/fr/docs/c%23/1660/indexer#t=201607252101420586035
[3] : https://www.wikiod.com/fr/docs/c%23/20/extension-methods#t=20160723191025670507
[4] : https://www.wikiod.com/fr/docs/c%23/26/keywords/1840/base#t=201607261455204441752

## pour chaque
`foreach` est utilisé pour parcourir les éléments d'un tableau ou les éléments d'une collection qui implémente [`IEnumerable`][3]✝.

    var lines = new string[] { 
        "Hello world!", 
        "How are you doing today?", 
        "Goodbye"
    };

    foreach (string line in lines)
    {
        Console.WriteLine(line);
    }

Cela produira

> "Bonjour le monde !"
> "Comment vas-tu aujourd'hui ?"
> "Au revoir"

[Démo en direct sur .NET Fiddle] (https://dotnetfiddle.net/0jy78m)

Vous pouvez quitter la boucle `foreach` à tout moment en utilisant le mot-clé [break][1] ou passer à l'itération suivante en utilisant le mot-clé [continue][2].

    var numbers = new int[] {1, 2, 3, 4, 5, 6};

    foreach (var number in numbers)
    {
        // Skip if 2
        if (number == 2)
            continue;

        // Stop iteration if 5
        if (number == 5)
            break;

        Console.Write(number + ", ");
    }

    // Prints: 1, 3, 4, 

[Démo en direct sur .NET Fiddle] (https://dotnetfiddle.net/dfSAbF)

Notez que l'ordre d'itération est garanti *uniquement* pour certaines collections telles que les tableaux et `List`, mais **non** garanti pour de nombreuses autres collections.

----------

✝ Alors que `IEnumerable` est généralement utilisé pour indiquer des collections énumérables, `foreach` nécessite uniquement que la collection expose publiquement la méthode `object GetEnumerator()`, qui doit renvoyer un objet qui expose la méthode `bool MoveNext()` et la méthode ` objet Courant { obtenir ; }` propriété.

[1] : https://www.wikiod.com/fr/docs/c%23/26/keywords/2858/break
[2] : https://www.wikiod.com/fr/docs/c%23/26/keywords/154/continue
[3] : https://msdn.microsoft.com/en-us/library/system.collections.ienumerable(v=vs.110).aspx

## dynamique
Le mot-clé `dynamic` est utilisé avec [les objets typés dynamiquement][1]. Les objets déclarés comme "dynamiques" renoncent aux vérifications statiques au moment de la compilation et sont plutôt évalués au moment de l'exécution.

    using System;
    using System.Dynamic;
    
    dynamic info = new ExpandoObject();
    info.Id = 123;
    info.Another = 456;
    
    Console.WriteLine(info.Another);
    // 456
    
    Console.WriteLine(info.DoesntExist);
    // Throws RuntimeBinderException

L'exemple suivant utilise `dynamic` avec la bibliothèque Json.NET de Newtonsoft, afin de lire facilement les données d'un fichier JSON désérialisé.

    try
    {
        string json = @"{ x : 10, y : ""ho""}";
        dynamic deserializedJson = JsonConvert.DeserializeObject(json);
        int x = deserializedJson.x;
        string y = deserializedJson.y;
        // int z = deserializedJson.z; // throws RuntimeBinderException
    }
    catch (RuntimeBinderException e)
    {
        // This exception is thrown when a property
        // that wasn't assigned to a dynamic variable is used
    }

[1] : https://www.wikiod.com/fr/docs/c%23/762/dynamic-type#t=201607212330428041437

Certaines limitations sont associées au mot-clé dynamique. L'une d'elles est l'utilisation de méthodes d'extension. L'exemple suivant ajoute une méthode d'extension pour la chaîne : `SayHello`.

    static class StringExtensions
    {
        public static string SayHello(this string s) => $"Hello {s}!";
    }

La première approche sera de l'appeler comme d'habitude (comme pour une chaîne) :

    var person = "Person";
    Console.WriteLine(person.SayHello());

    dynamic manager = "Manager";
    Console.WriteLine(manager.SayHello()); // RuntimeBinderException

Aucune erreur de compilation, mais lors de l'exécution, vous obtenez une `RuntimeBinderException`. La solution de contournement pour cela sera d'appeler la méthode d'extension via la classe statique :

    var helloManager = StringExtensions.SayHello(manager);
    Console.WriteLine(helloManager);

## essayer, attraper, enfin lancer
`try`, `catch`, `finally` et `throw` vous permettent de gérer les exceptions dans votre code.

    var processor = new InputProcessor();

    // The code within the try block will be executed. If an exception occurs during execution of
    // this code, execution will pass to the catch block corresponding to the exception type.
    try 
    {
        processor.Process(input);
    }
    // If a FormatException is thrown during the try block, then this catch block
    // will be executed.
    catch (FormatException ex)
    {
        // Throw is a keyword that will manually throw an exception, triggering any catch block that is
        // waiting for that exception type. 
        throw new InvalidOperationException("Invalid input", ex);
    }
    // catch can be used to catch all or any specific exceptions. This catch block,
    // with no type specified, catches any exception that hasn't already been caught
    // in a prior catch block.
    catch
    {
        LogUnexpectedException(); 
        throw; // Re-throws the original exception.
    }
    // The finally block is executed after all try-catch blocks have been; either after the try has
    // succeeded in running all commands or after all exceptions have been caught. 
    finally
    {
        processor.Dispose();
    }

**Remarque :** Le mot clé `return` peut être utilisé dans le bloc `try`, et le bloc `finally` sera toujours exécuté (juste avant le retour). Par exemple:

    try 
    {
        connection.Open();
        return connection.Get(query);
    } 
    finally 
    {
        connection.Close();
    }
 
L'instruction `connection.Close()` s'exécutera avant que le résultat de `connection.Get(query)` ne soit renvoyé.

## espace de noms
Le mot-clé `namespace` est une construction d'organisation qui nous aide à comprendre comment une base de code est organisée. Les espaces de noms en C # sont des espaces virtuels plutôt que d'être dans un dossier physique.

    namespace StackOverflow
    {
        namespace Documentation
        {
            namespace CSharp.Keywords
            {
                public class Program
                {
                    public static void Main()
                    {
                        Console.WriteLine(typeof(Program).Namespace);
                        //StackOverflow.Documentation.CSharp.Keywords
                    }
                }
            }
        }
    }

Les espaces de noms en C # peuvent également être écrits dans une syntaxe chaînée. Ce qui suit est équivalent à ci-dessus :

    namespace StackOverflow.Documentation.CSharp.Keywords
    {
        public class Program
        {
            public static void Main()
            {
                Console.WriteLine(typeof(Program).Namespace);
                //StackOverflow.Documentation.CSharp.Keywords
            }
        }
    }

## annuler
Le mot réservé `"void"` est un alias de type `System.Void`, et a deux usages :

1. Déclarez une méthode qui n'a pas de valeur de retour :


    public void DoSomething()
    {
        // Do some work, don't return any value to the caller.
    }

Une méthode avec un type de retour void peut toujours avoir le mot-clé `return` dans son corps. Ceci est utile lorsque vous souhaitez quitter l'exécution de la méthode et renvoyer le flux à l'appelant :

    public void DoSomething()
    {
        // Do some work...

        if (condition)
            return;

        // Do some more work if the condition evaluated to false.
    }

2. Déclarez un pointeur vers un type inconnu dans un contexte non sécurisé.

Dans un contexte non sécurisé, un type peut être un type pointeur, un type valeur ou un type référence. Une déclaration de type de pointeur est généralement `type* identifier`, où le type est un type connu - c'est-à-dire `int* myInt`, mais peut également être `void* identifier`, où le type est inconnu.

Notez que déclarer un type de pointeur vide est [déconseillé par Microsoft.][1]


[1] : https://msdn.microsoft.com/en-us/library/y31yhkeb.aspx

## réf, sortie
Les mots clés `ref` et `out` font passer un argument par référence, et non par valeur. Pour les types valeur, cela signifie que la valeur de la variable peut être modifiée par l'appelé.

    int x = 5;
    ChangeX(ref x);
    // The value of x could be different now

Pour les types de référence, l'instance dans la variable peut non seulement être modifiée (comme c'est le cas sans `ref`), mais elle peut aussi être complètement remplacée :

    Address a = new Address();
    ChangeFieldInAddress(a);
    // a will be the same instance as before, even if it is modified
    CreateANewInstance(ref a);
    // a could be an entirely new instance now

La principale différence entre les mots clés `out` et `ref` est que `ref` nécessite que la variable soit initialisée par l'appelant, tandis que `out` transmet cette responsabilité à l'appelé.

Pour utiliser un paramètre `out`, la définition de la méthode et la méthode appelante doivent utiliser explicitement le mot-clé `out`.

    int number = 1;
    Console.WriteLine("Before AddByRef: " + number); // number = 1
    AddOneByRef(ref number);
    Console.WriteLine("After AddByRef: " + number);  // number = 2
    SetByOut(out number);
    Console.WriteLine("After SetByOut: " + number);  // number = 34

    void AddOneByRef(ref int value)
    {
        value++;
    }
    
    void SetByOut(out int value)
    {
        value = 34;
    }

[<kbd>Démo en direct sur .NET Fiddle</kbd>](https://dotnetfiddle.net/ma2ikc)
    
Ce qui suit ne se compile *pas*, car les paramètres `out` doivent avoir une valeur assignée avant le retour de la méthode (elle compilerait en utilisant `ref` à la place):

    void PrintByOut(out int value)
    {
        Console.WriteLine("Hello!");
    }

** en utilisant notre mot-clé comme modificateur générique **

Le mot-clé `out` peut également être utilisé dans les paramètres de type générique lors de la définition d'interfaces et de délégués génériques. Dans ce cas, le mot-clé `out` spécifie que le paramètre de type est covariant.

> La covariance vous permet d'utiliser un type plus dérivé que celui spécifié par le paramètre générique. Cela permet la conversion implicite des classes qui implémentent des interfaces variantes et la conversion implicite des types délégués. La covariance et la contravariance sont prises en charge pour les types référence, mais elles ne le sont pas pour les types valeur. -MSDN

    //if we have an interface like this
    interface ICovariant<out R> { }
    
    //and two variables like
    ICovariant<Object> iobj = new Sample<Object>();
    ICovariant<String> istr = new Sample<String>();

    // then the following statement is valid
    // without the out keyword this would have thrown error
    iobj = istr; // implicit conversion occurs here
   

## base
Le mot-clé **`base`** est utilisé pour accéder aux membres d'une classe de base. Il est couramment utilisé pour appeler des implémentations de base de méthodes virtuelles ou pour spécifier quel constructeur de base doit être appelé.

**Choix d'un constructeur**

    public class Child : SomeBaseClass {
        public Child() : base("some string for the base class")
        {
        }
    }

    public class SomeBaseClass {
        public SomeBaseClass()
        {
            // new Child() will not call this constructor, as it does not have a parameter
        }
        public SomeBaseClass(string message)
        {
            // new Child() will use this base constructor because of the specified parameter in Child's constructor
            Console.WriteLine(message);
        }
    }

**Mise en œuvre de la base d'appel de la méthode virtuelle**

    public override void SomeVirtualMethod() {
        // Do something, then call base implementation
        base.SomeVirtualMethod();
    }

Il est possible d'utiliser le mot-clé base pour appeler une implémentation de base à partir de n'importe quelle méthode. Cela lie l'appel de méthode directement à l'implémentation de base, ce qui signifie que même si de nouvelles classes enfants remplacent une méthode virtuelle, l'implémentation de base sera toujours appelée, donc cela doit être utilisé avec prudence.

    public class Parent
    {
        public virtual int VirtualMethod()
        {
            return 1;
        }
    }

    public class Child : Parent
    {
        public override int VirtualMethod() {
            return 11;
        }

        public int NormalMethod()
        {
            return base.VirtualMethod();
        }

        public void CallMethods()
        {
            Assert.AreEqual(11, VirtualMethod());

            Assert.AreEqual(1, NormalMethod());
            Assert.AreEqual(1, base.VirtualMethod());
        }
    }

    public class GrandChild : Child
    {
        public override int VirtualMethod()
        {
            return 21;
        }

        public void CallAgain()
        {
            Assert.AreEqual(21, VirtualMethod());
            Assert.AreEqual(11, base.VirtualMethod());

            // Notice that the call to NormalMethod below still returns the value
            // from the extreme base class even though the method has been overridden
            // in the child class.
            Assert.AreEqual(1, NormalMethod());
        }
    }



## paramètres
`params` permet à un paramètre de méthode de recevoir un nombre variable d'arguments, c'est-à-dire que zéro, un ou plusieurs arguments sont autorisés pour ce paramètre.

    static int AddAll(params int[] numbers)
    {
        int total = 0;
        foreach (int number in numbers)
        {
            total += number;
        }
        
        return total;
    }

Cette méthode peut maintenant être appelée avec une liste typique d'arguments "int" ou un tableau d'entiers.

    AddAll(5, 10, 15, 20);                // 50
    AddAll(new int[] { 5, 10, 15, 20 });  // 50

`params` doit apparaître au plus une fois et s'il est utilisé, il doit être **dernier** dans la liste des arguments, même si le type suivant est différent de celui du tableau.

----

Soyez prudent lorsque vous surchargez des fonctions lorsque vous utilisez le mot-clé `params`. C# préfère faire correspondre des surcharges plus spécifiques avant d'essayer d'utiliser des surcharges avec `params`. Par exemple si vous avez deux méthodes :

    static double Add(params double[] numbers)
    {
        Console.WriteLine("Add with array of doubles");
        double total = 0.0;
        foreach (double number in numbers)
        {
            total += number;
        }
        
        return total;
    }

    static int Add(int a, int b)
    {
        Console.WriteLine("Add with 2 ints");
        return a + b;
    }

Ensuite, la surcharge spécifique à 2 arguments aura priorité avant d'essayer la surcharge `params`.

    Add(2, 3);      //prints "Add with 2 ints"
    Add(2, 3.0);    //prints "Add with array of doubles" (doubles are not ints)
    Add(2, 3, 4);   //prints "Add with array of doubles" (no 3 argument overload)


## flottant, double, décimal
# flotteur #

`float` est un alias du type de données .NET `System.Single`. Il permet de stocker des nombres à virgule flottante simple précision IEEE 754. Ce type de données est présent dans `mscorlib.dll` qui est implicitement référencé par chaque projet C # lorsque vous les créez.

Plage approximative : -3,4 × 10<sup>38</sup> à 3,4 × 10<sup>38</sup>

Précision décimale : 6-9 chiffres significatifs

**Notation**:

    float f = 0.1259;
    var f1 = 0.7895f; // f is literal suffix to represent float values 

> Il convient de noter que le type « float » entraîne souvent des
> erreurs d'arrondi. Dans les applications où la précision est importante, d'autres
> les types de données doivent être pris en compte.


----------
# double #

`double` est un alias du type de données .NET `System.Double`. Il représente un nombre à virgule flottante 64 bits à double précision. Ce type de données est présent dans `mscorlib.dll` qui est implicitement référencé dans tout projet C#.

Plage : ±5,0 × 10<sup>−324</sup> à ±1,7 × 10<sup>308</sup>

Précision décimale : 15-16 chiffres significatifs

**Notation**:

    double distance = 200.34; // a double value
    double salary = 245; // an integer implicitly type-casted to double value
    var marks = 123.764D; // D is literal suffix to represent double values

----------
# décimal #

`decimal` est un alias du type de données .NET `System.Decimal`. Il représente un mot clé indiquant un type de données 128 bits. Comparé aux types à virgule flottante, le type décimal a plus de précision et une plage plus petite, ce qui le rend approprié pour les calculs financiers et monétaires. Ce type de données est présent dans `mscorlib.dll` qui est implicitement référencé dans tout projet C#.

Plage : -7,9 × 10<sup>28</sup> à 7,9 × 10<sup>28</sup>

Précision décimale : 28-29 chiffres significatifs

**Notation**:

    decimal payable = 152.25m; // a decimal value
    var marks = 754.24m; // m is literal suffix to represent decimal values

## caractère
Un caractère est une lettre unique stockée dans une variable. C'est un type de valeur intégré qui prend deux octets d'espace mémoire. Il représente le type de données `System.Char` trouvé dans `mscorlib.dll` qui est implicitement référencé par chaque projet C # lorsque vous les créez.

Il existe plusieurs façons de procéder.
1) `car c = 'c';`
2) `char c = '\u0063'; //Unicode`
3) `char c = '\x0063' ; //Hex`
4) `car c = (char)99;//Intégral`

Un char peut être implicitement converti en `ushort, int, uint, long, ulong, float, double,` ou `decimal` et il renverra la valeur entière de ce char.

    ushort u = c;
renvoie 99, etc.

Cependant, il n'y a pas de conversions implicites d'autres types vers char. Au lieu de cela, vous devez les lancer.
 

    ushort u = 99;
     char c = (char)u;



## opérateur
La plupart des [opérateurs intégrés][OPERATORS] (y compris les opérateurs de conversion) peuvent être surchargés en utilisant le mot clé `operator` avec les modificateurs `public` et `static`.

Les opérateurs se présentent sous trois formes : les opérateurs unaires, les opérateurs binaires et les opérateurs de conversion.

Les opérateurs unaires et binaires nécessitent au moins un paramètre du même type que le type contenant, et certains nécessitent un opérateur de correspondance complémentaire.

Les opérateurs de conversion doivent convertir vers ou à partir du type englobant.

    public struct Vector32
    {
        
        public Vector32(int x, int y)
        {
            X = x;
            Y = y;
        }
        
        public int X { get; }
        public int Y { get; }

        public static bool operator ==(Vector32 left, Vector32 right)
            => left.X == right.X && left.Y == right.Y;

        public static bool operator !=(Vector32 left, Vector32 right)
            => !(left == right);

        public static Vector32 operator +(Vector32 left, Vector32 right)
            => new Vector32(left.X + right.X, left.Y + right.Y);

        public static Vector32 operator +(Vector32 left, int right)
            => new Vector32(left.X + right, left.Y + right);

        public static Vector32 operator +(int left, Vector32 right)
            => right + left;

        public static Vector32 operator -(Vector32 left, Vector32 right)
            => new Vector32(left.X - right.X, left.Y - right.Y);

        public static Vector32 operator -(Vector32 left, int right)
            => new Vector32(left.X - right, left.Y - right);

        public static Vector32 operator -(int left, Vector32 right)
            => right - left;

        public static implicit operator Vector64(Vector32 vector)
            => new Vector64(vector.X, vector.Y);

        public override string ToString() => $"{{{X}, {Y}}}";

    }

    public struct Vector64
    {

        public Vector64(long x, long y)
        {
            X = x;
            Y = y;
        }

        public long X { get; }
        public long Y { get; }

        public override string ToString() => $"{{{X}, {Y}}}";

    }

**Exemple**

    var vector1 = new Vector32(15, 39);
    var vector2 = new Vector32(87, 64);
            
    Console.WriteLine(vector1 == vector2); // false
    Console.WriteLine(vector1 != vector2); // true
    Console.WriteLine(vector1 + vector2);  // {102, 103}
    Console.WriteLine(vector1 - vector2);  // {-72, -25}

[OPÉRATEURS] : https://msdn.microsoft.com/en-us/library/6a71f45d.aspx

## Continuez
Passez immédiatement le contrôle à la prochaine itération de la construction de boucle englobante (for, foreach, do, while) :

    for (var i = 0; i < 10; i++)
    {
        if (i < 5)
        {
            continue;
        }
        Console.WriteLine(i);
    }

Production:

> 5
> 6
> 7
> 8
> 9

[<kbd>Démo en direct sur .NET Fiddle</kbd>](https://dotnetfiddle.net/H2NB0V)

    var stuff = new [] {"a", "b", null, "c", "d"};

    foreach (var s in stuff)
    {
        if (s == null)
        {
            continue;
        }           
        Console.WriteLine(s);
    }

Production:

> un
> b
>c
> j

[Démo en direct sur .NET Fiddle] (https://dotnetfiddle.net/l1JPiI)

## tandis que
L'opérateur `while` itère sur un bloc de code jusqu'à ce que la requête conditionnelle soit égale à false ou que le code soit interrompu par un [`goto`](https://www.wikiod.com/fr/docs/c%23/26/keywords/193/ goto), [`return`](https://www.wikiod.com/fr/docs/c%23/26/keywords/4600/return), [`break`](https://www.wikiod.com/fr/docs/c% 23/26/keywords/2858/break) ou l'instruction "throw".

Syntaxe du mot-clé "while" :

> tant que( *condition* )
> { *bloc de code ;* }

Exemple:

    int i = 0;
    while (i++ < 5)
    {
        Console.WriteLine("While is on loop number {0}.", i);
    }

Production:

>"While est sur la boucle numéro 1." \
"While est sur la boucle numéro 2."\
"While est sur la boucle numéro 3."\
"While est sur la boucle numéro 4."\
"Alors que c'est sur la boucle numéro 5."

[<kbd>Démo en direct sur .NET Fiddle</kbd>](https://dotnetfiddle.net/KRQjV0)

Une boucle while est **Contrôle d'entrée**, car la condition est vérifiée **avant** l'exécution du bloc de code joint. Cela signifie que la boucle while n'exécutera pas ses instructions si la condition est fausse.

    bool a = false;
    
    while (a == true)
    {
        Console.WriteLine("This will never be printed.");
    }

Donner une condition "while" sans la configurer pour qu'elle devienne fausse à un moment donné entraînera une boucle infinie ou sans fin. Dans la mesure du possible, cela doit être évité, cependant, il peut y avoir des circonstances exceptionnelles dans lesquelles vous en avez besoin.

Vous pouvez créer une telle boucle comme suit :

    while (true)
    {
    //...
    }

Notez que le compilateur C# transformera les boucles telles que

    while (true)
    {
    // ...
    }

ou

    for(;;)
    {
    // ...
    }

dans

    {
    :label
    // ...
    goto label;
    }

Notez qu'une boucle while peut avoir n'importe quelle condition, quelle que soit sa complexité, tant qu'elle évalue (ou renvoie) une valeur booléenne (bool). Il peut également contenir une fonction qui renvoie une valeur booléenne (car une telle fonction évalue le même type qu'une expression telle que `a==x'). Par exemple,

    while (AgriculturalService.MoreCornToPick(myFarm.GetAddress()))
    {
        myFarm.PickCorn();
    }

## revenir
> MSDN : L'instruction return termine l'exécution de la méthode dans laquelle
> il apparaît et rend le contrôle à la méthode appelante. Ça peut aussi
> renvoie une valeur facultative. Si la méthode est de type void, le retour
> déclaration peut être omise.

    public int Sum(int valueA, int valueB)
    {
        return valueA + valueB;
    }

    
    public void Terminate(bool terminateEarly)
    {
        if (terminateEarly) return; // method returns to caller if true was passed in
        else Console.WriteLine("Not early"); // prints only if terminateEarly was false
    }

## nul
Une variable d'un type référence peut contenir soit une référence valide à une instance, soit une référence nulle. La référence null est la valeur par défaut des variables de type référence, ainsi que des types de valeur nullable.

`null` est le mot-clé qui représente une référence nulle.

En tant qu'expression, il peut être utilisé pour attribuer la référence null aux variables des types susmentionnés :

    object a = null;
    string b = null;
    int? c = null;
    List<int> d  = null;

Les types de valeur non nullables ne peuvent pas se voir attribuer une référence null. Toutes les affectations suivantes sont invalides :

    int a = null; 
    float b = null;
    decimal c = null;

La référence nulle ne doit *pas* être confondue avec des instances valides de différents types tels que :

- une liste vide (`new List<int>()`)
- une chaîne vide (`""`)
- le chiffre zéro (`0`, `0f`, `0m`)
- le caractère nul ( `'\0'` )

Parfois, il est utile de vérifier si quelque chose est null ou un objet vide/par défaut. La méthode System.String.IsNullOrEmpty(String) peut être utilisée pour vérifier cela, ou vous pouvez implémenter votre propre méthode équivalente.

    private void GreetUser(string userName)
    {
        if (String.IsNullOrEmpty(userName))
        {
            //The method that called us either sent in an empty string, or they sent us a null reference. Either way, we need to report the problem.
            throw new InvalidOperationException("userName may not be null or empty.");
        }
        else
        {
            //userName is acceptable.
            Console.WriteLine("Hello, " + userName + "!");
        }
    }

## chaîne de caractères
`string` est un alias du type de données .NET `System.String`, qui permet de stocker du texte (séquences de caractères).

Notation:

    string a = "Hello";
    var b = "world";
    var f = new string(new []{ 'h', 'i', '!' }); // hi!

Chaque caractère de la chaîne est encodé en UTF-16, ce qui signifie que chaque caractère nécessitera un minimum de 2 octets d'espace de stockage.

## uint
Un **entier non signé**, ou **uint**, est un type de données numérique qui ne peut contenir que des entiers positifs. Comme son nom l'indique, il représente un entier 32 bits non signé. Le mot clé **uint** lui-même est un alias pour le type Common Type System `System.UInt32`. Ce type de données est présent dans `mscorlib.dll`, qui est implicitement référencé par chaque projet C # lorsque vous les créez. Il occupe quatre octets d'espace mémoire.

Les entiers non signés peuvent contenir n'importe quelle valeur comprise entre 0 et 4 294 967 295.


* Exemples sur comment et maintenant ne pas déclarer des entiers non signés *

    uint i = 425697; // Valid expression, explicitly stated to compiler
    var i1 = 789247U; // Valid expression, suffix allows compiler to determine datatype
    uint x = 3.0; // Error, there is no implicit conversion

----------

**Veuillez noter :** Selon [Microsoft][1], il est recommandé d'utiliser le type de données **[int][2]** dans la mesure du possible car le type de données **uint** n'est pas conforme à CLS.


[1] : https://msdn.microsoft.com/en-us/library/x0sksh43.aspx
[2] : https://www.wikiod.com/fr/docs/c%23/26/keywords#t=201608192209189084166

## utilisant
Il existe deux types d'utilisation du mot clé `using`, `using statement` et `using directive` :

1. **instruction d'utilisation** :

    The `using` keyword ensures that objects that implement the `IDisposable` interface are properly disposed after usage. There is a separate topic for the [using statement][1]
    
2. **directive d'utilisation**

La directive `using` a trois utilisations, voir la [page msdn pour la directive using][2]. Il existe un sujet distinct pour la [directive using][3].


[1] : https://www.wikiod.com/fr/docs/c%23/38/using-statement#t=201607311905386691069
[2] : https://msdn.microsoft.com/en-us/library/sf0df423.aspx
[3] : https://www.wikiod.com/fr/docs/c%23/52/using-directive#t=201607311908368095223

## statique
Le modificateur `static` est utilisé pour déclarer un membre statique, qui n'a pas besoin d'être instancié pour être accessible, mais est simplement accessible via son nom, c'est-à-dire `DateTime.Now`.

`static` peut être utilisé avec des classes, des champs, des méthodes, des propriétés, des opérateurs, des événements et des constructeurs.

Alors qu'une instance d'une classe contient une copie distincte de tous les champs d'instance de la classe, il n'y a qu'une seule copie de chaque champ statique.

    class A
    {
        static public int count = 0;

        public A()
        {
            count++;
        }
    }

    class Program
    {
        static void Main(string[] args)
        {
            A a = new A();
            A b = new A();
            A c = new A();

            Console.WriteLine(A.count); // 3 
        }
    }

`count` est égal au nombre total d'instances de la classe `A`.

Le modificateur static peut également être utilisé pour déclarer un constructeur statique pour une classe, pour initialiser des données statiques ou exécuter du code qui n'a besoin d'être appelé qu'une seule fois. Les constructeurs statiques sont appelés avant que la classe ne soit référencée pour la première fois.

    class A
    {
        static public DateTime InitializationTime;

        // Static constructor
        static A()
        {
            InitializationTime = DateTime.Now;
            // Guaranteed to only run once
            Console.WriteLine(InitializationTime.ToString());
        }
    }

Une `classe statique` est marquée avec le mot-clé `static` et peut être utilisée comme conteneur utile pour un ensemble de méthodes qui fonctionnent sur des paramètres, mais ne nécessitent pas nécessairement d'être liées à une instance. En raison de la nature "statique" de la classe, elle ne peut pas être instanciée, mais elle peut contenir un "constructeur statique". Certaines fonctionnalités d'une "classe statique" incluent :

- Ne peut pas être hérité
- Ne peut pas hériter d'autre chose que `Object`
- Peut contenir un constructeur statique mais pas un constructeur d'instance
- Ne peut contenir que des membres statiques
- Est scellé

Le compilateur est également convivial et indiquera au développeur si des membres d'instance existent dans la classe. Un exemple serait une classe statique qui convertit entre les métriques américaines et canadiennes :

    static class ConversionHelper {
        private static double oneGallonPerLitreRate = 0.264172;

        public static double litreToGallonConversion(int litres) {
            return litres * oneGallonPerLitreRate;
        }
    }

Lorsque les classes sont déclarées statiques :

    public static class Functions
    {
      public static int Double(int value)
      {
        return value + value;
      }
    }

toutes les fonctions, propriétés ou membres de la classe doivent également être déclarés statiques. Aucune instance de la classe ne peut être créée.
Essentiellement, une classe statique vous permet de créer des ensembles de fonctions qui sont regroupées logiquement.

Depuis C # 6, `static` peut également être utilisé avec `using` pour importer des membres et des méthodes statiques. Ils peuvent alors être utilisés sans nom de classe.

Ancienne méthode, sans "utiliser statique":
  
    using System;

    public class ConsoleApplication
    {
        public static void Main()
        {
             Console.WriteLine("Hello World!"); //Writeline is method belonging to static class Console
        }

    }
Exemple avec `using static`

    using static System.Console;

    public class ConsoleApplication
    {
        public static void Main()
        {
             WriteLine("Hello World!"); //Writeline is method belonging to static class Console
        }

    }

**Désavantages**
---------

Bien que les classes statiques puissent être incroyablement utiles, elles s'accompagnent de leurs propres mises en garde :

• Une fois que la classe statique a été appelée, la classe est chargée en mémoire et ne peut pas être exécutée via le ramasse-miettes tant que l'AppDomain hébergeant la classe statique n'est pas déchargé.

• Une classe statique ne peut pas implémenter une interface.

## entier
`int` est un alias pour `System.Int32`, qui est un type de données pour les entiers 32 bits signés. Ce type de données se trouve dans `mscorlib.dll` qui est implicitement référencé par chaque projet C # lorsque vous les créez.

Plage : -2 147 483 648 à 2 147 483 647

    int int1 = -10007;
    var int2 = 2132012521;     

## tête
Mot-clé utilisé pour les entiers 64 bits non signés. Il représente le type de données `System.UInt64` trouvé dans `mscorlib.dll` qui est implicitement référencé par chaque projet C # lorsque vous les créez.

Plage : 0 à 18 446 744 073 709 551 615

    ulong veryLargeInt = 18446744073609451315;
    var anotherVeryLargeInt = 15446744063609451315UL;

## bloquer
`lock` fournit la sécurité des threads pour un bloc de code, de sorte qu'il ne soit accessible que par un seul thread dans le même processus. Exemple:

    private static object _lockObj = new object();
    static void Main(string[] args)
    {
        Task.Run(() => TaskWork());
        Task.Run(() => TaskWork());
        Task.Run(() => TaskWork());
    
        Console.ReadKey();
    }
    
    private static void TaskWork()
    {
        lock(_lockObj)
        {
            Console.WriteLine("Entered");
    
            Task.Delay(3000);
            Console.WriteLine("Done Delaying");
    
            // Access shared resources safely
    
            Console.WriteLine("Leaving");
        }   
    }
    
    Output:

    Entered
    Done Delaying
    Leaving
    Entered
    Done Delaying
    Leaving
    Entered
    Done Delaying
    Leaving

**Cas d'utilisation :**

Chaque fois que vous avez un bloc de code qui peut produire des effets secondaires s'il est exécuté par plusieurs threads en même temps. Le mot-clé lock avec un **objet de synchronisation partagé** (`_objLock` dans l'exemple) peut être utilisé pour empêcher cela.

Notez que `_objLock` ne peut pas être `null` et plusieurs threads exécutant le code doivent utiliser la même instance d'objet (soit en en faisant un champ `static`, soit en utilisant la même instance de classe pour les deux threads)

Du côté du compilateur, le mot-clé lock est un sucre syntaxique qui est remplacé par `Monitor.Enter(_lockObj);` et `Monitor.Exit(_lockObj);`. Donc, si vous remplacez le verrou en entourant le bloc de code avec ces deux méthodes, vous obtiendrez les mêmes résultats. Vous pouvez voir le code réel dans [Syntactic sugar in C# - lock example][1]


[1] : https://www.wikiod.com/fr/docs/c%23/2994/syntactic-sugar-in-c-sharp/10166/lock#t=20160723121800624366

## interne
Le mot clé [`internal`][1] est un modificateur d'accès pour les types et les membres de type. Les types ou membres internes sont **accessibles uniquement dans les fichiers du même assembly**

*usage:*

    public class BaseClass 
    {
        // Only accessible within the same assembly
        internal static int x = 0;
    }


La différence entre les différents modificateurs d'accès est clarifiée [ici][2]

***Modificateurs d'accès***

> **publique**

> > Le type ou le membre est accessible par tout autre code du même assembly ou d'un autre assembly qui le référence.

> **privé**

> > Le type ou le membre n'est accessible que par code dans la même classe ou structure.

> **protégé**

> > Le type ou le membre n'est accessible que par code dans la même classe ou structure, ou dans une classe dérivée.

> **interne**

> > Le type ou le membre est accessible par n'importe quel code dans le même assembly, mais pas à partir d'un autre assembly.

> **interne protégé**

> > Le type ou le membre est accessible par n'importe quel code dans le même assembly, ou par n'importe quelle classe dérivée dans un autre assembly.

Lorsque **aucun modificateur d'accès** n'est défini, un modificateur d'accès par défaut est utilisé. Il y a donc toujours une forme de modificateur d'accès même s'il n'est pas défini.


[1] : https://msdn.microsoft.com/en-us/library/7c5ka91b.aspx
[2] : http://stackoverflow.com/a/614844/266562

## où
`where` peut servir à deux fins en C # : la contrainte de type dans un argument générique et le filtrage des requêtes LINQ.


Dans une classe générique, considérons

    public class Cup<T>
    {
        // ...
    }

T est appelé un paramètre de type. La définition de classe peut imposer des contraintes sur les types réels qui peuvent être fournis pour T.

Les types de contraintes suivants peuvent être appliqués :

* type de valeur
* Type de référence
* constructeur par défaut
* héritage et implémentation

**type de valeur**

Dans ce cas, seuls les "struct" (cela inclut les types de données "primitifs" tels que "int", "booléen", etc.) peuvent être fournis.

    public class Cup<T> where T : struct
    {
        // ...
    }

**Type de référence**

Dans ce cas, seuls les types de classe peuvent être fournis

    public class Cup<T> where T : class
    {
        // ...
    }

**valeur hybride/type de référence**

Parfois, il est souhaitable de restreindre les arguments de type à ceux disponibles dans une base de données, et ceux-ci seront généralement mappés aux types de valeur et aux chaînes. Comme toutes les restrictions de type doivent être respectées, il n'est pas possible de spécifier `where T : struct or string` (ce n'est pas une syntaxe valide). Une solution de contournement consiste à restreindre les arguments de type à [`IConvertible`][1] qui a intégré les types de "... Boolean, SByte, Byte, Int16, UInt16, Int32, UInt32, Int64, UInt64, Single, Double, Decimal, DateHeure, Caractère et Chaîne." Il est possible que d'autres objets implémentent IConvertible, bien que cela soit rare en pratique.

    public class Cup<T> where T : IConvertible
    {
        // ...
    }

**constructeur par défaut**

Seuls les types contenant un constructeur par défaut seront autorisés. Cela inclut les types de valeur et les classes qui contiennent un constructeur par défaut (sans paramètre)


    public class Cup<T> where T : new
    {
        // ...
    }

**héritage et implémentation**

Seuls les types qui héritent d'une certaine classe de base ou implémentent une certaine interface peuvent être fournis.


    public class Cup<T> where T : Beverage
    {
        // ...
    }


    public class Cup<T> where T : IBeer
    {
        // ...
    }


La contrainte peut même référencer un autre paramètre de type :

    public class Cup<T, U> where U : T
    {
        // ...
    }

Plusieurs contraintes peuvent être spécifiées pour un argument de type :

    public class Cup<T> where T : class, new()
    {
        // ...
    }

Les exemples précédents montrent des contraintes génériques sur une définition de classe, mais les contraintes peuvent être utilisées partout où un argument de type est fourni : classes, structures, interfaces, méthodes, etc.
---

`where` peut également être une clause LINQ. Dans ce cas, il est analogue à `WHERE` en SQL :

    int[] nums = { 5, 2, 1, 3, 9, 8, 6, 7, 2, 0 };

    var query =
        from num in nums 
        where num < 5
        select num;

        foreach (var n in query)
        {
            Console.Write(n + " ");
        }
        // prints 2 1 3 2 0


[1] : https://msdn.microsoft.com/en-us/library/system.iconvertible(v=vs.110).aspx

## externe
Le mot-clé `extern` est utilisé pour déclarer des méthodes implémentées en externe. Cela peut être utilisé conjointement avec l'attribut DllImport pour appeler du code non managé à l'aide des services Interop. qui, dans ce cas, viendra avec le modificateur `static`

Par exemple:

    using System.Runtime.InteropServices;
    public class MyClass
    {
        [DllImport("User32.dll")]
        private static extern int SetForegroundWindow(IntPtr point);
    
        public void ActivateProcessWindow(Process p)
        {
            SetForegroundWindow(p.MainWindowHandle);
        }
    }

Cela utilise la méthode SetForegroundWindow importée de la bibliothèque User32.dll

Cela peut également être utilisé pour définir un alias d'assembly externe. ce qui nous permet de référencer différentes versions des mêmes composants à partir d'un seul assemblage.

Pour référencer deux assemblys avec les mêmes noms de type complets, un alias doit être spécifié à une invite de commande, comme suit :

    /r:GridV1=grid.dll
    /r:GridV2=grid20.dll

Cela crée les alias externes GridV1 et GridV2. Pour utiliser ces alias à partir d'un programme, référencez-les à l'aide du mot-clé extern. Par exemple:

    extern alias GridV1;
    extern alias GridV2;


## lorsque
Le `when` est un mot-clé ajouté dans **C# 6**, et il est utilisé pour le filtrage des exceptions.

Avant l'introduction du mot clé `when`, vous auriez pu avoir une clause catch pour chaque type d'exception ; avec l'ajout du mot-clé, un contrôle plus fin est désormais possible.

Une expression `when` est attachée à une branche `catch`, et seulement si la condition `when` est `true`, la clause `catch` sera exécutée. Il est possible d'avoir plusieurs clauses `catch` avec les mêmes types de classe d'exception et différentes conditions `when`.



    private void CatchException(Action action)
    {
        try
        {
            action.Invoke();
        }
        
        // exception filter
        catch (Exception ex) when (ex.Message.Contains("when"))
        {
            Console.WriteLine("Caught an exception with when");
        }
    
        catch (Exception ex)
        {
            Console.WriteLine("Caught an exception without when");
        }
    }

    private void Method1() { throw new Exception("message for exception with when"); }
    private void Method2() { throw new Exception("message for general exception"); }
    
    
    CatchException(Method1);
    CatchException(Method2);

## si, si... sinon, si... sinon si
----------


L'instruction `if` est utilisée pour contrôler le déroulement du programme. Une instruction "if" identifie l'instruction à exécuter en fonction de la valeur d'une expression "booléenne".

Pour une seule instruction, les `accolades`{} sont facultatives mais recommandées.

    int a = 4;
    if(a % 2 == 0) 
    {
         Console.WriteLine("a contains an even number");
    }
    // output: "a contains an even number"


----------


Le `if` peut également avoir une clause `else`, qui sera exécutée si la condition est évaluée à false :

    int a = 5;
    if(a % 2 == 0) 
    {
         Console.WriteLine("a contains an even number");
    }
    else
    {
         Console.WriteLine("a contains an odd number");
    }
    // output: "a contains an odd number"


----------


La construction `if`...`else if` vous permet de spécifier plusieurs conditions :

    int a = 9;
    if(a % 2 == 0) 
    {
         Console.WriteLine("a contains an even number");
    }
    else if(a % 3 == 0) 
    {
         Console.WriteLine("a contains an odd number that is a multiple of 3"); 
    }
    else
    {
         Console.WriteLine("a contains an odd number");
    }
    // output: "a contains an odd number that is a multiple of 3"

*Important de noter* que si une condition est remplie dans l'exemple ci-dessus, le contrôle ignore les autres tests et saute à la fin de cette construction if else particulière. Ainsi, l'*ordre* des tests est important si vous utilisez if .. sinon si construire
----------

Les expressions booléennes C# utilisent [évaluation de court-circuit][1]. Ceci est important dans les cas où l'évaluation des conditions peut avoir des effets secondaires :

    if (someBooleanMethodWithSideEffects() && someOtherBooleanMethodWithSideEffects()) {
      //...
    }
Il n'y a aucune garantie que `someOtherBooleanMethodWithSideEffects` fonctionnera réellement.

C'est également important dans les cas où les conditions antérieures garantissent qu'il est "sûr" d'évaluer les conditions ultérieures. Par exemple:

    if (someCollection != null && someCollection.Count > 0) {
       // ..
    }
L'ordre est très important dans ce cas car, si on inverse l'ordre :

    if (someCollection.Count > 0 && someCollection != null) {
il lèvera une `NullReferenceException` si `someCollection` est `null`.

[1] : https://en.wikipedia.org/wiki/Short-circuit_evaluation

## structure
Un type "struct" est un type de valeur généralement utilisé pour encapsuler de petits groupes de variables associées, telles que les coordonnées d'un rectangle ou les caractéristiques d'un élément dans un inventaire.

> [Classes] [1] sont des types de référence, les structures sont des types de valeur.

    using static System.Console;
    
    namespace ConsoleApplication1
    {
        struct Point
        {
            public int X;
            public int Y;
    
            public override string ToString()
            {
                return $"X = {X}, Y = {Y}";
            }
    
            public void Display(string name)
            {
                WriteLine(name + ": " + ToString());
            }
        }
    
        class Program
        {
            static void Main()
            {
                var point1 = new Point {X = 10, Y = 20};
                // it's not a reference but value type
                var point2 = point1;
                point2.X = 777;
                point2.Y = 888;
                point1.Display(nameof(point1)); // point1: X = 10, Y = 20
                point2.Display(nameof(point2)); // point2: X = 777, Y = 888
    
                ReadKey();
            }
        }
    }

    
----------
Les structures peuvent également contenir des constructeurs, des constantes, des champs, des méthodes, des propriétés, des indexeurs, des opérateurs, des événements et des types imbriqués, bien que si plusieurs de ces membres sont requis, vous devriez plutôt envisager de faire de votre type une classe.


----------


**Quelques [suggestions][2] de MS sur quand utiliser struct et quand utiliser class :**

*ENVISAGER*

définir une structure au lieu d'une classe si les instances du type sont petites et généralement de courte durée ou sont généralement intégrées dans d'autres objets.

*ÉVITER DE*

définissant une structure à moins que le type n'ait toutes les caractéristiques suivantes :
 

- Il représente logiquement une valeur unique, similaire aux types primitifs
(entier, double, etc.)
- Sa taille d'instance est inférieure à 16 octets.
- Il est immuable.
- Il n'aura pas à être mis en boîte fréquemment.


[1] : http://stackoverflow.com/a/3924092/266562
[2] : https://msdn.microsoft.com/en-us/library/ms229017.aspx

## changer
L'instruction `switch` est une instruction de contrôle qui sélectionne une section de commutateur à exécuter à partir d'une liste de candidats. Une instruction switch comprend une ou plusieurs sections switch. Chaque section switch contient une ou plusieurs étiquettes "case" suivies d'une ou plusieurs instructions. Si aucune étiquette de cas ne contient de valeur correspondante, le contrôle est transféré à la section "default", s'il y en a une. La chute de cas n'est pas prise en charge en C #, à proprement parler. Cependant, si 1 ou plusieurs étiquettes `case` sont vides, l'exécution suivra le code du bloc `case` suivant qui contient du code. Cela permet de regrouper plusieurs étiquettes `case` avec la même implémentation. Dans l'exemple suivant, si `month` est égal à 12, le code dans `case 2` sera exécuté puisque les étiquettes `case` `12` `1` et `2` sont regroupées. Si un bloc `case` n'est pas vide, un `break` doit être présent avant la prochaine étiquette `case`, sinon le compilateur signalera une erreur.

    int month = DateTime.Now.Month; // this is expected to be 1-12 for Jan-Dec

    switch (month)
    {
        case 12: 
        case 1: 
        case 2:
            Console.WriteLine("Winter");
            break;
        case 3: 
        case 4: 
        case 5:
            Console.WriteLine("Spring");
            break;
        case 6: 
        case 7: 
        case 8:
            Console.WriteLine("Summer");
            break;
        case 9:     
        case 10: 
        case 11:
            Console.WriteLine("Autumn");
            break;
        default:
            Console.WriteLine("Incorrect month index");
            break;
    }

Un `case` ne peut être étiqueté que par une valeur connue au *moment de la compilation* (par exemple, `1`, `"str"`, `Enum.A`), donc une `variable` n'est pas une étiquette `case` valide , mais une valeur `const` ou `Enum` est (ainsi que toute valeur littérale).

## peu sûr
Le mot-clé `unsafe` peut être utilisé dans les déclarations de type ou de méthode ou pour déclarer un bloc en ligne.

Le but de ce mot-clé est de permettre l'utilisation du *sous-ensemble non sécurisé* de C# pour le bloc en question. Le sous-ensemble non sécurisé comprend des fonctionnalités telles que les pointeurs, l'allocation de pile, les tableaux de type C, etc.

Le code non sécurisé n'est pas vérifiable et c'est pourquoi son utilisation est déconseillée. La compilation de code non sécurisé nécessite de passer un commutateur au compilateur C#. De plus, le CLR exige que l'assembly en cours d'exécution ait une confiance totale.

Malgré ces limitations, le code non sécurisé a des utilisations valides pour rendre certaines opérations plus performantes (par exemple, l'indexation de tableaux) ou plus faciles (par exemple, l'interopérabilité avec certaines bibliothèques non gérées).

Comme exemple très simple

    // compile with /unsafe
    class UnsafeTest
    {
       unsafe static void SquarePtrParam(int* p)
       {
          *p *= *p; // the '*' dereferences the pointer.
          //Since we passed in "the address of i", this becomes "i *= i"
       }
    
       unsafe static void Main()
       {
          int i = 5;
          // Unsafe method: uses address-of operator (&):
          SquarePtrParam(&i); // "&i" means "the address of i". The behavior is similar to "ref i"
          Console.WriteLine(i); // Output: 25
       }
    }

En travaillant avec des pointeurs, nous pouvons modifier directement les valeurs des emplacements de mémoire, plutôt que de devoir les adresser par leur nom. Notez que cela nécessite souvent l'utilisation du mot-clé [fixed][1] pour éviter une éventuelle corruption de la mémoire lorsque le ramasse-miettes déplace les éléments (sinon, vous risquez d'obtenir [error CS0212][2]). Puisqu'une variable qui a été "fixée" ne peut pas être écrite, nous devons aussi souvent avoir un deuxième pointeur qui commence par pointer vers le même emplacement que le premier.

    void Main()
    {
        int[] intArray = new int[] { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10};

        UnsafeSquareArray(intArray);
        foreach(int i in intArray)
            Console.WriteLine(i);
    }
    
    unsafe static void UnsafeSquareArray(int[] pArr)
    {
        int len = pArr.Length;

        //in C or C++, we could say
        // int* a = &(pArr[0])
        // however, C# requires you to "fix" the variable first 
        fixed(int* fixedPointer = &(pArr[0]))
        {
            //Declare a new int pointer because "fixedPointer" cannot be written to.
            // "p" points to the same address space, but we can modify it
            int* p = fixedPointer;

            for (int i = 0; i < len; i++)
            {
                *p *= *p; //square the value, just like we did in SquarePtrParam, above
                p++;      //move the pointer to the next memory space.
                          // NOTE that the pointer will move 4 bytes since "p" is an
                          // int pointer and an int takes 4 bytes

                //the above 2 lines could be written as one, like this:
                // "*p *= *p++;"
            }
        }
    }

Production:

    1
    4
    9
    16
    25
    36
    49
    64
    81
    100


`unsafe` permet également l'utilisation de [stackalloc][3] qui allouera de la mémoire sur la pile comme _alloca dans la bibliothèque d'exécution C. Nous pouvons modifier l'exemple ci-dessus pour utiliser `stackalloc` comme suit :


    unsafe void Main()
    {
        const int len=10;
        int* seedArray = stackalloc int[len];
        
        //We can no longer use the initializer "{ 1, 2, 3, 4, 5, 6, 7, 8, 9, 10}" as before.
        // We have at least 2 options to populate the array. The end result of either
        // option will be the same (doing both will also be the same here).

        //FIRST OPTION:
        int* p = seedArray; // we don't want to lose where the array starts, so we
                            // create a shadow copy of the pointer
        for(int i=1; i<=len; i++)
            *p++ = i;
        //end of first option

        //SECOND OPTION:
        for(int i=0; i<len; i++)
            seedArray[i] = i+1;
        //end of second option

        UnsafeSquareArray(seedArray, len);
        for(int i=0; i< len; i++)
            Console.WriteLine(seedArray[i]);
    }
    
    //Now that we are dealing directly in pointers, we don't need to mess around with
    // "fixed", which dramatically simplifies the code
    unsafe static void UnsafeSquareArray(int* p, int len)
    {
        for (int i = 0; i < len; i++)
            *p *= *p++;
    }

(La sortie est la même que ci-dessus)


[1] : https://www.wikiod.com/fr/docs/c%23/26/keywords/59/fixed#t=20160802171014149858
[2] : https://msdn.microsoft.com/en-us/library/29ak9b70(v=vs.140).aspx
[3] : https://www.wikiod.com/fr/docs/c%23/26/keywords/57/stackalloc#t=20160802171014149858

## vrai faux
Les mots clés "true" et "false" ont deux utilisations :

1. En tant que valeurs booléennes littérales


    var myTrueBool = true;
    var myFalseBool = false;

2. En tant qu'opérateurs pouvant être surchargés


    public static bool operator true(MyClass x)
    {
        return x.value >= 0;
    }

    public static bool operator false(MyClass x)
    {
        return x.value < 0;
    }

La surcharge de l'opérateur false était utile avant C# 2.0, avant l'introduction des types "Nullable".
Un type qui surcharge l'opérateur "true" doit également surcharger l'opérateur "false".

## a été
Une variable locale implicitement typée qui est fortement typée comme si l'utilisateur avait déclaré le type. Contrairement aux autres déclarations de variable, le compilateur détermine le type de variable que cela représente en fonction de la valeur qui lui est affectée.

    var i = 10; // implicitly typed, the compiler must determine what type of variable this is
    int i = 10; // explicitly typed, the type of variable is explicitly stated to the compiler

    // Note that these both represent the same type of variable (int) with the same value (10).

Contrairement aux autres types de variables, les définitions de variables avec ce mot-clé doivent être initialisées lors de leur déclaration. Cela est dû au mot clé **var** représentant une variable implicitement typée.

    var i;
    i = 10;

    // This code will not run as it is not initialized upon declaration.

Le mot clé **var** peut également être utilisé pour créer de nouveaux types de données à la volée. Ces nouveaux types de données sont appelés *types anonymes*. Ils sont très utiles, car ils permettent à un utilisateur de définir un ensemble de propriétés sans avoir à déclarer explicitement un type d'objet au préalable.

* Type anonyme simple *

    var a = new { number = 1, text = "hi" };

*Requête LINQ qui retourne un type anonyme*

    public class Dog
    {
        public string Name { get; set; }
        public int Age { get; set; }
    }

    public class DogWithBreed
    {
        public Dog Dog { get; set; }
        public string BreedName  { get; set; }
    }

    public void GetDogsWithBreedNames()
    {
        var db = new DogDataContext(ConnectString);
        var result = from d in db.Dogs
                 join b in db.Breeds on d.BreedId equals b.BreedId
                 select new 
                        {
                            DogName = d.Name,
                            BreedName = b.BreedName
                        };

        DoStuff(result);
    }

Vous pouvez utiliser le mot-clé var dans l'instruction foreach

    public bool hasItemInList(List<String> list, string stringToSearch)
    {
        foreach(var item in list)
        {
            if( ( (string)item ).equals(stringToSearch) )
                return true;
        }

        return false;
    }

## énumération
Le mot clé `enum` indique au compilateur que cette classe hérite de la classe abstraite `Enum`, sans que le programmeur n'ait à en hériter explicitement. `Enum` est un descendant de `ValueType`, qui est destiné à être utilisé avec un ensemble distinct de constantes nommées.

    public enum DaysOfWeek
    {
        Monday,
        Tuesday,
    }

Vous pouvez éventuellement spécifier une valeur spécifique pour chacun (ou certains d'entre eux) :

    public enum NotableYear
    {
       EndOfWwI = 1918;
       EnfOfWwII = 1945,
    }

Dans cet exemple, j'ai omis une valeur pour 0, c'est généralement une mauvaise pratique. Un `enum` aura toujours une valeur par défaut produite par une conversion explicite `(YourEnumType) 0`, où `YourEnumType` est votre type `enume` déclaré. Sans une valeur de 0 définie, un `enum` n'aura pas de valeur définie à l'initiation.

Le type sous-jacent par défaut de `enum` est `int`, vous pouvez changer le type sous-jacent en n'importe quel type intégral, y compris `byte`, `sbyte`, `short`, `ushort`, `int`, `uint`, `long ` et `ulong`. Ci-dessous se trouve une énumération avec le type sous-jacent `byte` :

    enum Days : byte
    {
        Sunday = 0,
        Monday,
        Tuesday,
        Wednesday,
        Thursday,
        Friday,
        Saturday
    };

Notez également que vous pouvez convertir vers/depuis le type sous-jacent simplement avec un cast :

    int value = (int)NotableYear.EndOfWwI;

Pour ces raisons, vous feriez mieux de toujours vérifier si un `enum` est valide lorsque vous exposez des fonctions de bibliothèque :

    void PrintNotes(NotableYear year)
    {
        if (!Enum.IsDefined(typeof(NotableYear), year))
            throw InvalidEnumArgumentException("year", (int)year, typeof(NotableYear));
    
        // ...
    }



## dans
Le mot-clé "in" a trois utilisations :

a) Dans le cadre de la syntaxe d'une instruction "foreach" ou dans le cadre de la syntaxe d'une requête LINQ

    foreach (var member in sequence)
    {
        // ...
    }

b) Dans le contexte des interfaces génériques et des types délégués génériques, signifie _contravariance_ pour le paramètre de type en question :

    public interface IComparer<in T>
    {
        // ...
    }

c) Dans le contexte de la requête LINQ fait référence à la collection qui est interrogée

    var query = from x in source select new { x.Name, x.ID, };


## taille de
Utilisé pour obtenir la taille en octets pour un type non managé

    int byteSize = sizeof(byte) // 1
    int sbyteSize = sizeof(sbyte) // 1
    int shortSize = sizeof(short) // 2
    int ushortSize = sizeof(ushort) // 2
    int intSize = sizeof(int) // 4
    int uintSize = sizeof(uint) // 4
    int longSize = sizeof(long) // 8
    int ulongSize = sizeof(ulong) // 8
    int charSize = sizeof(char) // 2(Unicode)
    int floatSize = sizeof(float) // 4
    int doubleSize = sizeof(double) // 8
    int decimalSize = sizeof(decimal) // 16
    int boolSize = sizeof(bool) // 1

## long
Le mot-clé **long** est utilisé pour représenter des entiers 64 bits signés. Il s'agit d'un alias pour le type de données `System.Int64` présent dans `mscorlib.dll`, qui est implicitement référencé par chaque projet C # lorsque vous les créez.

*Toute variable **longue** peut être déclarée explicitement et implicitement :*

    long long1 = 9223372036854775806;  // explicit declaration, long keyword used
    var long2 = -9223372036854775806L; // implicit declaration, 'L' suffix used

Une variable **longue** peut contenir n'importe quelle valeur comprise entre –9 223 372 036 854 775 808 et 9 223 372 036 854 775 807, et peut être utile dans les situations où une variable doit contenir une valeur qui dépasse les limites de quelles autres variables (telles que [**int**][ 1] variable) peut contenir.


[1] : https://www.wikiod.com/fr/docs/c%23/26/keywords#t=201608201800043158849

## booléen
Mot-clé pour stocker les valeurs booléennes `true` et `false`. bool est un alias de System.Boolean.

La valeur par défaut d'un bool est false.

    bool b; // default value is false
    b = true; // true
    b = ((5 + 2) == 6); // false

Pour qu'un bool autorise les valeurs nulles, il doit être initialisé en tant que bool?.

La valeur par défaut d'un booléen ? est nul.

    bool? a // default value is null

## décoché
Le mot-clé `unchecked` empêche le compilateur de vérifier les débordements/sous-dépassements.

Par exemple:

    const int ConstantMax = int.MaxValue;
    unchecked
    {
        int1 = 2147483647 + 10;
    }
    int1 = unchecked(ConstantMax + 10);

Sans le mot clé `unchecked`, aucune des deux opérations d'addition ne sera compilée.

## Quand est-ce utile ?

Ceci est utile car cela peut aider à accélérer les calculs qui ne déborderont certainement pas car la vérification du dépassement prend du temps, ou lorsqu'un débordement/sous-dépassement est un comportement souhaité (par exemple, lors de la génération d'un code de hachage).

## fais
L'opérateur do itère sur un bloc de code jusqu'à ce qu'une requête conditionnelle soit égale à false. La boucle do-while peut également être interrompue par un [`goto`](https://www.wikiod.com/fr/docs/c%23/26/keywords/193/goto), [`return`](http:// stackoverflow.com/documentation/c%23/26/keywords/4600/return), [`break`](https://www.wikiod.com/fr/docs/c%23/26/keywords/2858/break) ou `throw ` déclaration.

La syntaxe du mot-clé `do` est :

> faire
> { *bloc de code ;* }
> tant que( *condition* );


Exemple:

    int i = 0;

    do
    {
        Console.WriteLine("Do is on loop number {0}.", i);
    } while (i++ < 5);


Production:

>"Do est sur la boucle numéro 1." \
"Do est sur la boucle numéro 2."\
"Do est sur la boucle numéro 3."\
"Do est sur la boucle numéro 4."\
"Do est sur la boucle numéro 5."


Contrairement à la boucle [`while`](https://www.wikiod.com/fr/docs/c%23/26/keywords/4396/while), la boucle do-while est **Exit Controlled**. Cela signifie que la boucle do-while exécuterait ses instructions au moins une fois, même si la condition échoue la première fois.


    bool a = false;

    do
    {
        Console.WriteLine("This will be printed once, even if a is false.");
    } while (a == true);

## interface
Une [`interface`][1] contient les [signatures][2] des méthodes, des propriétés et des événements. Les classes dérivées définissent les membres car l'interface ne contient que la déclaration des membres.

Une interface est déclarée à l'aide du mot-clé `interface`.

    interface IProduct
    {
        decimal Price { get; }
    }
    
    class Product : IProduct
    {
        const decimal vat = 0.2M;
        
        public Product(decimal price)
        {
            _price = price;
        }
        
        private decimal _price;
        public decimal Price { get { return _price * (1 + vat); } }
    }


[1] : http://stackoverflow.com/questions/tagged/interface+c%23
[2] : http://stackoverflow.com/questions/tagged/signature+c%23

## implicite
Le mot clé `implicit` est utilisé pour surcharger un opérateur de conversion. Par exemple, vous pouvez déclarer une classe `Fraction` qui devrait être automatiquement convertie en `double` si nécessaire, et qui peut être automatiquement convertie à partir de `int` :

    class Fraction(int numerator, int denominator)
    {
        public int Numerator { get; } = numerator;
        public int Denominator { get; } = denominator;
        // ...
        public static implicit operator double(Fraction f)
        {
            return f.Numerator / (double) f.Denominator;
        }
        public static implicit operator Fraction(int i)
        {
            return new Fraction(i, 1);
        }
    }

## ushort
Un type numérique utilisé pour stocker des entiers positifs 16 bits. `ushort` est un alias pour `System.UInt16` et occupe 2 octets de mémoire.

La plage valide va de `0` à `65535`.

```
ushort a = 50; // 50
ushort b = 65536; // Error, cannot be converted
ushort c = unchecked((ushort)65536); // Overflows (wraps around to 0)
```

## délégué
Les délégués sont des types qui représentent une référence à une méthode. Ils sont utilisés pour passer des méthodes comme arguments à d'autres méthodes.

Les délégués peuvent contenir des méthodes statiques, des méthodes d'instance, des méthodes anonymes ou des expressions lambda.
   
```
class DelegateExample
{
    public void Run()
    {
        //using class method
        InvokeDelegate( WriteToConsole ); 
        
        //using anonymous method
        DelegateInvoker di = delegate ( string input ) 
        { 
            Console.WriteLine( string.Format( "di: {0} ", input ) );
            return true; 
        };
        InvokeDelegate( di ); 
        
        //using lambda expression
        InvokeDelegate( input => false ); 
    }

    public delegate bool DelegateInvoker( string input );

    public void InvokeDelegate(DelegateInvoker func)
    {
        var ret = func( "hello world" );
        Console.WriteLine( string.Format( " > delegate returned {0}", ret ) );
    }

    public bool WriteToConsole( string input )
    {
        Console.WriteLine( string.Format( "WriteToConsole: '{0}'", input ) );
        return true;
    }
}
```

Lors de l'affectation d'une méthode à un délégué, il est important de noter que la méthode doit avoir le même type de retour ainsi que les mêmes paramètres. Cela diffère de la surcharge de méthode "normale", où seuls les paramètres définissent la signature de la méthode.

Les événements sont construits au-dessus des délégués.

## partiel
Le mot-clé `partial` peut être utilisé lors de la définition du type de la classe, de la structure ou de l'interface pour permettre à la définition du type d'être divisée en plusieurs fichiers. Ceci est utile pour incorporer de nouvelles fonctionnalités dans le code généré automatiquement.

**Fichier1.cs**

    namespace A
    {
        public partial class Test
        {
            public string Var1 {get;set;}
        }
    }

**Fichier2.cs**

    namespace A
    {
        public partial class Test
        {
            public string Var2 {get;set;}
        }
    }

**Remarque :** Une classe peut être divisée en n'importe quel nombre de fichiers. Cependant, toutes les déclarations doivent être sous le même espace de noms et le même assembly.

Les méthodes peuvent également être déclarées partielles à l'aide du mot clé `partial`. Dans ce cas, un fichier contiendra uniquement la définition de la méthode et un autre fichier contiendra l'implémentation.

> Une méthode partielle a sa signature définie dans une partie d'un type partiel, et son implémentation définie dans une autre partie du type. Les méthodes partielles permettent aux concepteurs de classes de fournir des crochets de méthode, similaires aux gestionnaires d'événements, que les développeurs peuvent décider d'implémenter ou non. Si le développeur ne fournit pas d'implémentation, le compilateur supprime la signature au moment de la compilation. Les conditions suivantes s'appliquent aux méthodes partielles :
> * Les signatures dans les deux parties du type partiel doivent correspondre.
> * La méthode doit retourner void.
> * Aucun modificateur d'accès n'est autorisé. Les méthodes partielles sont implicitement privées.
>
> -- MSDN

**Fichier1.cs**

    namespace A
    {
        public partial class Test
        {
            public string Var1 {get;set;}
            public partial Method1(string str);
        }
    }

**Fichier2.cs**

    namespace A
    {
        public partial class Test
        {
            public string Var2 {get;set;}
            public partial Method1(string str)
            {
                Console.WriteLine(str);
            }
        }
    }


**Remarque :** Le type contenant la méthode partial doit également être déclaré partial.

 




## octet
Un type numérique utilisé pour stocker des entiers *signés* 8 bits. `sbyte` est un alias pour `System.SByte` et occupe 1 octet de mémoire. Pour l'équivalent non signé, utilisez `byte`.

La plage valide est comprise entre `-127` et `127` (le reste est utilisé pour stocker le signe).

```
sbyte a = 127; // 127
sbyte b = -127; // -127
sbyte c = 200; // Error, cannot be converted
sbyte d = unchecked((sbyte)129); // -127 (overflows)
```

## un événement
Un "événement" permet au développeur d'implémenter un modèle de notification.

**Exemple simple**

    public class Server
    {
        // defines the event
        public event EventHandler DataChangeEvent;

        void RaiseEvent()
        {
            var ev = DataChangeEvent;
            if(ev != null)
            {
                ev(this, EventArgs.Empty);
            }
        }
    }

    public class Client
    {
        public void Client(Server server)
        {
            // client subscribes to the server's DataChangeEvent
            server.DataChangeEvent += server_DataChanged;
        }

        private void server_DataChanged(object sender, EventArgs args)
        {
            // notified when the server raises the DataChangeEvent
        }
    }

[Référence MSDN][1]


[1] : https://msdn.microsoft.com/en-CA/library/awbftdfh.aspx

